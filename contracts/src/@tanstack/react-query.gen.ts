// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { Accreditation, Appointments, AuditLogs, Billing, Context, Encounters, ExampleComments, ExamplePosts, Files, Health, Integrations, Jobs, Laboratory, Migration, NotificationPreferences, Notifications, type Options, Organizations, Patients, Practitioners, Roles, Webhooks } from '../sdk.gen';
import type { AccreditationStandardsCreateData, AccreditationStandardsCreateResponse, AccreditationStandardsGetData, AccreditationStandardsGetResponse, AccreditationStandardsListData, AccreditationStandardsListResponse, AccreditationStandardsUpdateData, AccreditationStandardsUpdateResponse, AllUserRolesListData, AllUserRolesListResponse, AppointmentsCancelData, AppointmentsCancelResponse, AppointmentsCheckInData, AppointmentsCheckInResponse, AppointmentsCreateData, AppointmentsCreateResponse, AppointmentsGetData, AppointmentsGetResponse, AppointmentsListData, AppointmentsListResponse, AppointmentSlotsBlockData, AppointmentSlotsBlockResponse, AppointmentSlotsGenerateData, AppointmentSlotsGenerateResponse, AppointmentSlotsListData, AppointmentSlotsListResponse, AppointmentSlotsUnblockData, AppointmentSlotsUnblockResponse, AppointmentsNoShowData, AppointmentsNoShowResponse, AppointmentsRescheduleData, AppointmentsRescheduleResponse, AppointmentsUpdateData, AppointmentsUpdateResponse, AuditLogsExportData, AuditLogsExportResponse, AuditLogsGetData, AuditLogsGetResponse, AuditLogsListData, AuditLogsListResponse, AvailableContextsListData, AvailableContextsListResponse, BranchesCreateData, BranchesCreateResponse, BranchesDeleteData, BranchesDeleteResponse, BranchesGetData, BranchesGetResponse, BranchesListData, BranchesListResponse, BranchesUpdateData, BranchesUpdateResponse, ChronicConditionsCreateData, ChronicConditionsCreateResponse, ChronicConditionsDeleteData, ChronicConditionsDeleteResponse, ChronicConditionsListData, ChronicConditionsListResponse, ChronicConditionsUpdateData, ChronicConditionsUpdateResponse, ClinicalAuditsApproveData, ClinicalAuditsApproveResponse, ClinicalAuditsCompleteData, ClinicalAuditsCompleteResponse, ClinicalAuditsCreateData, ClinicalAuditsCreateResponse, ClinicalAuditsGetData, ClinicalAuditsGetResponse, ClinicalAuditsListData, ClinicalAuditsListResponse, ContextSwitchSwitchData, ContextSwitchSwitchResponse, CurrentUserContextGetData, CurrentUserContextGetResponse, DiagnosesCreateData, DiagnosesCreateResponse, DiagnosesDeleteData, DiagnosesDeleteResponse, DiagnosesListData, DiagnosesListResponse, DiagnosesUpdateData, DiagnosesUpdateResponse, DiagnosticReportsCreateData, DiagnosticReportsCreateResponse, DiagnosticReportsFinalizeData, DiagnosticReportsFinalizeResponse, DiagnosticReportsGetData, DiagnosticReportsGetResponse, DiagnosticReportsListData, DiagnosticReportsListResponse, DocumentControlsApproveData, DocumentControlsApproveResponse, DocumentControlsCreateData, DocumentControlsCreateResponse, DocumentControlsGetData, DocumentControlsGetResponse, DocumentControlsListData, DocumentControlsListResponse, DocumentControlsPublishData, DocumentControlsPublishResponse, DocumentControlsRetireData, DocumentControlsRetireResponse, DocumentControlsSubmitForReviewData, DocumentControlsSubmitForReviewResponse, EncountersCancelData, EncountersCancelResponse, EncountersCompleteData, EncountersCompleteResponse, EncountersCreateData, EncountersCreateResponse, EncountersGetData, EncountersGetResponse, EncountersListData, EncountersListResponse, EncountersUpdateData, EncountersUpdateResponse, ExampleCommentsBatchCreateData, ExampleCommentsBatchCreateResponse, ExampleCommentsBatchSoftDeleteData, ExampleCommentsBatchSoftDeleteResponse, ExampleCommentsCreateData, ExampleCommentsCreateResponse, ExampleCommentsDeleteData, ExampleCommentsDeletePermanentData, ExampleCommentsDeletePermanentResponse, ExampleCommentsDeleteResponse, ExampleCommentsGetData, ExampleCommentsGetResponse, ExampleCommentsListData, ExampleCommentsListResponse, ExampleCommentsRestoreData, ExampleCommentsRestoreResponse, ExampleCommentsUpdateData, ExampleCommentsUpdateResponse, ExamplePostsBatchCreateData, ExamplePostsBatchCreateResponse, ExamplePostsBatchRestoreData, ExamplePostsBatchRestoreResponse, ExamplePostsBatchSoftDeleteData, ExamplePostsBatchSoftDeleteResponse, ExamplePostsBatchUpdateData, ExamplePostsBatchUpdateResponse, ExamplePostsCreateData, ExamplePostsCreateResponse, ExamplePostsDeleteData, ExamplePostsDeletePermanentData, ExamplePostsDeletePermanentResponse, ExamplePostsDeleteResponse, ExamplePostsGetData, ExamplePostsGetResponse, ExamplePostsListCursorData, ExamplePostsListCursorResponse, ExamplePostsListData, ExamplePostsListDeletedData, ExamplePostsListDeletedResponse, ExamplePostsListResponse, ExamplePostsRestoreData, ExamplePostsRestoreResponse, ExamplePostsUpdateData, ExamplePostsUpdateResponse, FilesConfirmUploadData, FilesConfirmUploadResponse, FilesDeleteData, FilesDeletePermanentData, FilesDeletePermanentResponse, FilesDeleteResponse, FilesDirectUploadData, FilesDirectUploadResponse, FilesDownloadData, FilesDownloadResponse, FilesGetData, FilesGetResponse, FilesInitiateUploadData, FilesInitiateUploadResponse, FilesListData, FilesListResponse, FilesUpdateData, FilesUpdateResponse, GlobalRolesCreateData, GlobalRolesCreateResponse, GlobalRolesDeleteData, GlobalRolesDeleteResponse, GlobalRolesGetData, GlobalRolesGetResponse, GlobalRolesListData, GlobalRolesListResponse, GlobalRolesUpdateData, GlobalRolesUpdateResponse, HealthCheckData, HealthCheckResponse, InfectionSurveillancesConfirmData, InfectionSurveillancesConfirmResponse, InfectionSurveillancesGetData, InfectionSurveillancesGetResponse, InfectionSurveillancesListData, InfectionSurveillancesListResponse, InfectionSurveillancesReportData, InfectionSurveillancesReportResponse, InfectionSurveillancesResolveData, InfectionSurveillancesResolveResponse, IntegrationDashboardGetData, IntegrationDashboardGetResponse, IntegrationErrorLogsGetData, IntegrationErrorLogsGetResponse, IntegrationErrorLogsIgnoreData, IntegrationErrorLogsIgnoreResponse, IntegrationErrorLogsListData, IntegrationErrorLogsListResponse, IntegrationErrorLogsResolveData, IntegrationErrorLogsResolveResponse, IntegrationSyncQueuesCancelData, IntegrationSyncQueuesCancelResponse, IntegrationSyncQueuesGetData, IntegrationSyncQueuesGetResponse, IntegrationSyncQueuesListData, IntegrationSyncQueuesListResponse, IntegrationSyncQueuesRetryData, IntegrationSyncQueuesRetryResponse, InvoicesApproveData, InvoicesApproveResponse, InvoicesCreateData, InvoicesCreateResponse, InvoicesGetData, InvoicesGetResponse, InvoicesGetSummaryData, InvoicesGetSummaryResponse, InvoicesListData, InvoicesListResponse, InvoicesUpdateData, InvoicesUpdateResponse, InvoicesVoidInvoiceData, InvoicesVoidInvoiceResponse, JknConfigsCreateData, JknConfigsCreateResponse, JknConfigsDeleteData, JknConfigsDeleteResponse, JknConfigsGetData, JknConfigsGetResponse, JknConfigsListData, JknConfigsListResponse, JknConfigsTestData, JknConfigsTestResponse, JknConfigsUpdateData, JknConfigsUpdateResponse, JobsCancelData, JobsCancelResponse, JobsGetData, JobsGetResponse, JobsListData, JobsListResponse, LabOrdersCancelData, LabOrdersCancelResponse, LabOrdersCreateData, LabOrdersCreateResponse, LabOrdersGetData, LabOrdersGetResponse, LabOrdersListData, LabOrdersListResponse, LabOrdersUpdateStatusData, LabOrdersUpdateStatusResponse, LabResultsEnterData, LabResultsEnterResponse, LabResultsGetData, LabResultsGetResponse, LabResultsListData, LabResultsListResponse, LabResultsUnverifyData, LabResultsUnverifyResponse, LabResultsVerifyData, LabResultsVerifyResponse, LabTestsCreateData, LabTestsCreateResponse, LabTestsDeleteData, LabTestsDeleteResponse, LabTestsGetData, LabTestsGetResponse, LabTestsListData, LabTestsListResponse, LabTestsUpdateData, LabTestsUpdateResponse, MigrationGetStatusData, MigrationGetStatusResponse, NotificationPreferencesRoutesGetPreferencesData, NotificationPreferencesRoutesGetPreferencesResponse, NotificationPreferencesRoutesUpdatePreferencesData, NotificationPreferencesRoutesUpdatePreferencesResponse, NotificationsDeleteData, NotificationsDeleteResponse, NotificationsGetData, NotificationsGetResponse, NotificationsGetUnreadCountData, NotificationsGetUnreadCountResponse, NotificationsListData, NotificationsListResponse, NotificationsMarkAllReadData, NotificationsMarkAllReadResponse, NotificationsMarkReadData, NotificationsMarkReadResponse, NotificationsMarkUnreadData, NotificationsMarkUnreadResponse, NotificationsRestoreData, NotificationsRestoreResponse, NotificationsSendData, NotificationsSendResponse, OrganizationsCreateData, OrganizationsCreateResponse, OrganizationsDeleteData, OrganizationsDeleteResponse, OrganizationsGetData, OrganizationsGetResponse, OrganizationsListData, OrganizationsListResponse, OrganizationsUpdateData, OrganizationsUpdateResponse, PatientAllergiesCreateData, PatientAllergiesCreateResponse, PatientAllergiesDeleteData, PatientAllergiesDeleteResponse, PatientAllergiesListData, PatientAllergiesListResponse, PatientAllergiesUpdateData, PatientAllergiesUpdateResponse, PatientSafetyIncidentsGetData, PatientSafetyIncidentsGetResponse, PatientSafetyIncidentsInvestigateData, PatientSafetyIncidentsInvestigateResponse, PatientSafetyIncidentsListData, PatientSafetyIncidentsListResponse, PatientSafetyIncidentsReportData, PatientSafetyIncidentsReportResponse, PatientSafetyIncidentsResolveData, PatientSafetyIncidentsResolveResponse, PatientsCreateData, PatientsCreateResponse, PatientsDeleteData, PatientsDeleteResponse, PatientsGetData, PatientsGetResponse, PatientsListData, PatientsListResponse, PatientsSearchByBpjsData, PatientsSearchByBpjsResponse, PatientsSearchByNikData, PatientsSearchByNikResponse, PatientsUpdateData, PatientsUpdateResponse, PaymentsCancelData, PaymentsCancelResponse, PaymentsCreateData, PaymentsCreateResponse, PaymentsGetData, PaymentsGetResponse, PaymentsListData, PaymentsListResponse, PaymentsVerifyData, PaymentsVerifyResponse, PolyclinicsCreateData, PolyclinicsCreateResponse, PolyclinicsDeleteData, PolyclinicsDeleteResponse, PolyclinicsGetData, PolyclinicsGetResponse, PolyclinicsListData, PolyclinicsListResponse, PolyclinicsUpdateData, PolyclinicsUpdateResponse, PractitionerCredentialsCreateData, PractitionerCredentialsCreateResponse, PractitionerCredentialsGetData, PractitionerCredentialsGetResponse, PractitionerCredentialsListData, PractitionerCredentialsListResponse, PractitionerCredentialsVerifyData, PractitionerCredentialsVerifyResponse, PractitionerSchedulesCreateData, PractitionerSchedulesCreateResponse, PractitionerSchedulesDeleteData, PractitionerSchedulesDeleteResponse, PractitionerSchedulesListData, PractitionerSchedulesListResponse, PractitionerSchedulesUpdateData, PractitionerSchedulesUpdateResponse, PractitionersCreateData, PractitionersCreateResponse, PractitionersDeleteData, PractitionersDeleteResponse, PractitionersGetData, PractitionersGetResponse, PractitionersListData, PractitionersListResponse, PractitionersUpdateData, PractitionersUpdateResponse, PrescriptionsCancelData, PrescriptionsCancelResponse, PrescriptionsCreateData, PrescriptionsCreateResponse, PrescriptionsGetData, PrescriptionsGetResponse, PrescriptionsListData, PrescriptionsListResponse, PrescriptionsSignOffData, PrescriptionsSignOffResponse, ProceduresCompleteData, ProceduresCompleteResponse, ProceduresCreateData, ProceduresCreateResponse, ProceduresListData, ProceduresListResponse, ProceduresUpdateData, ProceduresUpdateResponse, QualityIndicatorsCreateData, QualityIndicatorsCreateResponse, QualityIndicatorsGetData, QualityIndicatorsGetResponse, QualityIndicatorsListData, QualityIndicatorsListResponse, QualityIndicatorsListResultsData, QualityIndicatorsListResultsResponse, QualityIndicatorsRecordResultData, QualityIndicatorsRecordResultResponse, QueuesCallData, QueuesCallNextData, QueuesCallNextResponse, QueuesCallResponse, QueuesCompleteData, QueuesCompleteResponse, QueuesCreateData, QueuesCreateResponse, QueuesGetData, QueuesGetDisplayData, QueuesGetDisplayResponse, QueuesGetResponse, QueuesListData, QueuesListResponse, QueuesSkipData, QueuesSkipResponse, ReferralsCreateData, ReferralsCreateResponse, ReferralsGetData, ReferralsGetResponse, ReferralsListData, ReferralsListResponse, RefundsApproveData, RefundsApproveResponse, RefundsCreateData, RefundsCreateResponse, RefundsGetData, RefundsGetResponse, RefundsListData, RefundsListResponse, RefundsProcessData, RefundsProcessResponse, RefundsRejectData, RefundsRejectResponse, SatusehatConfigsCreateData, SatusehatConfigsCreateResponse, SatusehatConfigsDeleteData, SatusehatConfigsDeleteResponse, SatusehatConfigsGetData, SatusehatConfigsGetResponse, SatusehatConfigsListData, SatusehatConfigsListResponse, SatusehatConfigsRefreshTokenData, SatusehatConfigsRefreshTokenResponse, SatusehatConfigsTestData, SatusehatConfigsTestResponse, SatusehatConfigsUpdateData, SatusehatConfigsUpdateResponse, SpecimensCollectData, SpecimensCollectResponse, SpecimensGetData, SpecimensGetResponse, SpecimensListData, SpecimensListResponse, SpecimensReceiveData, SpecimensReceiveResponse, SpecimensRejectData, SpecimensRejectResponse, TenantRolesCreateData, TenantRolesCreateResponse, TenantRolesDeleteData, TenantRolesDeleteResponse, TenantRolesGetData, TenantRolesGetResponse, TenantRolesListData, TenantRolesListResponse, TenantRolesUpdateData, TenantRolesUpdateResponse, UserPermissionsGetData, UserPermissionsGetResponse, UserTenantRolesAssignData, UserTenantRolesAssignResponse, UserTenantRolesListData, UserTenantRolesListResponse, UserTenantRolesRemoveData, UserTenantRolesRemoveResponse, VitalSignsApiCreateData, VitalSignsApiCreateResponse, VitalSignsApiGetData, VitalSignsApiGetResponse, VitalSignsApiUpdateData, VitalSignsApiUpdateResponse, WebhooksCreateData, WebhooksCreateResponse, WebhooksDeleteData, WebhooksDeleteResponse, WebhooksGetData, WebhooksGetDeliveryData, WebhooksGetDeliveryResponse, WebhooksGetResponse, WebhooksListData, WebhooksListDeliveriesData, WebhooksListDeliveriesResponse, WebhooksListEventTypesData, WebhooksListEventTypesResponse, WebhooksListResponse, WebhooksRetryDeliveryData, WebhooksRetryDeliveryResponse, WebhooksRotateSecretData, WebhooksRotateSecretResponse, WebhooksTestData, WebhooksTestResponse, WebhooksUpdateData, WebhooksUpdateResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckQueryKey = (options?: Options<HealthCheckData>) => createQueryKey('healthCheck', options);

/**
 * Health check
 *
 * Check API health status
 * Returns 200 OK if the API is healthy
 */
export const healthCheckOptions = (options?: Options<HealthCheckData>) => queryOptions<HealthCheckResponse, DefaultError, HealthCheckResponse, ReturnType<typeof healthCheckQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Health.healthCheck({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckQueryKey(options)
});

export const migrationGetStatusQueryKey = (options?: Options<MigrationGetStatusData>) => createQueryKey('migrationGetStatus', options);

/**
 * Get API version migration status
 *
 * Get migration status for the current API version
 *
 * Returns information about:
 * - Current version status (current, deprecated, sunset)
 * - Sunset date if deprecated
 * - Replacement version to migrate to
 * - Breaking changes and migration checklist
 */
export const migrationGetStatusOptions = (options?: Options<MigrationGetStatusData>) => queryOptions<MigrationGetStatusResponse, DefaultError, MigrationGetStatusResponse, ReturnType<typeof migrationGetStatusQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Migration.migrationGetStatus({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: migrationGetStatusQueryKey(options)
});

export const notificationsListQueryKey = (options?: Options<NotificationsListData>) => createQueryKey('notificationsList', options);

/**
 * List notifications
 *
 * List user's notification history
 * Returns notifications for the authenticated user, excluding soft-deleted ones
 */
export const notificationsListOptions = (options?: Options<NotificationsListData>) => queryOptions<NotificationsListResponse, DefaultError, NotificationsListResponse, ReturnType<typeof notificationsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Notifications.notificationsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsListQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const notificationsListInfiniteQueryKey = (options?: Options<NotificationsListData>): QueryKey<Options<NotificationsListData>> => createQueryKey('notificationsList', options, true);

/**
 * List notifications
 *
 * List user's notification history
 * Returns notifications for the authenticated user, excluding soft-deleted ones
 */
export const notificationsListInfiniteOptions = (options?: Options<NotificationsListData>) => infiniteQueryOptions<NotificationsListResponse, DefaultError, InfiniteData<NotificationsListResponse>, QueryKey<Options<NotificationsListData>>, number | Pick<QueryKey<Options<NotificationsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<NotificationsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                offset: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Notifications.notificationsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsListInfiniteQueryKey(options)
});

/**
 * Mark all notifications as read
 *
 * Mark all notifications as read for the current user
 * Returns the count of notifications that were marked as read
 */
export const notificationsMarkAllReadMutation = (options?: Partial<Options<NotificationsMarkAllReadData>>): UseMutationOptions<NotificationsMarkAllReadResponse, DefaultError, Options<NotificationsMarkAllReadData>> => {
    const mutationOptions: UseMutationOptions<NotificationsMarkAllReadResponse, DefaultError, Options<NotificationsMarkAllReadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Notifications.notificationsMarkAllRead({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Send notification
 *
 * Send a notification
 * Queues the notification for delivery through the specified channel
 * Requires authentication. Consider adding authorization for production use.
 */
export const notificationsSendMutation = (options?: Partial<Options<NotificationsSendData>>): UseMutationOptions<NotificationsSendResponse, DefaultError, Options<NotificationsSendData>> => {
    const mutationOptions: UseMutationOptions<NotificationsSendResponse, DefaultError, Options<NotificationsSendData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Notifications.notificationsSend({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationsGetUnreadCountQueryKey = (options?: Options<NotificationsGetUnreadCountData>) => createQueryKey('notificationsGetUnreadCount', options);

/**
 * Get unread notification count
 *
 * Get count of unread notifications
 * Returns the number of unread notifications for the current user
 */
export const notificationsGetUnreadCountOptions = (options?: Options<NotificationsGetUnreadCountData>) => queryOptions<NotificationsGetUnreadCountResponse, DefaultError, NotificationsGetUnreadCountResponse, ReturnType<typeof notificationsGetUnreadCountQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Notifications.notificationsGetUnreadCount({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsGetUnreadCountQueryKey(options)
});

/**
 * Delete notification
 *
 * Soft delete a notification
 * Marks the notification as deleted without actually removing it
 */
export const notificationsDeleteMutation = (options?: Partial<Options<NotificationsDeleteData>>): UseMutationOptions<NotificationsDeleteResponse, DefaultError, Options<NotificationsDeleteData>> => {
    const mutationOptions: UseMutationOptions<NotificationsDeleteResponse, DefaultError, Options<NotificationsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Notifications.notificationsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationsGetQueryKey = (options: Options<NotificationsGetData>) => createQueryKey('notificationsGet', options);

/**
 * Get notification by ID
 *
 * Get a specific notification by ID
 * Only returns notifications owned by the authenticated user
 */
export const notificationsGetOptions = (options: Options<NotificationsGetData>) => queryOptions<NotificationsGetResponse, DefaultError, NotificationsGetResponse, ReturnType<typeof notificationsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Notifications.notificationsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationsGetQueryKey(options)
});

/**
 * Mark notification as read
 *
 * Mark a notification as read
 * Updates the readAt timestamp for the notification
 */
export const notificationsMarkReadMutation = (options?: Partial<Options<NotificationsMarkReadData>>): UseMutationOptions<NotificationsMarkReadResponse, DefaultError, Options<NotificationsMarkReadData>> => {
    const mutationOptions: UseMutationOptions<NotificationsMarkReadResponse, DefaultError, Options<NotificationsMarkReadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Notifications.notificationsMarkRead({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore notification
 *
 * Restore a soft-deleted notification
 * Clears the deletedAt timestamp to restore the notification
 */
export const notificationsRestoreMutation = (options?: Partial<Options<NotificationsRestoreData>>): UseMutationOptions<NotificationsRestoreResponse, DefaultError, Options<NotificationsRestoreData>> => {
    const mutationOptions: UseMutationOptions<NotificationsRestoreResponse, DefaultError, Options<NotificationsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Notifications.notificationsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Mark notification as unread
 *
 * Mark a notification as unread
 * Clears the readAt timestamp for the notification
 */
export const notificationsMarkUnreadMutation = (options?: Partial<Options<NotificationsMarkUnreadData>>): UseMutationOptions<NotificationsMarkUnreadResponse, DefaultError, Options<NotificationsMarkUnreadData>> => {
    const mutationOptions: UseMutationOptions<NotificationsMarkUnreadResponse, DefaultError, Options<NotificationsMarkUnreadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Notifications.notificationsMarkUnread({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const organizationsListQueryKey = (options?: Options<OrganizationsListData>) => createQueryKey('organizationsList', options);

/**
 * List organizations
 *
 * List all organizations
 */
export const organizationsListOptions = (options?: Options<OrganizationsListData>) => queryOptions<OrganizationsListResponse, DefaultError, OrganizationsListResponse, ReturnType<typeof organizationsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Organizations.organizationsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: organizationsListQueryKey(options)
});

export const organizationsListInfiniteQueryKey = (options?: Options<OrganizationsListData>): QueryKey<Options<OrganizationsListData>> => createQueryKey('organizationsList', options, true);

/**
 * List organizations
 *
 * List all organizations
 */
export const organizationsListInfiniteOptions = (options?: Options<OrganizationsListData>) => infiniteQueryOptions<OrganizationsListResponse, DefaultError, InfiniteData<OrganizationsListResponse>, QueryKey<Options<OrganizationsListData>>, number | Pick<QueryKey<Options<OrganizationsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<OrganizationsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Organizations.organizationsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: organizationsListInfiniteQueryKey(options)
});

/**
 * Create organization
 *
 * Create a new organization
 */
export const organizationsCreateMutation = (options?: Partial<Options<OrganizationsCreateData>>): UseMutationOptions<OrganizationsCreateResponse, DefaultError, Options<OrganizationsCreateData>> => {
    const mutationOptions: UseMutationOptions<OrganizationsCreateResponse, DefaultError, Options<OrganizationsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Organizations.organizationsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete organization
 *
 * Delete organization
 */
export const organizationsDeleteMutation = (options?: Partial<Options<OrganizationsDeleteData>>): UseMutationOptions<OrganizationsDeleteResponse, DefaultError, Options<OrganizationsDeleteData>> => {
    const mutationOptions: UseMutationOptions<OrganizationsDeleteResponse, DefaultError, Options<OrganizationsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Organizations.organizationsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const organizationsGetQueryKey = (options: Options<OrganizationsGetData>) => createQueryKey('organizationsGet', options);

/**
 * Get organization
 *
 * Get organization by ID
 */
export const organizationsGetOptions = (options: Options<OrganizationsGetData>) => queryOptions<OrganizationsGetResponse, DefaultError, OrganizationsGetResponse, ReturnType<typeof organizationsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Organizations.organizationsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: organizationsGetQueryKey(options)
});

/**
 * Update organization
 *
 * Update organization
 */
export const organizationsUpdateMutation = (options?: Partial<Options<OrganizationsUpdateData>>): UseMutationOptions<OrganizationsUpdateResponse, DefaultError, Options<OrganizationsUpdateData>> => {
    const mutationOptions: UseMutationOptions<OrganizationsUpdateResponse, DefaultError, Options<OrganizationsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Organizations.organizationsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const accreditationStandardsListQueryKey = (options: Options<AccreditationStandardsListData>) => createQueryKey('accreditationStandardsList', options);

/**
 * List accreditation standards
 *
 * List accreditation standards
 */
export const accreditationStandardsListOptions = (options: Options<AccreditationStandardsListData>) => queryOptions<AccreditationStandardsListResponse, DefaultError, AccreditationStandardsListResponse, ReturnType<typeof accreditationStandardsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.accreditationStandardsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: accreditationStandardsListQueryKey(options)
});

/**
 * Create accreditation record
 *
 * Create accreditation record
 */
export const accreditationStandardsCreateMutation = (options?: Partial<Options<AccreditationStandardsCreateData>>): UseMutationOptions<AccreditationStandardsCreateResponse, DefaultError, Options<AccreditationStandardsCreateData>> => {
    const mutationOptions: UseMutationOptions<AccreditationStandardsCreateResponse, DefaultError, Options<AccreditationStandardsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.accreditationStandardsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const accreditationStandardsGetQueryKey = (options: Options<AccreditationStandardsGetData>) => createQueryKey('accreditationStandardsGet', options);

/**
 * Get accreditation record
 *
 * Get accreditation record
 */
export const accreditationStandardsGetOptions = (options: Options<AccreditationStandardsGetData>) => queryOptions<AccreditationStandardsGetResponse, DefaultError, AccreditationStandardsGetResponse, ReturnType<typeof accreditationStandardsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.accreditationStandardsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: accreditationStandardsGetQueryKey(options)
});

/**
 * Update accreditation record
 *
 * Update accreditation record
 */
export const accreditationStandardsUpdateMutation = (options?: Partial<Options<AccreditationStandardsUpdateData>>): UseMutationOptions<AccreditationStandardsUpdateResponse, DefaultError, Options<AccreditationStandardsUpdateData>> => {
    const mutationOptions: UseMutationOptions<AccreditationStandardsUpdateResponse, DefaultError, Options<AccreditationStandardsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.accreditationStandardsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const appointmentsListQueryKey = (options: Options<AppointmentsListData>) => createQueryKey('appointmentsList', options);

/**
 * List appointments
 *
 * List appointments
 */
export const appointmentsListOptions = (options: Options<AppointmentsListData>) => queryOptions<AppointmentsListResponse, DefaultError, AppointmentsListResponse, ReturnType<typeof appointmentsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Appointments.appointmentsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: appointmentsListQueryKey(options)
});

export const appointmentsListInfiniteQueryKey = (options: Options<AppointmentsListData>): QueryKey<Options<AppointmentsListData>> => createQueryKey('appointmentsList', options, true);

/**
 * List appointments
 *
 * List appointments
 */
export const appointmentsListInfiniteOptions = (options: Options<AppointmentsListData>) => infiniteQueryOptions<AppointmentsListResponse, DefaultError, InfiniteData<AppointmentsListResponse>, QueryKey<Options<AppointmentsListData>>, number | Pick<QueryKey<Options<AppointmentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<AppointmentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Appointments.appointmentsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: appointmentsListInfiniteQueryKey(options)
});

/**
 * Book appointment
 *
 * Book an appointment
 */
export const appointmentsCreateMutation = (options?: Partial<Options<AppointmentsCreateData>>): UseMutationOptions<AppointmentsCreateResponse, DefaultError, Options<AppointmentsCreateData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsCreateResponse, DefaultError, Options<AppointmentsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.appointmentsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const appointmentsGetQueryKey = (options: Options<AppointmentsGetData>) => createQueryKey('appointmentsGet', options);

/**
 * Get appointment
 *
 * Get appointment by ID
 */
export const appointmentsGetOptions = (options: Options<AppointmentsGetData>) => queryOptions<AppointmentsGetResponse, DefaultError, AppointmentsGetResponse, ReturnType<typeof appointmentsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Appointments.appointmentsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: appointmentsGetQueryKey(options)
});

/**
 * Update appointment
 *
 * Update appointment
 */
export const appointmentsUpdateMutation = (options?: Partial<Options<AppointmentsUpdateData>>): UseMutationOptions<AppointmentsUpdateResponse, DefaultError, Options<AppointmentsUpdateData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsUpdateResponse, DefaultError, Options<AppointmentsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.appointmentsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel appointment
 *
 * Cancel appointment
 */
export const appointmentsCancelMutation = (options?: Partial<Options<AppointmentsCancelData>>): UseMutationOptions<AppointmentsCancelResponse, DefaultError, Options<AppointmentsCancelData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsCancelResponse, DefaultError, Options<AppointmentsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.appointmentsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Check-in patient
 *
 * Check-in patient
 */
export const appointmentsCheckInMutation = (options?: Partial<Options<AppointmentsCheckInData>>): UseMutationOptions<AppointmentsCheckInResponse, DefaultError, Options<AppointmentsCheckInData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsCheckInResponse, DefaultError, Options<AppointmentsCheckInData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.appointmentsCheckIn({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Mark as no-show
 *
 * No-show appointment
 */
export const appointmentsNoShowMutation = (options?: Partial<Options<AppointmentsNoShowData>>): UseMutationOptions<AppointmentsNoShowResponse, DefaultError, Options<AppointmentsNoShowData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsNoShowResponse, DefaultError, Options<AppointmentsNoShowData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.appointmentsNoShow({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reschedule appointment
 *
 * Reschedule appointment
 */
export const appointmentsRescheduleMutation = (options?: Partial<Options<AppointmentsRescheduleData>>): UseMutationOptions<AppointmentsRescheduleResponse, DefaultError, Options<AppointmentsRescheduleData>> => {
    const mutationOptions: UseMutationOptions<AppointmentsRescheduleResponse, DefaultError, Options<AppointmentsRescheduleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.appointmentsReschedule({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsListQueryKey = (options: Options<AuditLogsListData>) => createQueryKey('auditLogsList', options);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListOptions = (options: Options<AuditLogsListData>) => queryOptions<AuditLogsListResponse, DefaultError, AuditLogsListResponse, ReturnType<typeof auditLogsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await AuditLogs.auditLogsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListQueryKey(options)
});

export const auditLogsListInfiniteQueryKey = (options: Options<AuditLogsListData>): QueryKey<Options<AuditLogsListData>> => createQueryKey('auditLogsList', options, true);

/**
 * Query audit logs
 *
 * Query audit logs
 *
 * Search and filter audit events. Supports pagination.
 * Results are sorted by timestamp descending (newest first).
 */
export const auditLogsListInfiniteOptions = (options: Options<AuditLogsListData>) => infiniteQueryOptions<AuditLogsListResponse, DefaultError, InfiniteData<AuditLogsListResponse>, QueryKey<Options<AuditLogsListData>>, number | Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<AuditLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await AuditLogs.auditLogsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsListInfiniteQueryKey(options)
});

/**
 * Export audit logs
 *
 * Export audit logs
 *
 * Returns a download URL for audit logs in CSV or JSON format.
 * For large exports, returns 202 Accepted with a job ID.
 */
export const auditLogsExportMutation = (options?: Partial<Options<AuditLogsExportData>>): UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> => {
    const mutationOptions: UseMutationOptions<AuditLogsExportResponse, DefaultError, Options<AuditLogsExportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await AuditLogs.auditLogsExport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const auditLogsGetQueryKey = (options: Options<AuditLogsGetData>) => createQueryKey('auditLogsGet', options);

/**
 * Get audit log entry
 *
 * Get a single audit log entry
 */
export const auditLogsGetOptions = (options: Options<AuditLogsGetData>) => queryOptions<AuditLogsGetResponse, DefaultError, AuditLogsGetResponse, ReturnType<typeof auditLogsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await AuditLogs.auditLogsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: auditLogsGetQueryKey(options)
});

export const branchesListQueryKey = (options: Options<BranchesListData>) => createQueryKey('branchesList', options);

/**
 * List branches
 *
 * List branches in an organization
 */
export const branchesListOptions = (options: Options<BranchesListData>) => queryOptions<BranchesListResponse, DefaultError, BranchesListResponse, ReturnType<typeof branchesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Organizations.branchesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: branchesListQueryKey(options)
});

export const branchesListInfiniteQueryKey = (options: Options<BranchesListData>): QueryKey<Options<BranchesListData>> => createQueryKey('branchesList', options, true);

/**
 * List branches
 *
 * List branches in an organization
 */
export const branchesListInfiniteOptions = (options: Options<BranchesListData>) => infiniteQueryOptions<BranchesListResponse, DefaultError, InfiniteData<BranchesListResponse>, QueryKey<Options<BranchesListData>>, number | Pick<QueryKey<Options<BranchesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<BranchesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Organizations.branchesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: branchesListInfiniteQueryKey(options)
});

/**
 * Create branch
 *
 * Create a new branch
 */
export const branchesCreateMutation = (options?: Partial<Options<BranchesCreateData>>): UseMutationOptions<BranchesCreateResponse, DefaultError, Options<BranchesCreateData>> => {
    const mutationOptions: UseMutationOptions<BranchesCreateResponse, DefaultError, Options<BranchesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Organizations.branchesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete branch
 *
 * Delete branch
 */
export const branchesDeleteMutation = (options?: Partial<Options<BranchesDeleteData>>): UseMutationOptions<BranchesDeleteResponse, DefaultError, Options<BranchesDeleteData>> => {
    const mutationOptions: UseMutationOptions<BranchesDeleteResponse, DefaultError, Options<BranchesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Organizations.branchesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const branchesGetQueryKey = (options: Options<BranchesGetData>) => createQueryKey('branchesGet', options);

/**
 * Get branch
 *
 * Get branch by ID
 */
export const branchesGetOptions = (options: Options<BranchesGetData>) => queryOptions<BranchesGetResponse, DefaultError, BranchesGetResponse, ReturnType<typeof branchesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Organizations.branchesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: branchesGetQueryKey(options)
});

/**
 * Update branch
 *
 * Update branch
 */
export const branchesUpdateMutation = (options?: Partial<Options<BranchesUpdateData>>): UseMutationOptions<BranchesUpdateResponse, DefaultError, Options<BranchesUpdateData>> => {
    const mutationOptions: UseMutationOptions<BranchesUpdateResponse, DefaultError, Options<BranchesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Organizations.branchesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const clinicalAuditsListQueryKey = (options: Options<ClinicalAuditsListData>) => createQueryKey('clinicalAuditsList', options);

/**
 * List clinical audits
 *
 * List clinical audits
 */
export const clinicalAuditsListOptions = (options: Options<ClinicalAuditsListData>) => queryOptions<ClinicalAuditsListResponse, DefaultError, ClinicalAuditsListResponse, ReturnType<typeof clinicalAuditsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.clinicalAuditsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: clinicalAuditsListQueryKey(options)
});

export const clinicalAuditsListInfiniteQueryKey = (options: Options<ClinicalAuditsListData>): QueryKey<Options<ClinicalAuditsListData>> => createQueryKey('clinicalAuditsList', options, true);

/**
 * List clinical audits
 *
 * List clinical audits
 */
export const clinicalAuditsListInfiniteOptions = (options: Options<ClinicalAuditsListData>) => infiniteQueryOptions<ClinicalAuditsListResponse, DefaultError, InfiniteData<ClinicalAuditsListResponse>, QueryKey<Options<ClinicalAuditsListData>>, number | Pick<QueryKey<Options<ClinicalAuditsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ClinicalAuditsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Accreditation.clinicalAuditsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: clinicalAuditsListInfiniteQueryKey(options)
});

/**
 * Create clinical audit
 *
 * Create clinical audit
 */
export const clinicalAuditsCreateMutation = (options?: Partial<Options<ClinicalAuditsCreateData>>): UseMutationOptions<ClinicalAuditsCreateResponse, DefaultError, Options<ClinicalAuditsCreateData>> => {
    const mutationOptions: UseMutationOptions<ClinicalAuditsCreateResponse, DefaultError, Options<ClinicalAuditsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.clinicalAuditsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const clinicalAuditsGetQueryKey = (options: Options<ClinicalAuditsGetData>) => createQueryKey('clinicalAuditsGet', options);

/**
 * Get clinical audit
 *
 * Get clinical audit
 */
export const clinicalAuditsGetOptions = (options: Options<ClinicalAuditsGetData>) => queryOptions<ClinicalAuditsGetResponse, DefaultError, ClinicalAuditsGetResponse, ReturnType<typeof clinicalAuditsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.clinicalAuditsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: clinicalAuditsGetQueryKey(options)
});

/**
 * Approve clinical audit
 *
 * Approve clinical audit
 */
export const clinicalAuditsApproveMutation = (options?: Partial<Options<ClinicalAuditsApproveData>>): UseMutationOptions<ClinicalAuditsApproveResponse, DefaultError, Options<ClinicalAuditsApproveData>> => {
    const mutationOptions: UseMutationOptions<ClinicalAuditsApproveResponse, DefaultError, Options<ClinicalAuditsApproveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.clinicalAuditsApprove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complete clinical audit
 *
 * Complete clinical audit
 */
export const clinicalAuditsCompleteMutation = (options?: Partial<Options<ClinicalAuditsCompleteData>>): UseMutationOptions<ClinicalAuditsCompleteResponse, DefaultError, Options<ClinicalAuditsCompleteData>> => {
    const mutationOptions: UseMutationOptions<ClinicalAuditsCompleteResponse, DefaultError, Options<ClinicalAuditsCompleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.clinicalAuditsComplete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const diagnosticReportsListQueryKey = (options: Options<DiagnosticReportsListData>) => createQueryKey('diagnosticReportsList', options);

/**
 * List diagnostic reports
 *
 * List diagnostic reports
 */
export const diagnosticReportsListOptions = (options: Options<DiagnosticReportsListData>) => queryOptions<DiagnosticReportsListResponse, DefaultError, DiagnosticReportsListResponse, ReturnType<typeof diagnosticReportsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.diagnosticReportsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: diagnosticReportsListQueryKey(options)
});

export const diagnosticReportsListInfiniteQueryKey = (options: Options<DiagnosticReportsListData>): QueryKey<Options<DiagnosticReportsListData>> => createQueryKey('diagnosticReportsList', options, true);

/**
 * List diagnostic reports
 *
 * List diagnostic reports
 */
export const diagnosticReportsListInfiniteOptions = (options: Options<DiagnosticReportsListData>) => infiniteQueryOptions<DiagnosticReportsListResponse, DefaultError, InfiniteData<DiagnosticReportsListResponse>, QueryKey<Options<DiagnosticReportsListData>>, number | Pick<QueryKey<Options<DiagnosticReportsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<DiagnosticReportsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Laboratory.diagnosticReportsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: diagnosticReportsListInfiniteQueryKey(options)
});

/**
 * Create diagnostic report
 *
 * Create diagnostic report
 */
export const diagnosticReportsCreateMutation = (options?: Partial<Options<DiagnosticReportsCreateData>>): UseMutationOptions<DiagnosticReportsCreateResponse, DefaultError, Options<DiagnosticReportsCreateData>> => {
    const mutationOptions: UseMutationOptions<DiagnosticReportsCreateResponse, DefaultError, Options<DiagnosticReportsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.diagnosticReportsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const diagnosticReportsGetQueryKey = (options: Options<DiagnosticReportsGetData>) => createQueryKey('diagnosticReportsGet', options);

/**
 * Get diagnostic report
 *
 * Get diagnostic report
 */
export const diagnosticReportsGetOptions = (options: Options<DiagnosticReportsGetData>) => queryOptions<DiagnosticReportsGetResponse, DefaultError, DiagnosticReportsGetResponse, ReturnType<typeof diagnosticReportsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.diagnosticReportsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: diagnosticReportsGetQueryKey(options)
});

/**
 * Finalize diagnostic report
 *
 * Finalize diagnostic report
 */
export const diagnosticReportsFinalizeMutation = (options?: Partial<Options<DiagnosticReportsFinalizeData>>): UseMutationOptions<DiagnosticReportsFinalizeResponse, DefaultError, Options<DiagnosticReportsFinalizeData>> => {
    const mutationOptions: UseMutationOptions<DiagnosticReportsFinalizeResponse, DefaultError, Options<DiagnosticReportsFinalizeData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.diagnosticReportsFinalize({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const documentControlsListQueryKey = (options: Options<DocumentControlsListData>) => createQueryKey('documentControlsList', options);

/**
 * List controlled documents
 *
 * List controlled documents
 */
export const documentControlsListOptions = (options: Options<DocumentControlsListData>) => queryOptions<DocumentControlsListResponse, DefaultError, DocumentControlsListResponse, ReturnType<typeof documentControlsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.documentControlsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentControlsListQueryKey(options)
});

export const documentControlsListInfiniteQueryKey = (options: Options<DocumentControlsListData>): QueryKey<Options<DocumentControlsListData>> => createQueryKey('documentControlsList', options, true);

/**
 * List controlled documents
 *
 * List controlled documents
 */
export const documentControlsListInfiniteOptions = (options: Options<DocumentControlsListData>) => infiniteQueryOptions<DocumentControlsListResponse, DefaultError, InfiniteData<DocumentControlsListResponse>, QueryKey<Options<DocumentControlsListData>>, number | Pick<QueryKey<Options<DocumentControlsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<DocumentControlsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Accreditation.documentControlsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentControlsListInfiniteQueryKey(options)
});

/**
 * Create controlled document
 *
 * Create document
 */
export const documentControlsCreateMutation = (options?: Partial<Options<DocumentControlsCreateData>>): UseMutationOptions<DocumentControlsCreateResponse, DefaultError, Options<DocumentControlsCreateData>> => {
    const mutationOptions: UseMutationOptions<DocumentControlsCreateResponse, DefaultError, Options<DocumentControlsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.documentControlsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const documentControlsGetQueryKey = (options: Options<DocumentControlsGetData>) => createQueryKey('documentControlsGet', options);

/**
 * Get controlled document
 *
 * Get document
 */
export const documentControlsGetOptions = (options: Options<DocumentControlsGetData>) => queryOptions<DocumentControlsGetResponse, DefaultError, DocumentControlsGetResponse, ReturnType<typeof documentControlsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.documentControlsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: documentControlsGetQueryKey(options)
});

/**
 * Approve document
 *
 * Approve document
 */
export const documentControlsApproveMutation = (options?: Partial<Options<DocumentControlsApproveData>>): UseMutationOptions<DocumentControlsApproveResponse, DefaultError, Options<DocumentControlsApproveData>> => {
    const mutationOptions: UseMutationOptions<DocumentControlsApproveResponse, DefaultError, Options<DocumentControlsApproveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.documentControlsApprove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Publish document
 *
 * Publish document
 */
export const documentControlsPublishMutation = (options?: Partial<Options<DocumentControlsPublishData>>): UseMutationOptions<DocumentControlsPublishResponse, DefaultError, Options<DocumentControlsPublishData>> => {
    const mutationOptions: UseMutationOptions<DocumentControlsPublishResponse, DefaultError, Options<DocumentControlsPublishData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.documentControlsPublish({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Retire document
 *
 * Retire document
 */
export const documentControlsRetireMutation = (options?: Partial<Options<DocumentControlsRetireData>>): UseMutationOptions<DocumentControlsRetireResponse, DefaultError, Options<DocumentControlsRetireData>> => {
    const mutationOptions: UseMutationOptions<DocumentControlsRetireResponse, DefaultError, Options<DocumentControlsRetireData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.documentControlsRetire({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Submit document for review
 *
 * Submit for review
 */
export const documentControlsSubmitForReviewMutation = (options?: Partial<Options<DocumentControlsSubmitForReviewData>>): UseMutationOptions<DocumentControlsSubmitForReviewResponse, DefaultError, Options<DocumentControlsSubmitForReviewData>> => {
    const mutationOptions: UseMutationOptions<DocumentControlsSubmitForReviewResponse, DefaultError, Options<DocumentControlsSubmitForReviewData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.documentControlsSubmitForReview({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const encountersListQueryKey = (options: Options<EncountersListData>) => createQueryKey('encountersList', options);

/**
 * List encounters
 *
 * List encounters
 */
export const encountersListOptions = (options: Options<EncountersListData>) => queryOptions<EncountersListResponse, DefaultError, EncountersListResponse, ReturnType<typeof encountersListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.encountersList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: encountersListQueryKey(options)
});

export const encountersListInfiniteQueryKey = (options: Options<EncountersListData>): QueryKey<Options<EncountersListData>> => createQueryKey('encountersList', options, true);

/**
 * List encounters
 *
 * List encounters
 */
export const encountersListInfiniteOptions = (options: Options<EncountersListData>) => infiniteQueryOptions<EncountersListResponse, DefaultError, InfiniteData<EncountersListResponse>, QueryKey<Options<EncountersListData>>, number | Pick<QueryKey<Options<EncountersListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<EncountersListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Encounters.encountersList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: encountersListInfiniteQueryKey(options)
});

/**
 * Create encounter
 *
 * Create encounter
 */
export const encountersCreateMutation = (options?: Partial<Options<EncountersCreateData>>): UseMutationOptions<EncountersCreateResponse, DefaultError, Options<EncountersCreateData>> => {
    const mutationOptions: UseMutationOptions<EncountersCreateResponse, DefaultError, Options<EncountersCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.encountersCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const encountersGetQueryKey = (options: Options<EncountersGetData>) => createQueryKey('encountersGet', options);

/**
 * Get encounter
 *
 * Get encounter by ID
 */
export const encountersGetOptions = (options: Options<EncountersGetData>) => queryOptions<EncountersGetResponse, DefaultError, EncountersGetResponse, ReturnType<typeof encountersGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.encountersGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: encountersGetQueryKey(options)
});

/**
 * Update encounter
 *
 * Update encounter
 */
export const encountersUpdateMutation = (options?: Partial<Options<EncountersUpdateData>>): UseMutationOptions<EncountersUpdateResponse, DefaultError, Options<EncountersUpdateData>> => {
    const mutationOptions: UseMutationOptions<EncountersUpdateResponse, DefaultError, Options<EncountersUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.encountersUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Cancel encounter
 *
 * Cancel encounter
 */
export const encountersCancelMutation = (options?: Partial<Options<EncountersCancelData>>): UseMutationOptions<EncountersCancelResponse, DefaultError, Options<EncountersCancelData>> => {
    const mutationOptions: UseMutationOptions<EncountersCancelResponse, DefaultError, Options<EncountersCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.encountersCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complete encounter
 *
 * Complete encounter
 */
export const encountersCompleteMutation = (options?: Partial<Options<EncountersCompleteData>>): UseMutationOptions<EncountersCompleteResponse, DefaultError, Options<EncountersCompleteData>> => {
    const mutationOptions: UseMutationOptions<EncountersCompleteResponse, DefaultError, Options<EncountersCompleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.encountersComplete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const diagnosesListQueryKey = (options: Options<DiagnosesListData>) => createQueryKey('diagnosesList', options);

/**
 * List diagnoses
 *
 * List diagnoses for encounter
 */
export const diagnosesListOptions = (options: Options<DiagnosesListData>) => queryOptions<DiagnosesListResponse, DefaultError, DiagnosesListResponse, ReturnType<typeof diagnosesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.diagnosesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: diagnosesListQueryKey(options)
});

/**
 * Add diagnosis
 *
 * Add diagnosis
 */
export const diagnosesCreateMutation = (options?: Partial<Options<DiagnosesCreateData>>): UseMutationOptions<DiagnosesCreateResponse, DefaultError, Options<DiagnosesCreateData>> => {
    const mutationOptions: UseMutationOptions<DiagnosesCreateResponse, DefaultError, Options<DiagnosesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.diagnosesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete diagnosis
 *
 * Delete diagnosis
 */
export const diagnosesDeleteMutation = (options?: Partial<Options<DiagnosesDeleteData>>): UseMutationOptions<DiagnosesDeleteResponse, DefaultError, Options<DiagnosesDeleteData>> => {
    const mutationOptions: UseMutationOptions<DiagnosesDeleteResponse, DefaultError, Options<DiagnosesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.diagnosesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update diagnosis
 *
 * Update diagnosis
 */
export const diagnosesUpdateMutation = (options?: Partial<Options<DiagnosesUpdateData>>): UseMutationOptions<DiagnosesUpdateResponse, DefaultError, Options<DiagnosesUpdateData>> => {
    const mutationOptions: UseMutationOptions<DiagnosesUpdateResponse, DefaultError, Options<DiagnosesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.diagnosesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const prescriptionsListQueryKey = (options: Options<PrescriptionsListData>) => createQueryKey('prescriptionsList', options);

/**
 * List prescriptions
 *
 * List prescriptions for encounter
 */
export const prescriptionsListOptions = (options: Options<PrescriptionsListData>) => queryOptions<PrescriptionsListResponse, DefaultError, PrescriptionsListResponse, ReturnType<typeof prescriptionsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.prescriptionsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: prescriptionsListQueryKey(options)
});

/**
 * Create prescription
 *
 * Create prescription
 */
export const prescriptionsCreateMutation = (options?: Partial<Options<PrescriptionsCreateData>>): UseMutationOptions<PrescriptionsCreateResponse, DefaultError, Options<PrescriptionsCreateData>> => {
    const mutationOptions: UseMutationOptions<PrescriptionsCreateResponse, DefaultError, Options<PrescriptionsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.prescriptionsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const prescriptionsGetQueryKey = (options: Options<PrescriptionsGetData>) => createQueryKey('prescriptionsGet', options);

/**
 * Get prescription
 *
 * Get prescription
 */
export const prescriptionsGetOptions = (options: Options<PrescriptionsGetData>) => queryOptions<PrescriptionsGetResponse, DefaultError, PrescriptionsGetResponse, ReturnType<typeof prescriptionsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.prescriptionsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: prescriptionsGetQueryKey(options)
});

/**
 * Cancel prescription
 *
 * Cancel prescription
 */
export const prescriptionsCancelMutation = (options?: Partial<Options<PrescriptionsCancelData>>): UseMutationOptions<PrescriptionsCancelResponse, DefaultError, Options<PrescriptionsCancelData>> => {
    const mutationOptions: UseMutationOptions<PrescriptionsCancelResponse, DefaultError, Options<PrescriptionsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.prescriptionsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Sign off prescription
 *
 * Sign off prescription
 */
export const prescriptionsSignOffMutation = (options?: Partial<Options<PrescriptionsSignOffData>>): UseMutationOptions<PrescriptionsSignOffResponse, DefaultError, Options<PrescriptionsSignOffData>> => {
    const mutationOptions: UseMutationOptions<PrescriptionsSignOffResponse, DefaultError, Options<PrescriptionsSignOffData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.prescriptionsSignOff({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const proceduresListQueryKey = (options: Options<ProceduresListData>) => createQueryKey('proceduresList', options);

/**
 * List procedures
 *
 * List procedures for encounter
 */
export const proceduresListOptions = (options: Options<ProceduresListData>) => queryOptions<ProceduresListResponse, DefaultError, ProceduresListResponse, ReturnType<typeof proceduresListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.proceduresList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: proceduresListQueryKey(options)
});

/**
 * Add procedure
 *
 * Add procedure
 */
export const proceduresCreateMutation = (options?: Partial<Options<ProceduresCreateData>>): UseMutationOptions<ProceduresCreateResponse, DefaultError, Options<ProceduresCreateData>> => {
    const mutationOptions: UseMutationOptions<ProceduresCreateResponse, DefaultError, Options<ProceduresCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.proceduresCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update procedure
 *
 * Update procedure
 */
export const proceduresUpdateMutation = (options?: Partial<Options<ProceduresUpdateData>>): UseMutationOptions<ProceduresUpdateResponse, DefaultError, Options<ProceduresUpdateData>> => {
    const mutationOptions: UseMutationOptions<ProceduresUpdateResponse, DefaultError, Options<ProceduresUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.proceduresUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complete procedure
 *
 * Complete procedure
 */
export const proceduresCompleteMutation = (options?: Partial<Options<ProceduresCompleteData>>): UseMutationOptions<ProceduresCompleteResponse, DefaultError, Options<ProceduresCompleteData>> => {
    const mutationOptions: UseMutationOptions<ProceduresCompleteResponse, DefaultError, Options<ProceduresCompleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.proceduresComplete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const referralsListQueryKey = (options: Options<ReferralsListData>) => createQueryKey('referralsList', options);

/**
 * List referrals
 *
 * List referrals for encounter
 */
export const referralsListOptions = (options: Options<ReferralsListData>) => queryOptions<ReferralsListResponse, DefaultError, ReferralsListResponse, ReturnType<typeof referralsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.referralsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: referralsListQueryKey(options)
});

/**
 * Create referral
 *
 * Create referral
 */
export const referralsCreateMutation = (options?: Partial<Options<ReferralsCreateData>>): UseMutationOptions<ReferralsCreateResponse, DefaultError, Options<ReferralsCreateData>> => {
    const mutationOptions: UseMutationOptions<ReferralsCreateResponse, DefaultError, Options<ReferralsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.referralsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const referralsGetQueryKey = (options: Options<ReferralsGetData>) => createQueryKey('referralsGet', options);

/**
 * Get referral
 *
 * Get referral
 */
export const referralsGetOptions = (options: Options<ReferralsGetData>) => queryOptions<ReferralsGetResponse, DefaultError, ReferralsGetResponse, ReturnType<typeof referralsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.referralsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: referralsGetQueryKey(options)
});

export const vitalSignsApiGetQueryKey = (options: Options<VitalSignsApiGetData>) => createQueryKey('vitalSignsApiGet', options);

/**
 * Get vital signs
 *
 * Get vital signs for encounter
 */
export const vitalSignsApiGetOptions = (options: Options<VitalSignsApiGetData>) => queryOptions<VitalSignsApiGetResponse, DefaultError, VitalSignsApiGetResponse, ReturnType<typeof vitalSignsApiGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Encounters.vitalSignsApiGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: vitalSignsApiGetQueryKey(options)
});

/**
 * Update vital signs
 *
 * Update vital signs
 */
export const vitalSignsApiUpdateMutation = (options?: Partial<Options<VitalSignsApiUpdateData>>): UseMutationOptions<VitalSignsApiUpdateResponse, DefaultError, Options<VitalSignsApiUpdateData>> => {
    const mutationOptions: UseMutationOptions<VitalSignsApiUpdateResponse, DefaultError, Options<VitalSignsApiUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.vitalSignsApiUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Record vital signs
 *
 * Record vital signs
 */
export const vitalSignsApiCreateMutation = (options?: Partial<Options<VitalSignsApiCreateData>>): UseMutationOptions<VitalSignsApiCreateResponse, DefaultError, Options<VitalSignsApiCreateData>> => {
    const mutationOptions: UseMutationOptions<VitalSignsApiCreateResponse, DefaultError, Options<VitalSignsApiCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Encounters.vitalSignsApiCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const examplePostsListQueryKey = (options: Options<ExamplePostsListData>) => createQueryKey('examplePostsList', options);

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsListOptions = (options: Options<ExamplePostsListData>) => queryOptions<ExamplePostsListResponse, DefaultError, ExamplePostsListResponse, ReturnType<typeof examplePostsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ExamplePosts.examplePostsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListQueryKey(options)
});

export const examplePostsListInfiniteQueryKey = (options: Options<ExamplePostsListData>): QueryKey<Options<ExamplePostsListData>> => createQueryKey('examplePostsList', options, true);

/**
 * List example posts
 *
 * List posts in an organization
 * Supports pagination, filtering, sorting, and field selection
 */
export const examplePostsListInfiniteOptions = (options: Options<ExamplePostsListData>) => infiniteQueryOptions<ExamplePostsListResponse, DefaultError, InfiniteData<ExamplePostsListResponse>, QueryKey<Options<ExamplePostsListData>>, number | Pick<QueryKey<Options<ExamplePostsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await ExamplePosts.examplePostsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListInfiniteQueryKey(options)
});

/**
 * Create example post
 *
 * Create a new post
 */
export const examplePostsCreateMutation = (options?: Partial<Options<ExamplePostsCreateData>>): UseMutationOptions<ExamplePostsCreateResponse, DefaultError, Options<ExamplePostsCreateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsCreateResponse, DefaultError, Options<ExamplePostsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch update example posts
 *
 * Batch update posts
 */
export const examplePostsBatchUpdateMutation = (options?: Partial<Options<ExamplePostsBatchUpdateData>>): UseMutationOptions<ExamplePostsBatchUpdateResponse, DefaultError, Options<ExamplePostsBatchUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchUpdateResponse, DefaultError, Options<ExamplePostsBatchUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsBatchUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create example posts
 *
 * Batch create posts
 */
export const examplePostsBatchCreateMutation = (options?: Partial<Options<ExamplePostsBatchCreateData>>): UseMutationOptions<ExamplePostsBatchCreateResponse, DefaultError, Options<ExamplePostsBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchCreateResponse, DefaultError, Options<ExamplePostsBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch restore example posts
 *
 * Batch restore soft-deleted posts
 */
export const examplePostsBatchRestoreMutation = (options?: Partial<Options<ExamplePostsBatchRestoreData>>): UseMutationOptions<ExamplePostsBatchRestoreResponse, DefaultError, Options<ExamplePostsBatchRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchRestoreResponse, DefaultError, Options<ExamplePostsBatchRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsBatchRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete example posts
 *
 * Batch soft delete posts
 */
export const examplePostsBatchSoftDeleteMutation = (options?: Partial<Options<ExamplePostsBatchSoftDeleteData>>): UseMutationOptions<ExamplePostsBatchSoftDeleteResponse, DefaultError, Options<ExamplePostsBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsBatchSoftDeleteResponse, DefaultError, Options<ExamplePostsBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const examplePostsListCursorQueryKey = (options: Options<ExamplePostsListCursorData>) => createQueryKey('examplePostsListCursor', options);

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursorOptions = (options: Options<ExamplePostsListCursorData>) => queryOptions<ExamplePostsListCursorResponse, DefaultError, ExamplePostsListCursorResponse, ReturnType<typeof examplePostsListCursorQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ExamplePosts.examplePostsListCursor({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListCursorQueryKey(options)
});

export const examplePostsListCursorInfiniteQueryKey = (options: Options<ExamplePostsListCursorData>): QueryKey<Options<ExamplePostsListCursorData>> => createQueryKey('examplePostsListCursor', options, true);

/**
 * List example posts (cursor-based)
 *
 * List posts using cursor-based pagination
 *
 * Best for large datasets (>100K records) or real-time data where
 * consistent ordering is critical. Use page-based pagination for
 * typical UI scenarios with page numbers.
 */
export const examplePostsListCursorInfiniteOptions = (options: Options<ExamplePostsListCursorData>) => infiniteQueryOptions<ExamplePostsListCursorResponse, DefaultError, InfiniteData<ExamplePostsListCursorResponse>, QueryKey<Options<ExamplePostsListCursorData>>, string | Pick<QueryKey<Options<ExamplePostsListCursorData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListCursorData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                cursor: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await ExamplePosts.examplePostsListCursor({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListCursorInfiniteQueryKey(options)
});

export const examplePostsListDeletedQueryKey = (options: Options<ExamplePostsListDeletedData>) => createQueryKey('examplePostsListDeleted', options);

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeletedOptions = (options: Options<ExamplePostsListDeletedData>) => queryOptions<ExamplePostsListDeletedResponse, DefaultError, ExamplePostsListDeletedResponse, ReturnType<typeof examplePostsListDeletedQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ExamplePosts.examplePostsListDeleted({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListDeletedQueryKey(options)
});

export const examplePostsListDeletedInfiniteQueryKey = (options: Options<ExamplePostsListDeletedData>): QueryKey<Options<ExamplePostsListDeletedData>> => createQueryKey('examplePostsListDeleted', options, true);

/**
 * List deleted example posts
 *
 * List soft-deleted posts
 */
export const examplePostsListDeletedInfiniteOptions = (options: Options<ExamplePostsListDeletedData>) => infiniteQueryOptions<ExamplePostsListDeletedResponse, DefaultError, InfiniteData<ExamplePostsListDeletedResponse>, QueryKey<Options<ExamplePostsListDeletedData>>, number | Pick<QueryKey<Options<ExamplePostsListDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExamplePostsListDeletedData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await ExamplePosts.examplePostsListDeleted({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsListDeletedInfiniteQueryKey(options)
});

/**
 * Soft delete example post
 *
 * Soft delete a post (default delete behavior)
 * Post is marked as deleted but can be restored
 */
export const examplePostsDeleteMutation = (options?: Partial<Options<ExamplePostsDeleteData>>): UseMutationOptions<ExamplePostsDeleteResponse, DefaultError, Options<ExamplePostsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsDeleteResponse, DefaultError, Options<ExamplePostsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const examplePostsGetQueryKey = (options: Options<ExamplePostsGetData>) => createQueryKey('examplePostsGet', options);

/**
 * Get example post
 *
 * Get a single post by ID
 */
export const examplePostsGetOptions = (options: Options<ExamplePostsGetData>) => queryOptions<ExamplePostsGetResponse, DefaultError, ExamplePostsGetResponse, ReturnType<typeof examplePostsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ExamplePosts.examplePostsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: examplePostsGetQueryKey(options)
});

/**
 * Update example post
 *
 * Update a post (partial update)
 */
export const examplePostsUpdateMutation = (options?: Partial<Options<ExamplePostsUpdateData>>): UseMutationOptions<ExamplePostsUpdateResponse, DefaultError, Options<ExamplePostsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsUpdateResponse, DefaultError, Options<ExamplePostsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete example post
 *
 * Permanently delete a post (hard delete)
 * Post is permanently removed and cannot be restored
 */
export const examplePostsDeletePermanentMutation = (options?: Partial<Options<ExamplePostsDeletePermanentData>>): UseMutationOptions<ExamplePostsDeletePermanentResponse, DefaultError, Options<ExamplePostsDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsDeletePermanentResponse, DefaultError, Options<ExamplePostsDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore example post
 *
 * Restore a soft-deleted post
 */
export const examplePostsRestoreMutation = (options?: Partial<Options<ExamplePostsRestoreData>>): UseMutationOptions<ExamplePostsRestoreResponse, DefaultError, Options<ExamplePostsRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExamplePostsRestoreResponse, DefaultError, Options<ExamplePostsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExamplePosts.examplePostsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exampleCommentsListQueryKey = (options: Options<ExampleCommentsListData>) => createQueryKey('exampleCommentsList', options);

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsListOptions = (options: Options<ExampleCommentsListData>) => queryOptions<ExampleCommentsListResponse, DefaultError, ExampleCommentsListResponse, ReturnType<typeof exampleCommentsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ExampleComments.exampleCommentsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsListQueryKey(options)
});

export const exampleCommentsListInfiniteQueryKey = (options: Options<ExampleCommentsListData>): QueryKey<Options<ExampleCommentsListData>> => createQueryKey('exampleCommentsList', options, true);

/**
 * List comments for a post
 *
 * List comments for a post
 * Supports pagination, filtering, and sorting
 */
export const exampleCommentsListInfiniteOptions = (options: Options<ExampleCommentsListData>) => infiniteQueryOptions<ExampleCommentsListResponse, DefaultError, InfiniteData<ExampleCommentsListResponse>, QueryKey<Options<ExampleCommentsListData>>, number | Pick<QueryKey<Options<ExampleCommentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ExampleCommentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await ExampleComments.exampleCommentsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsListInfiniteQueryKey(options)
});

/**
 * Create comment on post
 *
 * Create a new comment on a post
 */
export const exampleCommentsCreateMutation = (options?: Partial<Options<ExampleCommentsCreateData>>): UseMutationOptions<ExampleCommentsCreateResponse, DefaultError, Options<ExampleCommentsCreateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsCreateResponse, DefaultError, Options<ExampleCommentsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExampleComments.exampleCommentsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch create comments
 *
 * Batch create comments
 */
export const exampleCommentsBatchCreateMutation = (options?: Partial<Options<ExampleCommentsBatchCreateData>>): UseMutationOptions<ExampleCommentsBatchCreateResponse, DefaultError, Options<ExampleCommentsBatchCreateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsBatchCreateResponse, DefaultError, Options<ExampleCommentsBatchCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExampleComments.exampleCommentsBatchCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Batch soft delete comments
 *
 * Batch soft delete comments
 */
export const exampleCommentsBatchSoftDeleteMutation = (options?: Partial<Options<ExampleCommentsBatchSoftDeleteData>>): UseMutationOptions<ExampleCommentsBatchSoftDeleteResponse, DefaultError, Options<ExampleCommentsBatchSoftDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsBatchSoftDeleteResponse, DefaultError, Options<ExampleCommentsBatchSoftDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExampleComments.exampleCommentsBatchSoftDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Soft delete comment
 *
 * Soft delete a comment
 */
export const exampleCommentsDeleteMutation = (options?: Partial<Options<ExampleCommentsDeleteData>>): UseMutationOptions<ExampleCommentsDeleteResponse, DefaultError, Options<ExampleCommentsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsDeleteResponse, DefaultError, Options<ExampleCommentsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExampleComments.exampleCommentsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const exampleCommentsGetQueryKey = (options: Options<ExampleCommentsGetData>) => createQueryKey('exampleCommentsGet', options);

/**
 * Get comment
 *
 * Get a single comment by ID
 */
export const exampleCommentsGetOptions = (options: Options<ExampleCommentsGetData>) => queryOptions<ExampleCommentsGetResponse, DefaultError, ExampleCommentsGetResponse, ReturnType<typeof exampleCommentsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await ExampleComments.exampleCommentsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: exampleCommentsGetQueryKey(options)
});

/**
 * Update comment
 *
 * Update a comment (partial update)
 */
export const exampleCommentsUpdateMutation = (options?: Partial<Options<ExampleCommentsUpdateData>>): UseMutationOptions<ExampleCommentsUpdateResponse, DefaultError, Options<ExampleCommentsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsUpdateResponse, DefaultError, Options<ExampleCommentsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExampleComments.exampleCommentsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Permanently delete comment
 *
 * Permanently delete a comment (hard delete)
 */
export const exampleCommentsDeletePermanentMutation = (options?: Partial<Options<ExampleCommentsDeletePermanentData>>): UseMutationOptions<ExampleCommentsDeletePermanentResponse, DefaultError, Options<ExampleCommentsDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsDeletePermanentResponse, DefaultError, Options<ExampleCommentsDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExampleComments.exampleCommentsDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Restore comment
 *
 * Restore a soft-deleted comment
 */
export const exampleCommentsRestoreMutation = (options?: Partial<Options<ExampleCommentsRestoreData>>): UseMutationOptions<ExampleCommentsRestoreResponse, DefaultError, Options<ExampleCommentsRestoreData>> => {
    const mutationOptions: UseMutationOptions<ExampleCommentsRestoreResponse, DefaultError, Options<ExampleCommentsRestoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await ExampleComments.exampleCommentsRestore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesListQueryKey = (options: Options<FilesListData>) => createQueryKey('filesList', options);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListOptions = (options: Options<FilesListData>) => queryOptions<FilesListResponse, DefaultError, FilesListResponse, ReturnType<typeof filesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Files.filesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListQueryKey(options)
});

export const filesListInfiniteQueryKey = (options: Options<FilesListData>): QueryKey<Options<FilesListData>> => createQueryKey('filesList', options, true);

/**
 * List files
 *
 * List files in an organization
 *
 * Returns paginated list of files with optional filtering.
 */
export const filesListInfiniteOptions = (options: Options<FilesListData>) => infiniteQueryOptions<FilesListResponse, DefaultError, InfiniteData<FilesListResponse>, QueryKey<Options<FilesListData>>, number | Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<FilesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Files.filesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesListInfiniteQueryKey(options)
});

/**
 * Direct file upload
 *
 * Direct file upload (multipart/form-data)
 *
 * For simple uploads of small files (< 10 MB).
 * File is uploaded directly to the API server.
 *
 * Note: For larger files or high volume, use presigned URL upload.
 */
export const filesDirectUploadMutation = (options?: Partial<Options<FilesDirectUploadData>>): UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesDirectUploadResponse, DefaultError, Options<FilesDirectUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Files.filesDirectUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Initiate presigned URL upload
 *
 * Initiate a presigned URL upload
 *
 * Returns a presigned URL for direct upload to storage (S3/R2/GCS).
 * Client uploads directly to storage, then confirms with the API.
 *
 * Flow:
 * 1. POST /files/uploads - Get presigned URL
 * 2. PUT {presignedUrl} - Upload directly to storage
 * 3. POST /files/uploads/{uploadId}/confirm - Confirm upload
 */
export const filesInitiateUploadMutation = (options?: Partial<Options<FilesInitiateUploadData>>): UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesInitiateUploadResponse, DefaultError, Options<FilesInitiateUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Files.filesInitiateUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Confirm presigned URL upload
 *
 * Confirm a presigned URL upload
 *
 * Called after client successfully uploads to the presigned URL.
 * Triggers virus scanning and creates the file record.
 */
export const filesConfirmUploadMutation = (options?: Partial<Options<FilesConfirmUploadData>>): UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> => {
    const mutationOptions: UseMutationOptions<FilesConfirmUploadResponse, DefaultError, Options<FilesConfirmUploadData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Files.filesConfirmUpload({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete file
 *
 * Delete a file (soft delete)
 *
 * File is marked as deleted but retained for audit purposes.
 * Storage is cleaned up after retention period.
 */
export const filesDeleteMutation = (options?: Partial<Options<FilesDeleteData>>): UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> => {
    const mutationOptions: UseMutationOptions<FilesDeleteResponse, DefaultError, Options<FilesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Files.filesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesGetQueryKey = (options: Options<FilesGetData>) => createQueryKey('filesGet', options);

/**
 * Get file
 *
 * Get a single file by ID
 *
 * Returns file metadata including a fresh signed URL for download.
 */
export const filesGetOptions = (options: Options<FilesGetData>) => queryOptions<FilesGetResponse, DefaultError, FilesGetResponse, ReturnType<typeof filesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Files.filesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesGetQueryKey(options)
});

/**
 * Update file
 *
 * Update file properties
 *
 * Currently supports changing the access level (private/public).
 */
export const filesUpdateMutation = (options?: Partial<Options<FilesUpdateData>>): UseMutationOptions<FilesUpdateResponse, DefaultError, Options<FilesUpdateData>> => {
    const mutationOptions: UseMutationOptions<FilesUpdateResponse, DefaultError, Options<FilesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Files.filesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const filesDownloadQueryKey = (options: Options<FilesDownloadData>) => createQueryKey('filesDownload', options);

/**
 * Download file
 *
 * Download a file
 *
 * Returns a redirect to a signed URL for the file.
 * The signed URL expires in 5 minutes.
 */
export const filesDownloadOptions = (options: Options<FilesDownloadData>) => queryOptions<FilesDownloadResponse, DefaultError, FilesDownloadResponse, ReturnType<typeof filesDownloadQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Files.filesDownload({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: filesDownloadQueryKey(options)
});

/**
 * Permanently delete file
 *
 * Permanently delete a file (hard delete)
 *
 * Immediately removes file from storage.
 * Use with caution - cannot be undone.
 */
export const filesDeletePermanentMutation = (options?: Partial<Options<FilesDeletePermanentData>>): UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> => {
    const mutationOptions: UseMutationOptions<FilesDeletePermanentResponse, DefaultError, Options<FilesDeletePermanentData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Files.filesDeletePermanent({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const infectionSurveillancesListQueryKey = (options: Options<InfectionSurveillancesListData>) => createQueryKey('infectionSurveillancesList', options);

/**
 * List infection surveillance cases
 *
 * List infection surveillance cases
 */
export const infectionSurveillancesListOptions = (options: Options<InfectionSurveillancesListData>) => queryOptions<InfectionSurveillancesListResponse, DefaultError, InfectionSurveillancesListResponse, ReturnType<typeof infectionSurveillancesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.infectionSurveillancesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: infectionSurveillancesListQueryKey(options)
});

export const infectionSurveillancesListInfiniteQueryKey = (options: Options<InfectionSurveillancesListData>): QueryKey<Options<InfectionSurveillancesListData>> => createQueryKey('infectionSurveillancesList', options, true);

/**
 * List infection surveillance cases
 *
 * List infection surveillance cases
 */
export const infectionSurveillancesListInfiniteOptions = (options: Options<InfectionSurveillancesListData>) => infiniteQueryOptions<InfectionSurveillancesListResponse, DefaultError, InfiniteData<InfectionSurveillancesListResponse>, QueryKey<Options<InfectionSurveillancesListData>>, number | Pick<QueryKey<Options<InfectionSurveillancesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<InfectionSurveillancesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Accreditation.infectionSurveillancesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: infectionSurveillancesListInfiniteQueryKey(options)
});

/**
 * Report infection case
 *
 * Report infection case
 */
export const infectionSurveillancesReportMutation = (options?: Partial<Options<InfectionSurveillancesReportData>>): UseMutationOptions<InfectionSurveillancesReportResponse, DefaultError, Options<InfectionSurveillancesReportData>> => {
    const mutationOptions: UseMutationOptions<InfectionSurveillancesReportResponse, DefaultError, Options<InfectionSurveillancesReportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.infectionSurveillancesReport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const infectionSurveillancesGetQueryKey = (options: Options<InfectionSurveillancesGetData>) => createQueryKey('infectionSurveillancesGet', options);

/**
 * Get infection case
 *
 * Get infection case
 */
export const infectionSurveillancesGetOptions = (options: Options<InfectionSurveillancesGetData>) => queryOptions<InfectionSurveillancesGetResponse, DefaultError, InfectionSurveillancesGetResponse, ReturnType<typeof infectionSurveillancesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.infectionSurveillancesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: infectionSurveillancesGetQueryKey(options)
});

/**
 * Confirm infection
 *
 * Confirm infection
 */
export const infectionSurveillancesConfirmMutation = (options?: Partial<Options<InfectionSurveillancesConfirmData>>): UseMutationOptions<InfectionSurveillancesConfirmResponse, DefaultError, Options<InfectionSurveillancesConfirmData>> => {
    const mutationOptions: UseMutationOptions<InfectionSurveillancesConfirmResponse, DefaultError, Options<InfectionSurveillancesConfirmData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.infectionSurveillancesConfirm({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resolve infection case
 *
 * Resolve infection case
 */
export const infectionSurveillancesResolveMutation = (options?: Partial<Options<InfectionSurveillancesResolveData>>): UseMutationOptions<InfectionSurveillancesResolveResponse, DefaultError, Options<InfectionSurveillancesResolveData>> => {
    const mutationOptions: UseMutationOptions<InfectionSurveillancesResolveResponse, DefaultError, Options<InfectionSurveillancesResolveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.infectionSurveillancesResolve({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const integrationDashboardGetQueryKey = (options: Options<IntegrationDashboardGetData>) => createQueryKey('integrationDashboardGet', options);

/**
 * Get integration dashboard
 *
 * Get integration dashboard
 */
export const integrationDashboardGetOptions = (options: Options<IntegrationDashboardGetData>) => queryOptions<IntegrationDashboardGetResponse, DefaultError, IntegrationDashboardGetResponse, ReturnType<typeof integrationDashboardGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.integrationDashboardGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: integrationDashboardGetQueryKey(options)
});

export const integrationErrorLogsListQueryKey = (options: Options<IntegrationErrorLogsListData>) => createQueryKey('integrationErrorLogsList', options);

/**
 * List integration error logs
 *
 * List error logs
 */
export const integrationErrorLogsListOptions = (options: Options<IntegrationErrorLogsListData>) => queryOptions<IntegrationErrorLogsListResponse, DefaultError, IntegrationErrorLogsListResponse, ReturnType<typeof integrationErrorLogsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.integrationErrorLogsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: integrationErrorLogsListQueryKey(options)
});

export const integrationErrorLogsListInfiniteQueryKey = (options: Options<IntegrationErrorLogsListData>): QueryKey<Options<IntegrationErrorLogsListData>> => createQueryKey('integrationErrorLogsList', options, true);

/**
 * List integration error logs
 *
 * List error logs
 */
export const integrationErrorLogsListInfiniteOptions = (options: Options<IntegrationErrorLogsListData>) => infiniteQueryOptions<IntegrationErrorLogsListResponse, DefaultError, InfiniteData<IntegrationErrorLogsListResponse>, QueryKey<Options<IntegrationErrorLogsListData>>, number | Pick<QueryKey<Options<IntegrationErrorLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<IntegrationErrorLogsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Integrations.integrationErrorLogsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: integrationErrorLogsListInfiniteQueryKey(options)
});

export const integrationErrorLogsGetQueryKey = (options: Options<IntegrationErrorLogsGetData>) => createQueryKey('integrationErrorLogsGet', options);

/**
 * Get integration error log
 *
 * Get error log
 */
export const integrationErrorLogsGetOptions = (options: Options<IntegrationErrorLogsGetData>) => queryOptions<IntegrationErrorLogsGetResponse, DefaultError, IntegrationErrorLogsGetResponse, ReturnType<typeof integrationErrorLogsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.integrationErrorLogsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: integrationErrorLogsGetQueryKey(options)
});

/**
 * Ignore integration error
 *
 * Ignore error
 */
export const integrationErrorLogsIgnoreMutation = (options?: Partial<Options<IntegrationErrorLogsIgnoreData>>): UseMutationOptions<IntegrationErrorLogsIgnoreResponse, DefaultError, Options<IntegrationErrorLogsIgnoreData>> => {
    const mutationOptions: UseMutationOptions<IntegrationErrorLogsIgnoreResponse, DefaultError, Options<IntegrationErrorLogsIgnoreData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.integrationErrorLogsIgnore({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resolve integration error
 *
 * Resolve error
 */
export const integrationErrorLogsResolveMutation = (options?: Partial<Options<IntegrationErrorLogsResolveData>>): UseMutationOptions<IntegrationErrorLogsResolveResponse, DefaultError, Options<IntegrationErrorLogsResolveData>> => {
    const mutationOptions: UseMutationOptions<IntegrationErrorLogsResolveResponse, DefaultError, Options<IntegrationErrorLogsResolveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.integrationErrorLogsResolve({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const jknConfigsListQueryKey = (options: Options<JknConfigsListData>) => createQueryKey('jknConfigsList', options);

/**
 * List JKN configs
 *
 * List JKN configurations
 */
export const jknConfigsListOptions = (options: Options<JknConfigsListData>) => queryOptions<JknConfigsListResponse, DefaultError, JknConfigsListResponse, ReturnType<typeof jknConfigsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.jknConfigsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jknConfigsListQueryKey(options)
});

/**
 * Create JKN config
 *
 * Create JKN configuration
 */
export const jknConfigsCreateMutation = (options?: Partial<Options<JknConfigsCreateData>>): UseMutationOptions<JknConfigsCreateResponse, DefaultError, Options<JknConfigsCreateData>> => {
    const mutationOptions: UseMutationOptions<JknConfigsCreateResponse, DefaultError, Options<JknConfigsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.jknConfigsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete JKN config
 *
 * Delete JKN configuration
 */
export const jknConfigsDeleteMutation = (options?: Partial<Options<JknConfigsDeleteData>>): UseMutationOptions<JknConfigsDeleteResponse, DefaultError, Options<JknConfigsDeleteData>> => {
    const mutationOptions: UseMutationOptions<JknConfigsDeleteResponse, DefaultError, Options<JknConfigsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.jknConfigsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const jknConfigsGetQueryKey = (options: Options<JknConfigsGetData>) => createQueryKey('jknConfigsGet', options);

/**
 * Get JKN config
 *
 * Get JKN configuration
 */
export const jknConfigsGetOptions = (options: Options<JknConfigsGetData>) => queryOptions<JknConfigsGetResponse, DefaultError, JknConfigsGetResponse, ReturnType<typeof jknConfigsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.jknConfigsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jknConfigsGetQueryKey(options)
});

/**
 * Update JKN config
 *
 * Update JKN configuration
 */
export const jknConfigsUpdateMutation = (options?: Partial<Options<JknConfigsUpdateData>>): UseMutationOptions<JknConfigsUpdateResponse, DefaultError, Options<JknConfigsUpdateData>> => {
    const mutationOptions: UseMutationOptions<JknConfigsUpdateResponse, DefaultError, Options<JknConfigsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.jknConfigsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test JKN connection
 *
 * Test JKN connection
 */
export const jknConfigsTestMutation = (options?: Partial<Options<JknConfigsTestData>>): UseMutationOptions<JknConfigsTestResponse, DefaultError, Options<JknConfigsTestData>> => {
    const mutationOptions: UseMutationOptions<JknConfigsTestResponse, DefaultError, Options<JknConfigsTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.jknConfigsTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const satusehatConfigsListQueryKey = (options: Options<SatusehatConfigsListData>) => createQueryKey('satusehatConfigsList', options);

/**
 * List SatuSehat configs
 *
 * List SatuSehat configurations
 */
export const satusehatConfigsListOptions = (options: Options<SatusehatConfigsListData>) => queryOptions<SatusehatConfigsListResponse, DefaultError, SatusehatConfigsListResponse, ReturnType<typeof satusehatConfigsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.satusehatConfigsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: satusehatConfigsListQueryKey(options)
});

/**
 * Create SatuSehat config
 *
 * Create SatuSehat configuration
 */
export const satusehatConfigsCreateMutation = (options?: Partial<Options<SatusehatConfigsCreateData>>): UseMutationOptions<SatusehatConfigsCreateResponse, DefaultError, Options<SatusehatConfigsCreateData>> => {
    const mutationOptions: UseMutationOptions<SatusehatConfigsCreateResponse, DefaultError, Options<SatusehatConfigsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.satusehatConfigsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete SatuSehat config
 *
 * Delete SatuSehat configuration
 */
export const satusehatConfigsDeleteMutation = (options?: Partial<Options<SatusehatConfigsDeleteData>>): UseMutationOptions<SatusehatConfigsDeleteResponse, DefaultError, Options<SatusehatConfigsDeleteData>> => {
    const mutationOptions: UseMutationOptions<SatusehatConfigsDeleteResponse, DefaultError, Options<SatusehatConfigsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.satusehatConfigsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const satusehatConfigsGetQueryKey = (options: Options<SatusehatConfigsGetData>) => createQueryKey('satusehatConfigsGet', options);

/**
 * Get SatuSehat config
 *
 * Get SatuSehat configuration
 */
export const satusehatConfigsGetOptions = (options: Options<SatusehatConfigsGetData>) => queryOptions<SatusehatConfigsGetResponse, DefaultError, SatusehatConfigsGetResponse, ReturnType<typeof satusehatConfigsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.satusehatConfigsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: satusehatConfigsGetQueryKey(options)
});

/**
 * Update SatuSehat config
 *
 * Update SatuSehat configuration
 */
export const satusehatConfigsUpdateMutation = (options?: Partial<Options<SatusehatConfigsUpdateData>>): UseMutationOptions<SatusehatConfigsUpdateResponse, DefaultError, Options<SatusehatConfigsUpdateData>> => {
    const mutationOptions: UseMutationOptions<SatusehatConfigsUpdateResponse, DefaultError, Options<SatusehatConfigsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.satusehatConfigsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Refresh SatuSehat token
 *
 * Refresh SatuSehat access token
 */
export const satusehatConfigsRefreshTokenMutation = (options?: Partial<Options<SatusehatConfigsRefreshTokenData>>): UseMutationOptions<SatusehatConfigsRefreshTokenResponse, DefaultError, Options<SatusehatConfigsRefreshTokenData>> => {
    const mutationOptions: UseMutationOptions<SatusehatConfigsRefreshTokenResponse, DefaultError, Options<SatusehatConfigsRefreshTokenData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.satusehatConfigsRefreshToken({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test SatuSehat connection
 *
 * Test SatuSehat connection
 */
export const satusehatConfigsTestMutation = (options?: Partial<Options<SatusehatConfigsTestData>>): UseMutationOptions<SatusehatConfigsTestResponse, DefaultError, Options<SatusehatConfigsTestData>> => {
    const mutationOptions: UseMutationOptions<SatusehatConfigsTestResponse, DefaultError, Options<SatusehatConfigsTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.satusehatConfigsTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const integrationSyncQueuesListQueryKey = (options: Options<IntegrationSyncQueuesListData>) => createQueryKey('integrationSyncQueuesList', options);

/**
 * List sync queue
 *
 * List sync queue entries
 */
export const integrationSyncQueuesListOptions = (options: Options<IntegrationSyncQueuesListData>) => queryOptions<IntegrationSyncQueuesListResponse, DefaultError, IntegrationSyncQueuesListResponse, ReturnType<typeof integrationSyncQueuesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.integrationSyncQueuesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: integrationSyncQueuesListQueryKey(options)
});

export const integrationSyncQueuesListInfiniteQueryKey = (options: Options<IntegrationSyncQueuesListData>): QueryKey<Options<IntegrationSyncQueuesListData>> => createQueryKey('integrationSyncQueuesList', options, true);

/**
 * List sync queue
 *
 * List sync queue entries
 */
export const integrationSyncQueuesListInfiniteOptions = (options: Options<IntegrationSyncQueuesListData>) => infiniteQueryOptions<IntegrationSyncQueuesListResponse, DefaultError, InfiniteData<IntegrationSyncQueuesListResponse>, QueryKey<Options<IntegrationSyncQueuesListData>>, number | Pick<QueryKey<Options<IntegrationSyncQueuesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<IntegrationSyncQueuesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Integrations.integrationSyncQueuesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: integrationSyncQueuesListInfiniteQueryKey(options)
});

/**
 * Retry failed syncs
 *
 * Retry failed sync
 */
export const integrationSyncQueuesRetryMutation = (options?: Partial<Options<IntegrationSyncQueuesRetryData>>): UseMutationOptions<IntegrationSyncQueuesRetryResponse, DefaultError, Options<IntegrationSyncQueuesRetryData>> => {
    const mutationOptions: UseMutationOptions<IntegrationSyncQueuesRetryResponse, DefaultError, Options<IntegrationSyncQueuesRetryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.integrationSyncQueuesRetry({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const integrationSyncQueuesGetQueryKey = (options: Options<IntegrationSyncQueuesGetData>) => createQueryKey('integrationSyncQueuesGet', options);

/**
 * Get sync queue entry
 *
 * Get sync queue entry
 */
export const integrationSyncQueuesGetOptions = (options: Options<IntegrationSyncQueuesGetData>) => queryOptions<IntegrationSyncQueuesGetResponse, DefaultError, IntegrationSyncQueuesGetResponse, ReturnType<typeof integrationSyncQueuesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Integrations.integrationSyncQueuesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: integrationSyncQueuesGetQueryKey(options)
});

/**
 * Cancel pending sync
 *
 * Cancel pending sync
 */
export const integrationSyncQueuesCancelMutation = (options?: Partial<Options<IntegrationSyncQueuesCancelData>>): UseMutationOptions<IntegrationSyncQueuesCancelResponse, DefaultError, Options<IntegrationSyncQueuesCancelData>> => {
    const mutationOptions: UseMutationOptions<IntegrationSyncQueuesCancelResponse, DefaultError, Options<IntegrationSyncQueuesCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Integrations.integrationSyncQueuesCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const invoicesListQueryKey = (options: Options<InvoicesListData>) => createQueryKey('invoicesList', options);

/**
 * List invoices
 *
 * List invoices
 */
export const invoicesListOptions = (options: Options<InvoicesListData>) => queryOptions<InvoicesListResponse, DefaultError, InvoicesListResponse, ReturnType<typeof invoicesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Billing.invoicesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: invoicesListQueryKey(options)
});

export const invoicesListInfiniteQueryKey = (options: Options<InvoicesListData>): QueryKey<Options<InvoicesListData>> => createQueryKey('invoicesList', options, true);

/**
 * List invoices
 *
 * List invoices
 */
export const invoicesListInfiniteOptions = (options: Options<InvoicesListData>) => infiniteQueryOptions<InvoicesListResponse, DefaultError, InfiniteData<InvoicesListResponse>, QueryKey<Options<InvoicesListData>>, number | Pick<QueryKey<Options<InvoicesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<InvoicesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Billing.invoicesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: invoicesListInfiniteQueryKey(options)
});

/**
 * Create invoice
 *
 * Create invoice
 */
export const invoicesCreateMutation = (options?: Partial<Options<InvoicesCreateData>>): UseMutationOptions<InvoicesCreateResponse, DefaultError, Options<InvoicesCreateData>> => {
    const mutationOptions: UseMutationOptions<InvoicesCreateResponse, DefaultError, Options<InvoicesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.invoicesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const invoicesGetSummaryQueryKey = (options: Options<InvoicesGetSummaryData>) => createQueryKey('invoicesGetSummary', options);

/**
 * Get billing summary
 *
 * Get billing summary
 */
export const invoicesGetSummaryOptions = (options: Options<InvoicesGetSummaryData>) => queryOptions<InvoicesGetSummaryResponse, DefaultError, InvoicesGetSummaryResponse, ReturnType<typeof invoicesGetSummaryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Billing.invoicesGetSummary({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: invoicesGetSummaryQueryKey(options)
});

export const invoicesGetQueryKey = (options: Options<InvoicesGetData>) => createQueryKey('invoicesGet', options);

/**
 * Get invoice
 *
 * Get invoice
 */
export const invoicesGetOptions = (options: Options<InvoicesGetData>) => queryOptions<InvoicesGetResponse, DefaultError, InvoicesGetResponse, ReturnType<typeof invoicesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Billing.invoicesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: invoicesGetQueryKey(options)
});

/**
 * Update invoice
 *
 * Update invoice
 */
export const invoicesUpdateMutation = (options?: Partial<Options<InvoicesUpdateData>>): UseMutationOptions<InvoicesUpdateResponse, DefaultError, Options<InvoicesUpdateData>> => {
    const mutationOptions: UseMutationOptions<InvoicesUpdateResponse, DefaultError, Options<InvoicesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.invoicesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Approve invoice
 *
 * Approve invoice
 */
export const invoicesApproveMutation = (options?: Partial<Options<InvoicesApproveData>>): UseMutationOptions<InvoicesApproveResponse, DefaultError, Options<InvoicesApproveData>> => {
    const mutationOptions: UseMutationOptions<InvoicesApproveResponse, DefaultError, Options<InvoicesApproveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.invoicesApprove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Void invoice
 *
 * Void invoice
 */
export const invoicesVoidInvoiceMutation = (options?: Partial<Options<InvoicesVoidInvoiceData>>): UseMutationOptions<InvoicesVoidInvoiceResponse, DefaultError, Options<InvoicesVoidInvoiceData>> => {
    const mutationOptions: UseMutationOptions<InvoicesVoidInvoiceResponse, DefaultError, Options<InvoicesVoidInvoiceData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.invoicesVoidInvoice({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const jobsListQueryKey = (options: Options<JobsListData>) => createQueryKey('jobsList', options);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsListOptions = (options: Options<JobsListData>) => queryOptions<JobsListResponse, DefaultError, JobsListResponse, ReturnType<typeof jobsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Jobs.jobsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListQueryKey(options)
});

export const jobsListInfiniteQueryKey = (options: Options<JobsListData>): QueryKey<Options<JobsListData>> => createQueryKey('jobsList', options, true);

/**
 * List jobs
 *
 * List async jobs
 *
 * Returns jobs for the current tenant.
 */
export const jobsListInfiniteOptions = (options: Options<JobsListData>) => infiniteQueryOptions<JobsListResponse, DefaultError, InfiniteData<JobsListResponse>, QueryKey<Options<JobsListData>>, number | Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<JobsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Jobs.jobsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsListInfiniteQueryKey(options)
});

export const jobsGetQueryKey = (options: Options<JobsGetData>) => createQueryKey('jobsGet', options);

/**
 * Get job status
 *
 * Get job status
 *
 * Poll this endpoint to check progress of async operations.
 */
export const jobsGetOptions = (options: Options<JobsGetData>) => queryOptions<JobsGetResponse, DefaultError, JobsGetResponse, ReturnType<typeof jobsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Jobs.jobsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: jobsGetQueryKey(options)
});

/**
 * Cancel job
 *
 * Cancel a job
 *
 * Only pending or processing jobs can be cancelled.
 */
export const jobsCancelMutation = (options?: Partial<Options<JobsCancelData>>): UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> => {
    const mutationOptions: UseMutationOptions<JobsCancelResponse, DefaultError, Options<JobsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Jobs.jobsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const labOrdersListQueryKey = (options: Options<LabOrdersListData>) => createQueryKey('labOrdersList', options);

/**
 * List lab orders
 *
 * List lab orders
 */
export const labOrdersListOptions = (options: Options<LabOrdersListData>) => queryOptions<LabOrdersListResponse, DefaultError, LabOrdersListResponse, ReturnType<typeof labOrdersListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.labOrdersList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labOrdersListQueryKey(options)
});

export const labOrdersListInfiniteQueryKey = (options: Options<LabOrdersListData>): QueryKey<Options<LabOrdersListData>> => createQueryKey('labOrdersList', options, true);

/**
 * List lab orders
 *
 * List lab orders
 */
export const labOrdersListInfiniteOptions = (options: Options<LabOrdersListData>) => infiniteQueryOptions<LabOrdersListResponse, DefaultError, InfiniteData<LabOrdersListResponse>, QueryKey<Options<LabOrdersListData>>, number | Pick<QueryKey<Options<LabOrdersListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<LabOrdersListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Laboratory.labOrdersList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labOrdersListInfiniteQueryKey(options)
});

/**
 * Create lab order
 *
 * Create lab order
 */
export const labOrdersCreateMutation = (options?: Partial<Options<LabOrdersCreateData>>): UseMutationOptions<LabOrdersCreateResponse, DefaultError, Options<LabOrdersCreateData>> => {
    const mutationOptions: UseMutationOptions<LabOrdersCreateResponse, DefaultError, Options<LabOrdersCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labOrdersCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const labOrdersGetQueryKey = (options: Options<LabOrdersGetData>) => createQueryKey('labOrdersGet', options);

/**
 * Get lab order
 *
 * Get lab order
 */
export const labOrdersGetOptions = (options: Options<LabOrdersGetData>) => queryOptions<LabOrdersGetResponse, DefaultError, LabOrdersGetResponse, ReturnType<typeof labOrdersGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.labOrdersGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labOrdersGetQueryKey(options)
});

/**
 * Cancel lab order
 *
 * Cancel lab order
 */
export const labOrdersCancelMutation = (options?: Partial<Options<LabOrdersCancelData>>): UseMutationOptions<LabOrdersCancelResponse, DefaultError, Options<LabOrdersCancelData>> => {
    const mutationOptions: UseMutationOptions<LabOrdersCancelResponse, DefaultError, Options<LabOrdersCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labOrdersCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update lab order status
 *
 * Update lab order status
 */
export const labOrdersUpdateStatusMutation = (options?: Partial<Options<LabOrdersUpdateStatusData>>): UseMutationOptions<LabOrdersUpdateStatusResponse, DefaultError, Options<LabOrdersUpdateStatusData>> => {
    const mutationOptions: UseMutationOptions<LabOrdersUpdateStatusResponse, DefaultError, Options<LabOrdersUpdateStatusData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labOrdersUpdateStatus({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const labResultsListQueryKey = (options: Options<LabResultsListData>) => createQueryKey('labResultsList', options);

/**
 * List lab results
 *
 * List lab results
 */
export const labResultsListOptions = (options: Options<LabResultsListData>) => queryOptions<LabResultsListResponse, DefaultError, LabResultsListResponse, ReturnType<typeof labResultsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.labResultsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labResultsListQueryKey(options)
});

export const labResultsListInfiniteQueryKey = (options: Options<LabResultsListData>): QueryKey<Options<LabResultsListData>> => createQueryKey('labResultsList', options, true);

/**
 * List lab results
 *
 * List lab results
 */
export const labResultsListInfiniteOptions = (options: Options<LabResultsListData>) => infiniteQueryOptions<LabResultsListResponse, DefaultError, InfiniteData<LabResultsListResponse>, QueryKey<Options<LabResultsListData>>, number | Pick<QueryKey<Options<LabResultsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<LabResultsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Laboratory.labResultsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labResultsListInfiniteQueryKey(options)
});

/**
 * Enter lab result
 *
 * Enter lab result
 */
export const labResultsEnterMutation = (options?: Partial<Options<LabResultsEnterData>>): UseMutationOptions<LabResultsEnterResponse, DefaultError, Options<LabResultsEnterData>> => {
    const mutationOptions: UseMutationOptions<LabResultsEnterResponse, DefaultError, Options<LabResultsEnterData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labResultsEnter({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const labResultsGetQueryKey = (options: Options<LabResultsGetData>) => createQueryKey('labResultsGet', options);

/**
 * Get lab result
 *
 * Get lab result
 */
export const labResultsGetOptions = (options: Options<LabResultsGetData>) => queryOptions<LabResultsGetResponse, DefaultError, LabResultsGetResponse, ReturnType<typeof labResultsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.labResultsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labResultsGetQueryKey(options)
});

/**
 * Unverify lab result
 *
 * Unverify lab result
 */
export const labResultsUnverifyMutation = (options?: Partial<Options<LabResultsUnverifyData>>): UseMutationOptions<LabResultsUnverifyResponse, DefaultError, Options<LabResultsUnverifyData>> => {
    const mutationOptions: UseMutationOptions<LabResultsUnverifyResponse, DefaultError, Options<LabResultsUnverifyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labResultsUnverify({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Verify lab result
 *
 * Verify lab result
 */
export const labResultsVerifyMutation = (options?: Partial<Options<LabResultsVerifyData>>): UseMutationOptions<LabResultsVerifyResponse, DefaultError, Options<LabResultsVerifyData>> => {
    const mutationOptions: UseMutationOptions<LabResultsVerifyResponse, DefaultError, Options<LabResultsVerifyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labResultsVerify({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const labTestsListQueryKey = (options: Options<LabTestsListData>) => createQueryKey('labTestsList', options);

/**
 * List lab tests
 *
 * List lab tests
 */
export const labTestsListOptions = (options: Options<LabTestsListData>) => queryOptions<LabTestsListResponse, DefaultError, LabTestsListResponse, ReturnType<typeof labTestsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.labTestsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labTestsListQueryKey(options)
});

export const labTestsListInfiniteQueryKey = (options: Options<LabTestsListData>): QueryKey<Options<LabTestsListData>> => createQueryKey('labTestsList', options, true);

/**
 * List lab tests
 *
 * List lab tests
 */
export const labTestsListInfiniteOptions = (options: Options<LabTestsListData>) => infiniteQueryOptions<LabTestsListResponse, DefaultError, InfiniteData<LabTestsListResponse>, QueryKey<Options<LabTestsListData>>, number | Pick<QueryKey<Options<LabTestsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<LabTestsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Laboratory.labTestsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labTestsListInfiniteQueryKey(options)
});

/**
 * Create lab test
 *
 * Create lab test
 */
export const labTestsCreateMutation = (options?: Partial<Options<LabTestsCreateData>>): UseMutationOptions<LabTestsCreateResponse, DefaultError, Options<LabTestsCreateData>> => {
    const mutationOptions: UseMutationOptions<LabTestsCreateResponse, DefaultError, Options<LabTestsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labTestsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete lab test
 *
 * Delete lab test
 */
export const labTestsDeleteMutation = (options?: Partial<Options<LabTestsDeleteData>>): UseMutationOptions<LabTestsDeleteResponse, DefaultError, Options<LabTestsDeleteData>> => {
    const mutationOptions: UseMutationOptions<LabTestsDeleteResponse, DefaultError, Options<LabTestsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labTestsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const labTestsGetQueryKey = (options: Options<LabTestsGetData>) => createQueryKey('labTestsGet', options);

/**
 * Get lab test
 *
 * Get lab test
 */
export const labTestsGetOptions = (options: Options<LabTestsGetData>) => queryOptions<LabTestsGetResponse, DefaultError, LabTestsGetResponse, ReturnType<typeof labTestsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.labTestsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: labTestsGetQueryKey(options)
});

/**
 * Update lab test
 *
 * Update lab test
 */
export const labTestsUpdateMutation = (options?: Partial<Options<LabTestsUpdateData>>): UseMutationOptions<LabTestsUpdateResponse, DefaultError, Options<LabTestsUpdateData>> => {
    const mutationOptions: UseMutationOptions<LabTestsUpdateResponse, DefaultError, Options<LabTestsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.labTestsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patientSafetyIncidentsListQueryKey = (options: Options<PatientSafetyIncidentsListData>) => createQueryKey('patientSafetyIncidentsList', options);

/**
 * List patient safety incidents
 *
 * List patient safety incidents
 */
export const patientSafetyIncidentsListOptions = (options: Options<PatientSafetyIncidentsListData>) => queryOptions<PatientSafetyIncidentsListResponse, DefaultError, PatientSafetyIncidentsListResponse, ReturnType<typeof patientSafetyIncidentsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.patientSafetyIncidentsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientSafetyIncidentsListQueryKey(options)
});

export const patientSafetyIncidentsListInfiniteQueryKey = (options: Options<PatientSafetyIncidentsListData>): QueryKey<Options<PatientSafetyIncidentsListData>> => createQueryKey('patientSafetyIncidentsList', options, true);

/**
 * List patient safety incidents
 *
 * List patient safety incidents
 */
export const patientSafetyIncidentsListInfiniteOptions = (options: Options<PatientSafetyIncidentsListData>) => infiniteQueryOptions<PatientSafetyIncidentsListResponse, DefaultError, InfiniteData<PatientSafetyIncidentsListResponse>, QueryKey<Options<PatientSafetyIncidentsListData>>, number | Pick<QueryKey<Options<PatientSafetyIncidentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PatientSafetyIncidentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Accreditation.patientSafetyIncidentsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientSafetyIncidentsListInfiniteQueryKey(options)
});

/**
 * Report patient safety incident
 *
 * Report patient safety incident
 */
export const patientSafetyIncidentsReportMutation = (options?: Partial<Options<PatientSafetyIncidentsReportData>>): UseMutationOptions<PatientSafetyIncidentsReportResponse, DefaultError, Options<PatientSafetyIncidentsReportData>> => {
    const mutationOptions: UseMutationOptions<PatientSafetyIncidentsReportResponse, DefaultError, Options<PatientSafetyIncidentsReportData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.patientSafetyIncidentsReport({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patientSafetyIncidentsGetQueryKey = (options: Options<PatientSafetyIncidentsGetData>) => createQueryKey('patientSafetyIncidentsGet', options);

/**
 * Get patient safety incident
 *
 * Get patient safety incident
 */
export const patientSafetyIncidentsGetOptions = (options: Options<PatientSafetyIncidentsGetData>) => queryOptions<PatientSafetyIncidentsGetResponse, DefaultError, PatientSafetyIncidentsGetResponse, ReturnType<typeof patientSafetyIncidentsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.patientSafetyIncidentsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientSafetyIncidentsGetQueryKey(options)
});

/**
 * Start investigation
 *
 * Start investigation
 */
export const patientSafetyIncidentsInvestigateMutation = (options?: Partial<Options<PatientSafetyIncidentsInvestigateData>>): UseMutationOptions<PatientSafetyIncidentsInvestigateResponse, DefaultError, Options<PatientSafetyIncidentsInvestigateData>> => {
    const mutationOptions: UseMutationOptions<PatientSafetyIncidentsInvestigateResponse, DefaultError, Options<PatientSafetyIncidentsInvestigateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.patientSafetyIncidentsInvestigate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Resolve incident
 *
 * Resolve incident
 */
export const patientSafetyIncidentsResolveMutation = (options?: Partial<Options<PatientSafetyIncidentsResolveData>>): UseMutationOptions<PatientSafetyIncidentsResolveResponse, DefaultError, Options<PatientSafetyIncidentsResolveData>> => {
    const mutationOptions: UseMutationOptions<PatientSafetyIncidentsResolveResponse, DefaultError, Options<PatientSafetyIncidentsResolveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.patientSafetyIncidentsResolve({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patientsListQueryKey = (options: Options<PatientsListData>) => createQueryKey('patientsList', options);

/**
 * List patients
 *
 * List patients
 */
export const patientsListOptions = (options: Options<PatientsListData>) => queryOptions<PatientsListResponse, DefaultError, PatientsListResponse, ReturnType<typeof patientsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Patients.patientsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientsListQueryKey(options)
});

export const patientsListInfiniteQueryKey = (options: Options<PatientsListData>): QueryKey<Options<PatientsListData>> => createQueryKey('patientsList', options, true);

/**
 * List patients
 *
 * List patients
 */
export const patientsListInfiniteOptions = (options: Options<PatientsListData>) => infiniteQueryOptions<PatientsListResponse, DefaultError, InfiniteData<PatientsListResponse>, QueryKey<Options<PatientsListData>>, number | Pick<QueryKey<Options<PatientsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PatientsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Patients.patientsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientsListInfiniteQueryKey(options)
});

/**
 * Register patient
 *
 * Register a new patient
 */
export const patientsCreateMutation = (options?: Partial<Options<PatientsCreateData>>): UseMutationOptions<PatientsCreateResponse, DefaultError, Options<PatientsCreateData>> => {
    const mutationOptions: UseMutationOptions<PatientsCreateResponse, DefaultError, Options<PatientsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.patientsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patientsSearchByBpjsQueryKey = (options: Options<PatientsSearchByBpjsData>) => createQueryKey('patientsSearchByBpjs', options);

/**
 * Search patient by BPJS number
 *
 * Search patient by BPJS number
 */
export const patientsSearchByBpjsOptions = (options: Options<PatientsSearchByBpjsData>) => queryOptions<PatientsSearchByBpjsResponse, DefaultError, PatientsSearchByBpjsResponse, ReturnType<typeof patientsSearchByBpjsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Patients.patientsSearchByBpjs({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientsSearchByBpjsQueryKey(options)
});

export const patientsSearchByNikQueryKey = (options: Options<PatientsSearchByNikData>) => createQueryKey('patientsSearchByNik', options);

/**
 * Search patient by NIK
 *
 * Search patient by NIK
 */
export const patientsSearchByNikOptions = (options: Options<PatientsSearchByNikData>) => queryOptions<PatientsSearchByNikResponse, DefaultError, PatientsSearchByNikResponse, ReturnType<typeof patientsSearchByNikQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Patients.patientsSearchByNik({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientsSearchByNikQueryKey(options)
});

/**
 * Delete patient
 *
 * Delete patient (soft delete)
 */
export const patientsDeleteMutation = (options?: Partial<Options<PatientsDeleteData>>): UseMutationOptions<PatientsDeleteResponse, DefaultError, Options<PatientsDeleteData>> => {
    const mutationOptions: UseMutationOptions<PatientsDeleteResponse, DefaultError, Options<PatientsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.patientsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patientsGetQueryKey = (options: Options<PatientsGetData>) => createQueryKey('patientsGet', options);

/**
 * Get patient
 *
 * Get patient by ID
 */
export const patientsGetOptions = (options: Options<PatientsGetData>) => queryOptions<PatientsGetResponse, DefaultError, PatientsGetResponse, ReturnType<typeof patientsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Patients.patientsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientsGetQueryKey(options)
});

/**
 * Update patient
 *
 * Update patient
 */
export const patientsUpdateMutation = (options?: Partial<Options<PatientsUpdateData>>): UseMutationOptions<PatientsUpdateResponse, DefaultError, Options<PatientsUpdateData>> => {
    const mutationOptions: UseMutationOptions<PatientsUpdateResponse, DefaultError, Options<PatientsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.patientsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const patientAllergiesListQueryKey = (options: Options<PatientAllergiesListData>) => createQueryKey('patientAllergiesList', options);

/**
 * List patient allergies
 *
 * List patient allergies
 */
export const patientAllergiesListOptions = (options: Options<PatientAllergiesListData>) => queryOptions<PatientAllergiesListResponse, DefaultError, PatientAllergiesListResponse, ReturnType<typeof patientAllergiesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Patients.patientAllergiesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: patientAllergiesListQueryKey(options)
});

/**
 * Add patient allergy
 *
 * Add allergy
 */
export const patientAllergiesCreateMutation = (options?: Partial<Options<PatientAllergiesCreateData>>): UseMutationOptions<PatientAllergiesCreateResponse, DefaultError, Options<PatientAllergiesCreateData>> => {
    const mutationOptions: UseMutationOptions<PatientAllergiesCreateResponse, DefaultError, Options<PatientAllergiesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.patientAllergiesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete patient allergy
 *
 * Delete allergy
 */
export const patientAllergiesDeleteMutation = (options?: Partial<Options<PatientAllergiesDeleteData>>): UseMutationOptions<PatientAllergiesDeleteResponse, DefaultError, Options<PatientAllergiesDeleteData>> => {
    const mutationOptions: UseMutationOptions<PatientAllergiesDeleteResponse, DefaultError, Options<PatientAllergiesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.patientAllergiesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update patient allergy
 *
 * Update allergy
 */
export const patientAllergiesUpdateMutation = (options?: Partial<Options<PatientAllergiesUpdateData>>): UseMutationOptions<PatientAllergiesUpdateResponse, DefaultError, Options<PatientAllergiesUpdateData>> => {
    const mutationOptions: UseMutationOptions<PatientAllergiesUpdateResponse, DefaultError, Options<PatientAllergiesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.patientAllergiesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const chronicConditionsListQueryKey = (options: Options<ChronicConditionsListData>) => createQueryKey('chronicConditionsList', options);

/**
 * List chronic conditions
 *
 * List chronic conditions
 */
export const chronicConditionsListOptions = (options: Options<ChronicConditionsListData>) => queryOptions<ChronicConditionsListResponse, DefaultError, ChronicConditionsListResponse, ReturnType<typeof chronicConditionsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Patients.chronicConditionsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: chronicConditionsListQueryKey(options)
});

/**
 * Add chronic condition
 *
 * Add chronic condition
 */
export const chronicConditionsCreateMutation = (options?: Partial<Options<ChronicConditionsCreateData>>): UseMutationOptions<ChronicConditionsCreateResponse, DefaultError, Options<ChronicConditionsCreateData>> => {
    const mutationOptions: UseMutationOptions<ChronicConditionsCreateResponse, DefaultError, Options<ChronicConditionsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.chronicConditionsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete chronic condition
 *
 * Delete chronic condition
 */
export const chronicConditionsDeleteMutation = (options?: Partial<Options<ChronicConditionsDeleteData>>): UseMutationOptions<ChronicConditionsDeleteResponse, DefaultError, Options<ChronicConditionsDeleteData>> => {
    const mutationOptions: UseMutationOptions<ChronicConditionsDeleteResponse, DefaultError, Options<ChronicConditionsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.chronicConditionsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update chronic condition
 *
 * Update chronic condition
 */
export const chronicConditionsUpdateMutation = (options?: Partial<Options<ChronicConditionsUpdateData>>): UseMutationOptions<ChronicConditionsUpdateResponse, DefaultError, Options<ChronicConditionsUpdateData>> => {
    const mutationOptions: UseMutationOptions<ChronicConditionsUpdateResponse, DefaultError, Options<ChronicConditionsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Patients.chronicConditionsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paymentsListQueryKey = (options: Options<PaymentsListData>) => createQueryKey('paymentsList', options);

/**
 * List payments
 *
 * List payments
 */
export const paymentsListOptions = (options: Options<PaymentsListData>) => queryOptions<PaymentsListResponse, DefaultError, PaymentsListResponse, ReturnType<typeof paymentsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Billing.paymentsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: paymentsListQueryKey(options)
});

export const paymentsListInfiniteQueryKey = (options: Options<PaymentsListData>): QueryKey<Options<PaymentsListData>> => createQueryKey('paymentsList', options, true);

/**
 * List payments
 *
 * List payments
 */
export const paymentsListInfiniteOptions = (options: Options<PaymentsListData>) => infiniteQueryOptions<PaymentsListResponse, DefaultError, InfiniteData<PaymentsListResponse>, QueryKey<Options<PaymentsListData>>, number | Pick<QueryKey<Options<PaymentsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PaymentsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Billing.paymentsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: paymentsListInfiniteQueryKey(options)
});

/**
 * Create payment
 *
 * Create payment
 */
export const paymentsCreateMutation = (options?: Partial<Options<PaymentsCreateData>>): UseMutationOptions<PaymentsCreateResponse, DefaultError, Options<PaymentsCreateData>> => {
    const mutationOptions: UseMutationOptions<PaymentsCreateResponse, DefaultError, Options<PaymentsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.paymentsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const paymentsGetQueryKey = (options: Options<PaymentsGetData>) => createQueryKey('paymentsGet', options);

/**
 * Get payment
 *
 * Get payment
 */
export const paymentsGetOptions = (options: Options<PaymentsGetData>) => queryOptions<PaymentsGetResponse, DefaultError, PaymentsGetResponse, ReturnType<typeof paymentsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Billing.paymentsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: paymentsGetQueryKey(options)
});

/**
 * Cancel payment
 *
 * Cancel payment
 */
export const paymentsCancelMutation = (options?: Partial<Options<PaymentsCancelData>>): UseMutationOptions<PaymentsCancelResponse, DefaultError, Options<PaymentsCancelData>> => {
    const mutationOptions: UseMutationOptions<PaymentsCancelResponse, DefaultError, Options<PaymentsCancelData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.paymentsCancel({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Verify payment
 *
 * Verify payment
 */
export const paymentsVerifyMutation = (options?: Partial<Options<PaymentsVerifyData>>): UseMutationOptions<PaymentsVerifyResponse, DefaultError, Options<PaymentsVerifyData>> => {
    const mutationOptions: UseMutationOptions<PaymentsVerifyResponse, DefaultError, Options<PaymentsVerifyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.paymentsVerify({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const polyclinicsListQueryKey = (options: Options<PolyclinicsListData>) => createQueryKey('polyclinicsList', options);

/**
 * List polyclinics
 *
 * List polyclinics
 */
export const polyclinicsListOptions = (options: Options<PolyclinicsListData>) => queryOptions<PolyclinicsListResponse, DefaultError, PolyclinicsListResponse, ReturnType<typeof polyclinicsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Practitioners.polyclinicsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: polyclinicsListQueryKey(options)
});

export const polyclinicsListInfiniteQueryKey = (options: Options<PolyclinicsListData>): QueryKey<Options<PolyclinicsListData>> => createQueryKey('polyclinicsList', options, true);

/**
 * List polyclinics
 *
 * List polyclinics
 */
export const polyclinicsListInfiniteOptions = (options: Options<PolyclinicsListData>) => infiniteQueryOptions<PolyclinicsListResponse, DefaultError, InfiniteData<PolyclinicsListResponse>, QueryKey<Options<PolyclinicsListData>>, number | Pick<QueryKey<Options<PolyclinicsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PolyclinicsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Practitioners.polyclinicsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: polyclinicsListInfiniteQueryKey(options)
});

/**
 * Create polyclinic
 *
 * Create polyclinic
 */
export const polyclinicsCreateMutation = (options?: Partial<Options<PolyclinicsCreateData>>): UseMutationOptions<PolyclinicsCreateResponse, DefaultError, Options<PolyclinicsCreateData>> => {
    const mutationOptions: UseMutationOptions<PolyclinicsCreateResponse, DefaultError, Options<PolyclinicsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.polyclinicsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete polyclinic
 *
 * Delete polyclinic
 */
export const polyclinicsDeleteMutation = (options?: Partial<Options<PolyclinicsDeleteData>>): UseMutationOptions<PolyclinicsDeleteResponse, DefaultError, Options<PolyclinicsDeleteData>> => {
    const mutationOptions: UseMutationOptions<PolyclinicsDeleteResponse, DefaultError, Options<PolyclinicsDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.polyclinicsDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const polyclinicsGetQueryKey = (options: Options<PolyclinicsGetData>) => createQueryKey('polyclinicsGet', options);

/**
 * Get polyclinic
 *
 * Get polyclinic
 */
export const polyclinicsGetOptions = (options: Options<PolyclinicsGetData>) => queryOptions<PolyclinicsGetResponse, DefaultError, PolyclinicsGetResponse, ReturnType<typeof polyclinicsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Practitioners.polyclinicsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: polyclinicsGetQueryKey(options)
});

/**
 * Update polyclinic
 *
 * Update polyclinic
 */
export const polyclinicsUpdateMutation = (options?: Partial<Options<PolyclinicsUpdateData>>): UseMutationOptions<PolyclinicsUpdateResponse, DefaultError, Options<PolyclinicsUpdateData>> => {
    const mutationOptions: UseMutationOptions<PolyclinicsUpdateResponse, DefaultError, Options<PolyclinicsUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.polyclinicsUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const practitionerCredentialsListQueryKey = (options: Options<PractitionerCredentialsListData>) => createQueryKey('practitionerCredentialsList', options);

/**
 * List practitioner credentials
 *
 * List practitioner credentials
 */
export const practitionerCredentialsListOptions = (options: Options<PractitionerCredentialsListData>) => queryOptions<PractitionerCredentialsListResponse, DefaultError, PractitionerCredentialsListResponse, ReturnType<typeof practitionerCredentialsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.practitionerCredentialsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: practitionerCredentialsListQueryKey(options)
});

export const practitionerCredentialsListInfiniteQueryKey = (options: Options<PractitionerCredentialsListData>): QueryKey<Options<PractitionerCredentialsListData>> => createQueryKey('practitionerCredentialsList', options, true);

/**
 * List practitioner credentials
 *
 * List practitioner credentials
 */
export const practitionerCredentialsListInfiniteOptions = (options: Options<PractitionerCredentialsListData>) => infiniteQueryOptions<PractitionerCredentialsListResponse, DefaultError, InfiniteData<PractitionerCredentialsListResponse>, QueryKey<Options<PractitionerCredentialsListData>>, number | Pick<QueryKey<Options<PractitionerCredentialsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PractitionerCredentialsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Accreditation.practitionerCredentialsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: practitionerCredentialsListInfiniteQueryKey(options)
});

/**
 * Add practitioner credential
 *
 * Add credential
 */
export const practitionerCredentialsCreateMutation = (options?: Partial<Options<PractitionerCredentialsCreateData>>): UseMutationOptions<PractitionerCredentialsCreateResponse, DefaultError, Options<PractitionerCredentialsCreateData>> => {
    const mutationOptions: UseMutationOptions<PractitionerCredentialsCreateResponse, DefaultError, Options<PractitionerCredentialsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.practitionerCredentialsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const practitionerCredentialsGetQueryKey = (options: Options<PractitionerCredentialsGetData>) => createQueryKey('practitionerCredentialsGet', options);

/**
 * Get practitioner credential
 *
 * Get credential
 */
export const practitionerCredentialsGetOptions = (options: Options<PractitionerCredentialsGetData>) => queryOptions<PractitionerCredentialsGetResponse, DefaultError, PractitionerCredentialsGetResponse, ReturnType<typeof practitionerCredentialsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.practitionerCredentialsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: practitionerCredentialsGetQueryKey(options)
});

/**
 * Verify practitioner credential
 *
 * Verify credential
 */
export const practitionerCredentialsVerifyMutation = (options?: Partial<Options<PractitionerCredentialsVerifyData>>): UseMutationOptions<PractitionerCredentialsVerifyResponse, DefaultError, Options<PractitionerCredentialsVerifyData>> => {
    const mutationOptions: UseMutationOptions<PractitionerCredentialsVerifyResponse, DefaultError, Options<PractitionerCredentialsVerifyData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.practitionerCredentialsVerify({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const practitionersListQueryKey = (options: Options<PractitionersListData>) => createQueryKey('practitionersList', options);

/**
 * List practitioners
 *
 * List practitioners
 */
export const practitionersListOptions = (options: Options<PractitionersListData>) => queryOptions<PractitionersListResponse, DefaultError, PractitionersListResponse, ReturnType<typeof practitionersListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Practitioners.practitionersList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: practitionersListQueryKey(options)
});

export const practitionersListInfiniteQueryKey = (options: Options<PractitionersListData>): QueryKey<Options<PractitionersListData>> => createQueryKey('practitionersList', options, true);

/**
 * List practitioners
 *
 * List practitioners
 */
export const practitionersListInfiniteOptions = (options: Options<PractitionersListData>) => infiniteQueryOptions<PractitionersListResponse, DefaultError, InfiniteData<PractitionersListResponse>, QueryKey<Options<PractitionersListData>>, number | Pick<QueryKey<Options<PractitionersListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<PractitionersListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Practitioners.practitionersList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: practitionersListInfiniteQueryKey(options)
});

/**
 * Register practitioner
 *
 * Register a new practitioner
 */
export const practitionersCreateMutation = (options?: Partial<Options<PractitionersCreateData>>): UseMutationOptions<PractitionersCreateResponse, DefaultError, Options<PractitionersCreateData>> => {
    const mutationOptions: UseMutationOptions<PractitionersCreateResponse, DefaultError, Options<PractitionersCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.practitionersCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete practitioner
 *
 * Delete practitioner
 */
export const practitionersDeleteMutation = (options?: Partial<Options<PractitionersDeleteData>>): UseMutationOptions<PractitionersDeleteResponse, DefaultError, Options<PractitionersDeleteData>> => {
    const mutationOptions: UseMutationOptions<PractitionersDeleteResponse, DefaultError, Options<PractitionersDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.practitionersDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const practitionersGetQueryKey = (options: Options<PractitionersGetData>) => createQueryKey('practitionersGet', options);

/**
 * Get practitioner
 *
 * Get practitioner by ID
 */
export const practitionersGetOptions = (options: Options<PractitionersGetData>) => queryOptions<PractitionersGetResponse, DefaultError, PractitionersGetResponse, ReturnType<typeof practitionersGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Practitioners.practitionersGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: practitionersGetQueryKey(options)
});

/**
 * Update practitioner
 *
 * Update practitioner
 */
export const practitionersUpdateMutation = (options?: Partial<Options<PractitionersUpdateData>>): UseMutationOptions<PractitionersUpdateResponse, DefaultError, Options<PractitionersUpdateData>> => {
    const mutationOptions: UseMutationOptions<PractitionersUpdateResponse, DefaultError, Options<PractitionersUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.practitionersUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const practitionerSchedulesListQueryKey = (options: Options<PractitionerSchedulesListData>) => createQueryKey('practitionerSchedulesList', options);

/**
 * List practitioner schedules
 *
 * List practitioner schedules
 */
export const practitionerSchedulesListOptions = (options: Options<PractitionerSchedulesListData>) => queryOptions<PractitionerSchedulesListResponse, DefaultError, PractitionerSchedulesListResponse, ReturnType<typeof practitionerSchedulesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Practitioners.practitionerSchedulesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: practitionerSchedulesListQueryKey(options)
});

/**
 * Create schedule
 *
 * Create schedule
 */
export const practitionerSchedulesCreateMutation = (options?: Partial<Options<PractitionerSchedulesCreateData>>): UseMutationOptions<PractitionerSchedulesCreateResponse, DefaultError, Options<PractitionerSchedulesCreateData>> => {
    const mutationOptions: UseMutationOptions<PractitionerSchedulesCreateResponse, DefaultError, Options<PractitionerSchedulesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.practitionerSchedulesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete schedule
 *
 * Delete schedule
 */
export const practitionerSchedulesDeleteMutation = (options?: Partial<Options<PractitionerSchedulesDeleteData>>): UseMutationOptions<PractitionerSchedulesDeleteResponse, DefaultError, Options<PractitionerSchedulesDeleteData>> => {
    const mutationOptions: UseMutationOptions<PractitionerSchedulesDeleteResponse, DefaultError, Options<PractitionerSchedulesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.practitionerSchedulesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update schedule
 *
 * Update schedule
 */
export const practitionerSchedulesUpdateMutation = (options?: Partial<Options<PractitionerSchedulesUpdateData>>): UseMutationOptions<PractitionerSchedulesUpdateResponse, DefaultError, Options<PractitionerSchedulesUpdateData>> => {
    const mutationOptions: UseMutationOptions<PractitionerSchedulesUpdateResponse, DefaultError, Options<PractitionerSchedulesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.practitionerSchedulesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const qualityIndicatorsListQueryKey = (options: Options<QualityIndicatorsListData>) => createQueryKey('qualityIndicatorsList', options);

/**
 * List quality indicators
 *
 * List quality indicators
 */
export const qualityIndicatorsListOptions = (options: Options<QualityIndicatorsListData>) => queryOptions<QualityIndicatorsListResponse, DefaultError, QualityIndicatorsListResponse, ReturnType<typeof qualityIndicatorsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.qualityIndicatorsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: qualityIndicatorsListQueryKey(options)
});

export const qualityIndicatorsListInfiniteQueryKey = (options: Options<QualityIndicatorsListData>): QueryKey<Options<QualityIndicatorsListData>> => createQueryKey('qualityIndicatorsList', options, true);

/**
 * List quality indicators
 *
 * List quality indicators
 */
export const qualityIndicatorsListInfiniteOptions = (options: Options<QualityIndicatorsListData>) => infiniteQueryOptions<QualityIndicatorsListResponse, DefaultError, InfiniteData<QualityIndicatorsListResponse>, QueryKey<Options<QualityIndicatorsListData>>, number | Pick<QueryKey<Options<QualityIndicatorsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<QualityIndicatorsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Accreditation.qualityIndicatorsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: qualityIndicatorsListInfiniteQueryKey(options)
});

/**
 * Create quality indicator
 *
 * Create quality indicator
 */
export const qualityIndicatorsCreateMutation = (options?: Partial<Options<QualityIndicatorsCreateData>>): UseMutationOptions<QualityIndicatorsCreateResponse, DefaultError, Options<QualityIndicatorsCreateData>> => {
    const mutationOptions: UseMutationOptions<QualityIndicatorsCreateResponse, DefaultError, Options<QualityIndicatorsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.qualityIndicatorsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const qualityIndicatorsGetQueryKey = (options: Options<QualityIndicatorsGetData>) => createQueryKey('qualityIndicatorsGet', options);

/**
 * Get quality indicator
 *
 * Get quality indicator
 */
export const qualityIndicatorsGetOptions = (options: Options<QualityIndicatorsGetData>) => queryOptions<QualityIndicatorsGetResponse, DefaultError, QualityIndicatorsGetResponse, ReturnType<typeof qualityIndicatorsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.qualityIndicatorsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: qualityIndicatorsGetQueryKey(options)
});

export const qualityIndicatorsListResultsQueryKey = (options: Options<QualityIndicatorsListResultsData>) => createQueryKey('qualityIndicatorsListResults', options);

/**
 * List quality indicator results
 *
 * List quality indicator results
 */
export const qualityIndicatorsListResultsOptions = (options: Options<QualityIndicatorsListResultsData>) => queryOptions<QualityIndicatorsListResultsResponse, DefaultError, QualityIndicatorsListResultsResponse, ReturnType<typeof qualityIndicatorsListResultsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Accreditation.qualityIndicatorsListResults({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: qualityIndicatorsListResultsQueryKey(options)
});

/**
 * Record quality indicator result
 *
 * Record quality indicator result
 */
export const qualityIndicatorsRecordResultMutation = (options?: Partial<Options<QualityIndicatorsRecordResultData>>): UseMutationOptions<QualityIndicatorsRecordResultResponse, DefaultError, Options<QualityIndicatorsRecordResultData>> => {
    const mutationOptions: UseMutationOptions<QualityIndicatorsRecordResultResponse, DefaultError, Options<QualityIndicatorsRecordResultData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Accreditation.qualityIndicatorsRecordResult({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const queuesListQueryKey = (options: Options<QueuesListData>) => createQueryKey('queuesList', options);

/**
 * List queues
 *
 * List queues
 */
export const queuesListOptions = (options: Options<QueuesListData>) => queryOptions<QueuesListResponse, DefaultError, QueuesListResponse, ReturnType<typeof queuesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Appointments.queuesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: queuesListQueryKey(options)
});

export const queuesListInfiniteQueryKey = (options: Options<QueuesListData>): QueryKey<Options<QueuesListData>> => createQueryKey('queuesList', options, true);

/**
 * List queues
 *
 * List queues
 */
export const queuesListInfiniteOptions = (options: Options<QueuesListData>) => infiniteQueryOptions<QueuesListResponse, DefaultError, InfiniteData<QueuesListResponse>, QueryKey<Options<QueuesListData>>, number | Pick<QueryKey<Options<QueuesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<QueuesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Appointments.queuesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: queuesListInfiniteQueryKey(options)
});

/**
 * Add to queue
 *
 * Add to queue
 */
export const queuesCreateMutation = (options?: Partial<Options<QueuesCreateData>>): UseMutationOptions<QueuesCreateResponse, DefaultError, Options<QueuesCreateData>> => {
    const mutationOptions: UseMutationOptions<QueuesCreateResponse, DefaultError, Options<QueuesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.queuesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Call next in queue
 *
 * Call next in queue
 */
export const queuesCallNextMutation = (options?: Partial<Options<QueuesCallNextData>>): UseMutationOptions<QueuesCallNextResponse, DefaultError, Options<QueuesCallNextData>> => {
    const mutationOptions: UseMutationOptions<QueuesCallNextResponse, DefaultError, Options<QueuesCallNextData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.queuesCallNext({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const queuesGetDisplayQueryKey = (options: Options<QueuesGetDisplayData>) => createQueryKey('queuesGetDisplay', options);

/**
 * Get queue display
 *
 * Get current queue display
 */
export const queuesGetDisplayOptions = (options: Options<QueuesGetDisplayData>) => queryOptions<QueuesGetDisplayResponse, DefaultError, QueuesGetDisplayResponse, ReturnType<typeof queuesGetDisplayQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Appointments.queuesGetDisplay({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: queuesGetDisplayQueryKey(options)
});

export const queuesGetQueryKey = (options: Options<QueuesGetData>) => createQueryKey('queuesGet', options);

/**
 * Get queue
 *
 * Get queue by ID
 */
export const queuesGetOptions = (options: Options<QueuesGetData>) => queryOptions<QueuesGetResponse, DefaultError, QueuesGetResponse, ReturnType<typeof queuesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Appointments.queuesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: queuesGetQueryKey(options)
});

/**
 * Call queue
 *
 * Call specific queue
 */
export const queuesCallMutation = (options?: Partial<Options<QueuesCallData>>): UseMutationOptions<QueuesCallResponse, DefaultError, Options<QueuesCallData>> => {
    const mutationOptions: UseMutationOptions<QueuesCallResponse, DefaultError, Options<QueuesCallData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.queuesCall({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Complete queue
 *
 * Complete queue (patient served)
 */
export const queuesCompleteMutation = (options?: Partial<Options<QueuesCompleteData>>): UseMutationOptions<QueuesCompleteResponse, DefaultError, Options<QueuesCompleteData>> => {
    const mutationOptions: UseMutationOptions<QueuesCompleteResponse, DefaultError, Options<QueuesCompleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.queuesComplete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Skip queue
 *
 * Skip queue
 */
export const queuesSkipMutation = (options?: Partial<Options<QueuesSkipData>>): UseMutationOptions<QueuesSkipResponse, DefaultError, Options<QueuesSkipData>> => {
    const mutationOptions: UseMutationOptions<QueuesSkipResponse, DefaultError, Options<QueuesSkipData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Appointments.queuesSkip({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const refundsListQueryKey = (options: Options<RefundsListData>) => createQueryKey('refundsList', options);

/**
 * List refunds
 *
 * List refunds
 */
export const refundsListOptions = (options: Options<RefundsListData>) => queryOptions<RefundsListResponse, DefaultError, RefundsListResponse, ReturnType<typeof refundsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Billing.refundsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: refundsListQueryKey(options)
});

export const refundsListInfiniteQueryKey = (options: Options<RefundsListData>): QueryKey<Options<RefundsListData>> => createQueryKey('refundsList', options, true);

/**
 * List refunds
 *
 * List refunds
 */
export const refundsListInfiniteOptions = (options: Options<RefundsListData>) => infiniteQueryOptions<RefundsListResponse, DefaultError, InfiniteData<RefundsListResponse>, QueryKey<Options<RefundsListData>>, number | Pick<QueryKey<Options<RefundsListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<RefundsListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Billing.refundsList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: refundsListInfiniteQueryKey(options)
});

/**
 * Create refund request
 *
 * Create refund request
 */
export const refundsCreateMutation = (options?: Partial<Options<RefundsCreateData>>): UseMutationOptions<RefundsCreateResponse, DefaultError, Options<RefundsCreateData>> => {
    const mutationOptions: UseMutationOptions<RefundsCreateResponse, DefaultError, Options<RefundsCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.refundsCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const refundsGetQueryKey = (options: Options<RefundsGetData>) => createQueryKey('refundsGet', options);

/**
 * Get refund
 *
 * Get refund
 */
export const refundsGetOptions = (options: Options<RefundsGetData>) => queryOptions<RefundsGetResponse, DefaultError, RefundsGetResponse, ReturnType<typeof refundsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Billing.refundsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: refundsGetQueryKey(options)
});

/**
 * Approve refund
 *
 * Approve refund
 */
export const refundsApproveMutation = (options?: Partial<Options<RefundsApproveData>>): UseMutationOptions<RefundsApproveResponse, DefaultError, Options<RefundsApproveData>> => {
    const mutationOptions: UseMutationOptions<RefundsApproveResponse, DefaultError, Options<RefundsApproveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.refundsApprove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Process refund
 *
 * Process refund
 */
export const refundsProcessMutation = (options?: Partial<Options<RefundsProcessData>>): UseMutationOptions<RefundsProcessResponse, DefaultError, Options<RefundsProcessData>> => {
    const mutationOptions: UseMutationOptions<RefundsProcessResponse, DefaultError, Options<RefundsProcessData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.refundsProcess({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reject refund
 *
 * Reject refund
 */
export const refundsRejectMutation = (options?: Partial<Options<RefundsRejectData>>): UseMutationOptions<RefundsRejectResponse, DefaultError, Options<RefundsRejectData>> => {
    const mutationOptions: UseMutationOptions<RefundsRejectResponse, DefaultError, Options<RefundsRejectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Billing.refundsReject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tenantRolesListQueryKey = (options: Options<TenantRolesListData>) => createQueryKey('tenantRolesList', options);

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesListOptions = (options: Options<TenantRolesListData>) => queryOptions<TenantRolesListResponse, DefaultError, TenantRolesListResponse, ReturnType<typeof tenantRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Roles.tenantRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesListQueryKey(options)
});

export const tenantRolesListInfiniteQueryKey = (options: Options<TenantRolesListData>): QueryKey<Options<TenantRolesListData>> => createQueryKey('tenantRolesList', options, true);

/**
 * List tenant roles
 *
 * List all roles in a tenant
 *
 * Returns both system roles and custom roles for this tenant.
 */
export const tenantRolesListInfiniteOptions = (options: Options<TenantRolesListData>) => infiniteQueryOptions<TenantRolesListResponse, DefaultError, InfiniteData<TenantRolesListResponse>, QueryKey<Options<TenantRolesListData>>, number | Pick<QueryKey<Options<TenantRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<TenantRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Roles.tenantRolesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesListInfiniteQueryKey(options)
});

/**
 * Create tenant role
 *
 * Create a tenant-scoped role
 *
 * Creates a custom role for this specific tenant.
 */
export const tenantRolesCreateMutation = (options?: Partial<Options<TenantRolesCreateData>>): UseMutationOptions<TenantRolesCreateResponse, DefaultError, Options<TenantRolesCreateData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesCreateResponse, DefaultError, Options<TenantRolesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.tenantRolesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const tenantRolesDeleteMutation = (options?: Partial<Options<TenantRolesDeleteData>>): UseMutationOptions<TenantRolesDeleteResponse, DefaultError, Options<TenantRolesDeleteData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesDeleteResponse, DefaultError, Options<TenantRolesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.tenantRolesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const tenantRolesGetQueryKey = (options: Options<TenantRolesGetData>) => createQueryKey('tenantRolesGet', options);

/**
 * Get role
 *
 * Get a role by ID
 */
export const tenantRolesGetOptions = (options: Options<TenantRolesGetData>) => queryOptions<TenantRolesGetResponse, DefaultError, TenantRolesGetResponse, ReturnType<typeof tenantRolesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Roles.tenantRolesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: tenantRolesGetQueryKey(options)
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const tenantRolesUpdateMutation = (options?: Partial<Options<TenantRolesUpdateData>>): UseMutationOptions<TenantRolesUpdateResponse, DefaultError, Options<TenantRolesUpdateData>> => {
    const mutationOptions: UseMutationOptions<TenantRolesUpdateResponse, DefaultError, Options<TenantRolesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.tenantRolesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const appointmentSlotsListQueryKey = (options: Options<AppointmentSlotsListData>) => createQueryKey('appointmentSlotsList', options);

/**
 * List available slots
 *
 * List available slots
 */
export const appointmentSlotsListOptions = (options: Options<AppointmentSlotsListData>) => queryOptions<AppointmentSlotsListResponse, DefaultError, AppointmentSlotsListResponse, ReturnType<typeof appointmentSlotsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Practitioners.appointmentSlotsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: appointmentSlotsListQueryKey(options)
});

/**
 * Generate slots
 *
 * Generate slots for a schedule
 */
export const appointmentSlotsGenerateMutation = (options?: Partial<Options<AppointmentSlotsGenerateData>>): UseMutationOptions<AppointmentSlotsGenerateResponse, DefaultError, Options<AppointmentSlotsGenerateData>> => {
    const mutationOptions: UseMutationOptions<AppointmentSlotsGenerateResponse, DefaultError, Options<AppointmentSlotsGenerateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.appointmentSlotsGenerate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Block slot
 *
 * Block a slot
 */
export const appointmentSlotsBlockMutation = (options?: Partial<Options<AppointmentSlotsBlockData>>): UseMutationOptions<AppointmentSlotsBlockResponse, DefaultError, Options<AppointmentSlotsBlockData>> => {
    const mutationOptions: UseMutationOptions<AppointmentSlotsBlockResponse, DefaultError, Options<AppointmentSlotsBlockData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.appointmentSlotsBlock({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Unblock slot
 *
 * Unblock a slot
 */
export const appointmentSlotsUnblockMutation = (options?: Partial<Options<AppointmentSlotsUnblockData>>): UseMutationOptions<AppointmentSlotsUnblockResponse, DefaultError, Options<AppointmentSlotsUnblockData>> => {
    const mutationOptions: UseMutationOptions<AppointmentSlotsUnblockResponse, DefaultError, Options<AppointmentSlotsUnblockData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Practitioners.appointmentSlotsUnblock({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const specimensListQueryKey = (options: Options<SpecimensListData>) => createQueryKey('specimensList', options);

/**
 * List specimens
 *
 * List specimens
 */
export const specimensListOptions = (options: Options<SpecimensListData>) => queryOptions<SpecimensListResponse, DefaultError, SpecimensListResponse, ReturnType<typeof specimensListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.specimensList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: specimensListQueryKey(options)
});

export const specimensListInfiniteQueryKey = (options: Options<SpecimensListData>): QueryKey<Options<SpecimensListData>> => createQueryKey('specimensList', options, true);

/**
 * List specimens
 *
 * List specimens
 */
export const specimensListInfiniteOptions = (options: Options<SpecimensListData>) => infiniteQueryOptions<SpecimensListResponse, DefaultError, InfiniteData<SpecimensListResponse>, QueryKey<Options<SpecimensListData>>, number | Pick<QueryKey<Options<SpecimensListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<SpecimensListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Laboratory.specimensList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: specimensListInfiniteQueryKey(options)
});

/**
 * Collect specimen
 *
 * Collect specimen
 */
export const specimensCollectMutation = (options?: Partial<Options<SpecimensCollectData>>): UseMutationOptions<SpecimensCollectResponse, DefaultError, Options<SpecimensCollectData>> => {
    const mutationOptions: UseMutationOptions<SpecimensCollectResponse, DefaultError, Options<SpecimensCollectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.specimensCollect({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const specimensGetQueryKey = (options: Options<SpecimensGetData>) => createQueryKey('specimensGet', options);

/**
 * Get specimen
 *
 * Get specimen
 */
export const specimensGetOptions = (options: Options<SpecimensGetData>) => queryOptions<SpecimensGetResponse, DefaultError, SpecimensGetResponse, ReturnType<typeof specimensGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Laboratory.specimensGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: specimensGetQueryKey(options)
});

/**
 * Receive specimen
 *
 * Receive specimen at lab
 */
export const specimensReceiveMutation = (options?: Partial<Options<SpecimensReceiveData>>): UseMutationOptions<SpecimensReceiveResponse, DefaultError, Options<SpecimensReceiveData>> => {
    const mutationOptions: UseMutationOptions<SpecimensReceiveResponse, DefaultError, Options<SpecimensReceiveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.specimensReceive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reject specimen
 *
 * Reject specimen
 */
export const specimensRejectMutation = (options?: Partial<Options<SpecimensRejectData>>): UseMutationOptions<SpecimensRejectResponse, DefaultError, Options<SpecimensRejectData>> => {
    const mutationOptions: UseMutationOptions<SpecimensRejectResponse, DefaultError, Options<SpecimensRejectData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Laboratory.specimensReject({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const userPermissionsGetQueryKey = (options: Options<UserPermissionsGetData>) => createQueryKey('userPermissionsGet', options);

/**
 * Get user effective permissions
 *
 * Get user's effective permissions in this tenant
 *
 * Returns all roles (global + tenant) and the combined effective permissions
 * after applying deny-override resolution.
 */
export const userPermissionsGetOptions = (options: Options<UserPermissionsGetData>) => queryOptions<UserPermissionsGetResponse, DefaultError, UserPermissionsGetResponse, ReturnType<typeof userPermissionsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Roles.userPermissionsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userPermissionsGetQueryKey(options)
});

export const userTenantRolesListQueryKey = (options: Options<UserTenantRolesListData>) => createQueryKey('userTenantRolesList', options);

/**
 * List user roles in tenant
 *
 * List roles assigned to a user in this tenant
 *
 * Returns both global and tenant-specific role assignments.
 */
export const userTenantRolesListOptions = (options: Options<UserTenantRolesListData>) => queryOptions<UserTenantRolesListResponse, DefaultError, UserTenantRolesListResponse, ReturnType<typeof userTenantRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Roles.userTenantRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: userTenantRolesListQueryKey(options)
});

/**
 * Assign role to user
 *
 * Assign a role to a user in this tenant
 */
export const userTenantRolesAssignMutation = (options?: Partial<Options<UserTenantRolesAssignData>>): UseMutationOptions<UserTenantRolesAssignResponse, DefaultError, Options<UserTenantRolesAssignData>> => {
    const mutationOptions: UseMutationOptions<UserTenantRolesAssignResponse, DefaultError, Options<UserTenantRolesAssignData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.userTenantRolesAssign({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove role from user
 *
 * Remove a role from a user
 */
export const userTenantRolesRemoveMutation = (options?: Partial<Options<UserTenantRolesRemoveData>>): UseMutationOptions<UserTenantRolesRemoveResponse, DefaultError, Options<UserTenantRolesRemoveData>> => {
    const mutationOptions: UseMutationOptions<UserTenantRolesRemoveResponse, DefaultError, Options<UserTenantRolesRemoveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.userTenantRolesRemove({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListQueryKey = (options: Options<WebhooksListData>) => createQueryKey('webhooksList', options);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListOptions = (options: Options<WebhooksListData>) => queryOptions<WebhooksListResponse, DefaultError, WebhooksListResponse, ReturnType<typeof webhooksListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Webhooks.webhooksList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListQueryKey(options)
});

export const webhooksListInfiniteQueryKey = (options: Options<WebhooksListData>): QueryKey<Options<WebhooksListData>> => createQueryKey('webhooksList', options, true);

/**
 * List webhooks
 *
 * List all webhooks in an organization
 */
export const webhooksListInfiniteOptions = (options: Options<WebhooksListData>) => infiniteQueryOptions<WebhooksListResponse, DefaultError, InfiniteData<WebhooksListResponse>, QueryKey<Options<WebhooksListData>>, number | Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Webhooks.webhooksList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListInfiniteQueryKey(options)
});

/**
 * Create webhook
 *
 * Create a new webhook
 *
 * The secret is only returned once in the response.
 * Store it securely for signature verification.
 */
export const webhooksCreateMutation = (options?: Partial<Options<WebhooksCreateData>>): UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksCreateResponse, DefaultError, Options<WebhooksCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Webhooks.webhooksCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListEventTypesQueryKey = (options: Options<WebhooksListEventTypesData>) => createQueryKey('webhooksListEventTypes', options);

/**
 * List event types
 *
 * Get available event types
 *
 * Returns all event types that can be subscribed to.
 */
export const webhooksListEventTypesOptions = (options: Options<WebhooksListEventTypesData>) => queryOptions<WebhooksListEventTypesResponse, DefaultError, WebhooksListEventTypesResponse, ReturnType<typeof webhooksListEventTypesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Webhooks.webhooksListEventTypes({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListEventTypesQueryKey(options)
});

/**
 * Delete webhook
 *
 * Delete a webhook
 */
export const webhooksDeleteMutation = (options?: Partial<Options<WebhooksDeleteData>>): UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> => {
    const mutationOptions: UseMutationOptions<WebhooksDeleteResponse, DefaultError, Options<WebhooksDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Webhooks.webhooksDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksGetQueryKey = (options: Options<WebhooksGetData>) => createQueryKey('webhooksGet', options);

/**
 * Get webhook
 *
 * Get a webhook by ID
 */
export const webhooksGetOptions = (options: Options<WebhooksGetData>) => queryOptions<WebhooksGetResponse, DefaultError, WebhooksGetResponse, ReturnType<typeof webhooksGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Webhooks.webhooksGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetQueryKey(options)
});

/**
 * Update webhook
 *
 * Update a webhook
 */
export const webhooksUpdateMutation = (options?: Partial<Options<WebhooksUpdateData>>): UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> => {
    const mutationOptions: UseMutationOptions<WebhooksUpdateResponse, DefaultError, Options<WebhooksUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Webhooks.webhooksUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const webhooksListDeliveriesQueryKey = (options: Options<WebhooksListDeliveriesData>) => createQueryKey('webhooksListDeliveries', options);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesOptions = (options: Options<WebhooksListDeliveriesData>) => queryOptions<WebhooksListDeliveriesResponse, DefaultError, WebhooksListDeliveriesResponse, ReturnType<typeof webhooksListDeliveriesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Webhooks.webhooksListDeliveries({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesQueryKey(options)
});

export const webhooksListDeliveriesInfiniteQueryKey = (options: Options<WebhooksListDeliveriesData>): QueryKey<Options<WebhooksListDeliveriesData>> => createQueryKey('webhooksListDeliveries', options, true);

/**
 * List webhook deliveries
 *
 * List webhook deliveries
 *
 * View delivery history for debugging.
 */
export const webhooksListDeliveriesInfiniteOptions = (options: Options<WebhooksListDeliveriesData>) => infiniteQueryOptions<WebhooksListDeliveriesResponse, DefaultError, InfiniteData<WebhooksListDeliveriesResponse>, QueryKey<Options<WebhooksListDeliveriesData>>, number | Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<WebhooksListDeliveriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Webhooks.webhooksListDeliveries({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksListDeliveriesInfiniteQueryKey(options)
});

export const webhooksGetDeliveryQueryKey = (options: Options<WebhooksGetDeliveryData>) => createQueryKey('webhooksGetDelivery', options);

/**
 * Get webhook delivery
 *
 * Get a specific delivery
 */
export const webhooksGetDeliveryOptions = (options: Options<WebhooksGetDeliveryData>) => queryOptions<WebhooksGetDeliveryResponse, DefaultError, WebhooksGetDeliveryResponse, ReturnType<typeof webhooksGetDeliveryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Webhooks.webhooksGetDelivery({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: webhooksGetDeliveryQueryKey(options)
});

/**
 * Retry delivery
 *
 * Retry a failed delivery
 *
 * Manually triggers a retry for a failed delivery.
 */
export const webhooksRetryDeliveryMutation = (options?: Partial<Options<WebhooksRetryDeliveryData>>): UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRetryDeliveryResponse, DefaultError, Options<WebhooksRetryDeliveryData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Webhooks.webhooksRetryDelivery({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Rotate webhook secret
 *
 * Rotate webhook secret
 *
 * Generates a new secret. The old secret immediately stops working.
 */
export const webhooksRotateSecretMutation = (options?: Partial<Options<WebhooksRotateSecretData>>): UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> => {
    const mutationOptions: UseMutationOptions<WebhooksRotateSecretResponse, DefaultError, Options<WebhooksRotateSecretData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Webhooks.webhooksRotateSecret({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Test webhook
 *
 * Test a webhook
 *
 * Sends a test event to verify the webhook is configured correctly.
 */
export const webhooksTestMutation = (options?: Partial<Options<WebhooksTestData>>): UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> => {
    const mutationOptions: UseMutationOptions<WebhooksTestResponse, DefaultError, Options<WebhooksTestData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Webhooks.webhooksTest({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const notificationPreferencesRoutesGetPreferencesQueryKey = (options?: Options<NotificationPreferencesRoutesGetPreferencesData>) => createQueryKey('notificationPreferencesRoutesGetPreferences', options);

/**
 * Get notification preferences
 *
 * Get notification preferences for the current user
 * Returns default values if no preferences are set
 */
export const notificationPreferencesRoutesGetPreferencesOptions = (options?: Options<NotificationPreferencesRoutesGetPreferencesData>) => queryOptions<NotificationPreferencesRoutesGetPreferencesResponse, DefaultError, NotificationPreferencesRoutesGetPreferencesResponse, ReturnType<typeof notificationPreferencesRoutesGetPreferencesQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await NotificationPreferences.notificationPreferencesRoutesGetPreferences({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: notificationPreferencesRoutesGetPreferencesQueryKey(options)
});

/**
 * Update notification preferences
 *
 * Update notification preferences for the current user
 * Supports partial updates - only provided fields will be updated
 */
export const notificationPreferencesRoutesUpdatePreferencesMutation = (options?: Partial<Options<NotificationPreferencesRoutesUpdatePreferencesData>>): UseMutationOptions<NotificationPreferencesRoutesUpdatePreferencesResponse, DefaultError, Options<NotificationPreferencesRoutesUpdatePreferencesData>> => {
    const mutationOptions: UseMutationOptions<NotificationPreferencesRoutesUpdatePreferencesResponse, DefaultError, Options<NotificationPreferencesRoutesUpdatePreferencesData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await NotificationPreferences.notificationPreferencesRoutesUpdatePreferences({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const globalRolesListQueryKey = (options?: Options<GlobalRolesListData>) => createQueryKey('globalRolesList', options);

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesListOptions = (options?: Options<GlobalRolesListData>) => queryOptions<GlobalRolesListResponse, DefaultError, GlobalRolesListResponse, ReturnType<typeof globalRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Roles.globalRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesListQueryKey(options)
});

export const globalRolesListInfiniteQueryKey = (options?: Options<GlobalRolesListData>): QueryKey<Options<GlobalRolesListData>> => createQueryKey('globalRolesList', options, true);

/**
 * List global roles
 *
 * List all global roles
 *
 * Returns global roles (no tenant scope) for the default application.
 */
export const globalRolesListInfiniteOptions = (options?: Options<GlobalRolesListData>) => infiniteQueryOptions<GlobalRolesListResponse, DefaultError, InfiniteData<GlobalRolesListResponse>, QueryKey<Options<GlobalRolesListData>>, number | Pick<QueryKey<Options<GlobalRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<GlobalRolesListData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await Roles.globalRolesList({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesListInfiniteQueryKey(options)
});

/**
 * Create global role
 *
 * Create a global role
 *
 * Creates a role that applies across all tenants.
 */
export const globalRolesCreateMutation = (options?: Partial<Options<GlobalRolesCreateData>>): UseMutationOptions<GlobalRolesCreateResponse, DefaultError, Options<GlobalRolesCreateData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesCreateResponse, DefaultError, Options<GlobalRolesCreateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.globalRolesCreate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete role
 *
 * Delete a role
 *
 * System roles cannot be deleted.
 * Fails if role is assigned to any users.
 */
export const globalRolesDeleteMutation = (options?: Partial<Options<GlobalRolesDeleteData>>): UseMutationOptions<GlobalRolesDeleteResponse, DefaultError, Options<GlobalRolesDeleteData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesDeleteResponse, DefaultError, Options<GlobalRolesDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.globalRolesDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const globalRolesGetQueryKey = (options: Options<GlobalRolesGetData>) => createQueryKey('globalRolesGet', options);

/**
 * Get role
 *
 * Get a role by ID
 */
export const globalRolesGetOptions = (options: Options<GlobalRolesGetData>) => queryOptions<GlobalRolesGetResponse, DefaultError, GlobalRolesGetResponse, ReturnType<typeof globalRolesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Roles.globalRolesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: globalRolesGetQueryKey(options)
});

/**
 * Update role
 *
 * Update a role
 *
 * System roles cannot be renamed but their permissions can be modified.
 */
export const globalRolesUpdateMutation = (options?: Partial<Options<GlobalRolesUpdateData>>): UseMutationOptions<GlobalRolesUpdateResponse, DefaultError, Options<GlobalRolesUpdateData>> => {
    const mutationOptions: UseMutationOptions<GlobalRolesUpdateResponse, DefaultError, Options<GlobalRolesUpdateData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Roles.globalRolesUpdate({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const availableContextsListQueryKey = (options?: Options<AvailableContextsListData>) => createQueryKey('availableContextsList', options);

/**
 * List available contexts
 *
 * List all available contexts for the current user
 *
 * Returns all applications and tenants the user has access to.
 */
export const availableContextsListOptions = (options?: Options<AvailableContextsListData>) => queryOptions<AvailableContextsListResponse, DefaultError, AvailableContextsListResponse, ReturnType<typeof availableContextsListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Context.availableContextsList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: availableContextsListQueryKey(options)
});

export const currentUserContextGetQueryKey = (options?: Options<CurrentUserContextGetData>) => createQueryKey('currentUserContextGet', options);

/**
 * Get active context
 *
 * Get current user's active context
 *
 * Returns the currently active application and tenant for the user.
 * This is for UI state management, not authorization decisions.
 */
export const currentUserContextGetOptions = (options?: Options<CurrentUserContextGetData>) => queryOptions<CurrentUserContextGetResponse, DefaultError, CurrentUserContextGetResponse, ReturnType<typeof currentUserContextGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Context.currentUserContextGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: currentUserContextGetQueryKey(options)
});

/**
 * Switch context
 *
 * Switch user's active context
 *
 * Changes the active application and/or tenant.
 * This is for UI state management, not authorization decisions.
 */
export const contextSwitchSwitchMutation = (options?: Partial<Options<ContextSwitchSwitchData>>): UseMutationOptions<ContextSwitchSwitchResponse, DefaultError, Options<ContextSwitchSwitchData>> => {
    const mutationOptions: UseMutationOptions<ContextSwitchSwitchResponse, DefaultError, Options<ContextSwitchSwitchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await Context.contextSwitchSwitch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const allUserRolesListQueryKey = (options: Options<AllUserRolesListData>) => createQueryKey('allUserRolesList', options);

/**
 * List all user roles
 *
 * List user's roles across all applications and tenants
 *
 * Returns all role assignments for the user across all contexts.
 */
export const allUserRolesListOptions = (options: Options<AllUserRolesListData>) => queryOptions<AllUserRolesListResponse, DefaultError, AllUserRolesListResponse, ReturnType<typeof allUserRolesListQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await Roles.allUserRolesList({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: allUserRolesListQueryKey(options)
});
