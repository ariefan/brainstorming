// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'https://api.example.com' | 'http://localhost:3001' | (string & {});
};

/**
 * Accreditation body
 */
export type AccreditationBody = 'snars' | 'kars' | 'kemenkesKlinik' | 'kemenkesPuskesmas';

/**
 * Accreditation level
 */
export type AccreditationLevel = 'notAccredited' | 'basic' | 'intermediate' | 'advanced' | 'excellent';

/**
 * Accreditation Standard
 *
 * Tracks accreditation status for organization/branch
 */
export type AccreditationStandard = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Accreditation body
     */
    accreditationBody: AccreditationBody;
    /**
     * Current level
     */
    currentLevel: AccreditationLevel;
    /**
     * Target level
     */
    targetLevel?: AccreditationLevel;
    /**
     * Status
     */
    status: AccreditationStatus;
    /**
     * Last accredited date
     */
    lastAccreditedAt?: string;
    /**
     * Expiry date
     */
    expiresAt?: string;
    /**
     * Next survey date
     */
    nextSurveyDate?: string;
    /**
     * Self-assessment score
     */
    selfAssessmentScore?: number;
    /**
     * Survey score
     */
    surveyScore?: number;
    /**
     * Surveyor organization
     */
    surveyorOrganization?: string;
    /**
     * Surveyor team
     */
    surveyorTeam?: Array<{
        name: string;
        role: string;
        specialty?: string;
    }>;
    /**
     * Certificate number
     */
    certificateNumber?: string;
    /**
     * Certificate URL
     */
    certificateUrl?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Accreditation standard list response
 */
export type AccreditationStandardListResponse = {
    /**
     * Array of resources
     */
    data: Array<AccreditationStandard>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single accreditation standard response
 */
export type AccreditationStandardResponse = {
    /**
     * The resource data
     */
    data: AccreditationStandard;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Accreditation status
 */
export type AccreditationStatus = 'notStarted' | 'preparing' | 'selfAssessment' | 'submitted' | 'surveyed' | 'accredited' | 'lapsed';

/**
 * User's active context (current app/tenant selection)
 */
export type ActiveContext = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Currently active application ID
     */
    activeApplicationId: string;
    /**
     * Currently active tenant ID (null if no tenant selected)
     */
    activeTenantId?: string;
    /**
     * When the context was last updated
     */
    updatedAt: string;
};

/**
 * Active context response
 */
export type ActiveContextResponse = {
    data: ActiveContext;
    meta: ResponseMeta;
};

/**
 * Allergy severity
 */
export type AllergySeverity = 'mild' | 'moderate' | 'severe' | 'lifeThreatening';

/**
 * Allergy type
 */
export type AllergyType = 'food' | 'medication' | 'environmental' | 'other';

/**
 * Appointment resource
 *
 * Represents a scheduled patient visit
 */
export type Appointment = {
    /**
     * Unique appointment identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Appointment number
     */
    appointmentNumber: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Appointment slot ID (if booked via slot)
     */
    appointmentSlotId?: string;
    /**
     * Appointment type
     */
    appointmentType: AppointmentType;
    /**
     * Appointment status
     */
    status: AppointmentStatus;
    /**
     * Appointment date
     */
    appointmentDate: string;
    /**
     * Start time (HH:mm)
     */
    startTime: string;
    /**
     * End time (HH:mm)
     */
    endTime?: string;
    /**
     * Duration (in minutes)
     */
    duration?: string;
    /**
     * Priority
     */
    priority: QueuePriority;
    /**
     * Reason for visit
     */
    reasonForVisit?: string;
    /**
     * Symptoms description
     */
    symptoms?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Whether this is a walk-in
     */
    isWalkIn: boolean;
    /**
     * Whether this is an online booking
     */
    isOnline: boolean;
    /**
     * Whether this is a video call
     */
    isVideoCall: boolean;
    /**
     * Whether this is a follow-up appointment
     */
    isFollowUp: boolean;
    /**
     * Previous appointment ID (for follow-ups)
     */
    previousAppointmentId?: string;
    /**
     * BPJS booking code
     */
    bpjsAntreanKodeBooking?: string;
    /**
     * JKN sync status
     */
    isJknSynced: boolean;
    /**
     * When synced to JKN
     */
    jknSyncedAt?: string;
    /**
     * JKN sync error message
     */
    jknSyncError?: string;
    /**
     * Check-in time
     */
    checkedInAt?: string;
    /**
     * Who performed check-in
     */
    checkedInBy?: string;
    /**
     * When appointment started
     */
    startedAt?: string;
    /**
     * Completion time
     */
    completedAt?: string;
    /**
     * When marked as no-show
     */
    noShowAt?: string;
    /**
     * Cancellation reason
     */
    cancellationReason?: string;
    /**
     * Who cancelled
     */
    cancelledBy?: string;
    /**
     * When cancelled
     */
    cancelledAt?: string;
    /**
     * Soft delete status
     */
    isDeleted: boolean;
    /**
     * When deleted
     */
    deletedAt?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Appointment list response
 */
export type AppointmentListResponse = {
    /**
     * Array of resources
     */
    data: Array<Appointment>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Appointment reminder
 */
export type AppointmentReminder = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Appointment ID
     */
    appointmentId: string;
    /**
     * Reminder type
     */
    reminderType: 'sms' | 'email' | 'push' | 'whatsapp';
    /**
     * Scheduled send time
     */
    scheduledAt: string;
    /**
     * Actual send time
     */
    sentAt?: string;
    /**
     * Whether reminder was sent successfully
     */
    isSent: boolean;
    /**
     * Error message if failed
     */
    errorMessage?: string;
    /**
     * When created
     */
    createdAt: string;
};

/**
 * Single appointment response
 */
export type AppointmentResponse = {
    /**
     * The resource data
     */
    data: Appointment;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Appointment slot (time slot for booking)
 */
export type AppointmentSlot = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Slot date
     */
    slotDate: string;
    /**
     * Start time (HH:mm)
     */
    startTime: string;
    /**
     * End time (HH:mm)
     */
    endTime: string;
    /**
     * Duration in minutes
     */
    duration: string;
    /**
     * Whether slot is available
     */
    isAvailable: boolean;
    /**
     * Whether slot is booked
     */
    isBooked: boolean;
    /**
     * Who booked (user ID)
     */
    bookedBy?: string;
    /**
     * When booked
     */
    bookedAt?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Slot list response
 */
export type AppointmentSlotListResponse = {
    /**
     * Array of resources
     */
    data: Array<AppointmentSlot>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single slot response
 */
export type AppointmentSlotResponse = {
    /**
     * The resource data
     */
    data: AppointmentSlot;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Appointment status
 */
export type AppointmentStatus = 'booked' | 'confirmed' | 'checkedIn' | 'inQueue' | 'completed' | 'cancelled' | 'noShow';

/**
 * Appointment type
 */
export type AppointmentType = 'consultation' | 'followUp' | 'procedure' | 'lab' | 'imaging' | 'vaccination' | 'checkup';

/**
 * Appointment with related data
 */
export type AppointmentWithRelationsResponse = {
    data: {
        /**
         * Unique appointment identifier
         */
        id: string;
        /**
         * Organization ID (tenant scope)
         */
        organizationId: string;
        /**
         * Branch ID
         */
        branchId?: string;
        /**
         * Appointment number
         */
        appointmentNumber: string;
        /**
         * Patient ID
         */
        patientId: string;
        /**
         * Practitioner ID
         */
        practitionerId: string;
        /**
         * Polyclinic ID
         */
        polyclinicId: string;
        /**
         * Appointment slot ID (if booked via slot)
         */
        appointmentSlotId?: string;
        /**
         * Appointment type
         */
        appointmentType: AppointmentType;
        /**
         * Appointment status
         */
        status: AppointmentStatus;
        /**
         * Appointment date
         */
        appointmentDate: string;
        /**
         * Start time (HH:mm)
         */
        startTime: string;
        /**
         * End time (HH:mm)
         */
        endTime?: string;
        /**
         * Duration (in minutes)
         */
        duration?: string;
        /**
         * Priority
         */
        priority: QueuePriority;
        /**
         * Reason for visit
         */
        reasonForVisit?: string;
        /**
         * Symptoms description
         */
        symptoms?: string;
        /**
         * Notes
         */
        notes?: string;
        /**
         * Whether this is a walk-in
         */
        isWalkIn: boolean;
        /**
         * Whether this is an online booking
         */
        isOnline: boolean;
        /**
         * Whether this is a video call
         */
        isVideoCall: boolean;
        /**
         * Whether this is a follow-up appointment
         */
        isFollowUp: boolean;
        /**
         * Previous appointment ID (for follow-ups)
         */
        previousAppointmentId?: string;
        /**
         * BPJS booking code
         */
        bpjsAntreanKodeBooking?: string;
        /**
         * JKN sync status
         */
        isJknSynced: boolean;
        /**
         * When synced to JKN
         */
        jknSyncedAt?: string;
        /**
         * JKN sync error message
         */
        jknSyncError?: string;
        /**
         * Check-in time
         */
        checkedInAt?: string;
        /**
         * Who performed check-in
         */
        checkedInBy?: string;
        /**
         * When appointment started
         */
        startedAt?: string;
        /**
         * Completion time
         */
        completedAt?: string;
        /**
         * When marked as no-show
         */
        noShowAt?: string;
        /**
         * Cancellation reason
         */
        cancellationReason?: string;
        /**
         * Who cancelled
         */
        cancelledBy?: string;
        /**
         * When cancelled
         */
        cancelledAt?: string;
        /**
         * Soft delete status
         */
        isDeleted: boolean;
        /**
         * When deleted
         */
        deletedAt?: string;
        /**
         * When created
         */
        createdAt: string;
        /**
         * When updated
         */
        updatedAt: string;
        patient?: {
            id: string;
            fullName: string;
            medicalRecordNumber: string;
        };
        practitioner?: {
            id: string;
            fullName: string;
            specialty?: Specialty;
        };
        polyclinic?: {
            id: string;
            polyclinicName: string;
        };
        queue?: Queue;
    };
    meta: ResponseMeta;
};

/**
 * Request body for approving refund
 */
export type ApproveRefundRequest = {
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request to assign a role to a user
 */
export type AssignRoleRequest = {
    /**
     * Role ID to assign
     */
    roleId: string;
};

/**
 * Response for async operations that return 202 Accepted
 */
export type AsyncJobResponse = {
    /**
     * Unique job identifier
     */
    jobId: string;
    /**
     * Current job status
     */
    status: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * URL to check job status
     */
    statusUrl: string;
    /**
     * Estimated completion time
     */
    estimatedCompletion?: string;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Actor who performed the action
 */
export type AuditActor = {
    /**
     * Type of actor
     */
    type: AuditActorType;
    /**
     * Actor ID (user ID, service account ID, or "system")
     */
    id: string;
    /**
     * Actor email (for users)
     */
    email?: string;
    /**
     * IP address of the actor
     */
    ipAddress?: string;
    /**
     * User agent string
     */
    userAgent?: string;
};

/**
 * Actor type - who performed the action
 */
export type AuditActorType = 'user' | 'service' | 'system';

/**
 * Change record for a single field
 */
export type AuditChange = {
    /**
     * Value before the change
     */
    old: unknown;
    /**
     * Value after the change
     */
    new: unknown;
};

/**
 * Audit log entry
 *
 * Immutable record of an action in the system.
 */
export type AuditLog = {
    /**
     * Unique event identifier (format: evt_abc123)
     */
    eventId: string;
    /**
     * Event type (format: resource.action)
     */
    eventType: string;
    /**
     * When the event occurred
     */
    timestamp: string;
    /**
     * Tenant where the event occurred
     */
    tenantId: string;
    /**
     * Who performed the action
     */
    actor: AuditActor;
    /**
     * What resource was affected
     */
    resource: AuditResource;
    /**
     * Changes made (for update operations)
     */
    changes?: {
        [key: string]: AuditChange;
    };
    /**
     * Full resource state before the action (for deletes, sensitive ops)
     */
    resourceBefore?: {
        [key: string]: unknown;
    };
    /**
     * Full resource state after the action (for creates, sensitive ops)
     */
    resourceAfter?: {
        [key: string]: unknown;
    };
    /**
     * Additional context
     */
    metadata?: AuditMetadata;
};

/**
 * Audit log list response
 */
export type AuditLogListResponse = {
    data: Array<AuditLog>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single audit log response
 */
export type AuditLogResponse = {
    data: AuditLog;
    meta: ResponseMeta;
};

/**
 * Additional metadata for the audit event
 */
export type AuditMetadata = {
    /**
     * Request ID for correlation
     */
    requestId?: string;
    /**
     * Session ID
     */
    sessionId?: string;
    /**
     * Reason for the action (if provided)
     */
    reason?: string;
    /**
     * Additional context-specific data
     */
    extra?: {
        [key: string]: unknown;
    };
};

/**
 * Resource affected by the action
 */
export type AuditResource = {
    /**
     * Resource type
     */
    type: string;
    /**
     * Resource ID
     */
    id: string;
    /**
     * API endpoint that was called
     */
    endpoint?: string;
    /**
     * HTTP method used
     */
    method?: string;
};

/**
 * Batch delete response envelope
 */
export type BatchDeleteResponse = {
    /**
     * Results for each item in the batch
     */
    results: Array<BatchDeleteResult>;
    /**
     * Summary of operation results
     */
    summary: BatchSummary;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Batch delete result (soft delete)
 */
export type BatchDeleteResult = {
    /**
     * Index of the item in the original request array
     */
    index: number;
    /**
     * Status of the operation for this item
     */
    status: 'success' | 'error' | 'skipped';
    /**
     * Deleted item info (present if status is success)
     */
    data?: {
        /**
         * ID of the deleted item
         */
        id: string;
        /**
         * Timestamp when the item was deleted
         */
        deletedAt: string;
    };
    /**
     * Error details (present if status is error)
     */
    error?: {
        /**
         * Error code
         */
        code: string;
        /**
         * Error message
         */
        message: string;
    };
};

/**
 * Options for batch operations
 */
export type BatchOptions = {
    /**
     * If true, all items succeed or all fail (transactional)
     */
    atomic?: boolean;
    /**
     * If true, return created/updated records in response
     */
    returnRecords?: boolean;
    /**
     * If true, skip items that already exist (duplicates)
     */
    skipDuplicates?: boolean;
    /**
     * If true, validate without actually creating/updating
     */
    validateOnly?: boolean;
};

/**
 * Summary of batch operation results
 */
export type BatchSummary = {
    /**
     * Total number of items in the request
     */
    total: number;
    /**
     * Number of successfully processed items
     */
    successful: number;
    /**
     * Number of failed items
     */
    failed: number;
    /**
     * Number of skipped items (e.g., duplicates)
     */
    skipped: number;
};

/**
 * Billable item type
 */
export type BillableItemType = 'consultation' | 'procedure' | 'medication' | 'labTest' | 'radiology' | 'room' | 'supply' | 'other';

/**
 * Billing Summary
 *
 * Summary of billing for a patient or period
 */
export type BillingSummary = {
    /**
     * Total invoices
     */
    totalInvoices: number;
    /**
     * Total invoiced amount
     */
    totalInvoicedAmount: number;
    /**
     * Total paid amount
     */
    totalPaidAmount: number;
    /**
     * Total outstanding
     */
    totalOutstanding: number;
    /**
     * Total overdue
     */
    totalOverdue: number;
    /**
     * By payment type
     */
    byPaymentType: Array<{
        /**
         * Payment type
         */
        paymentType: PaymentType;
        /**
         * Count
         */
        count: number;
        /**
         * Amount
         */
        amount: number;
    }>;
    /**
     * By status
     */
    byStatus: Array<{
        /**
         * Status
         */
        status: InvoiceStatus;
        /**
         * Count
         */
        count: number;
        /**
         * Amount
         */
        amount: number;
    }>;
};

/**
 * Billing summary response
 */
export type BillingSummaryResponse = {
    /**
     * The resource data
     */
    data: BillingSummary;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Request body for blocking a slot
 */
export type BlockSlotRequest = {
    /**
     * Reason for blocking
     */
    reason?: string;
};

/**
 * Blood type
 */
export type BloodType = 'a' | 'b' | 'ab' | 'o';

/**
 * BPJS facility type
 */
export type BpjsFacilityType = 'fktp' | 'fkrtl';

/**
 * Branch (sub-location) resource
 *
 * Represents a branch/location within an organization
 */
export type Branch = {
    /**
     * Unique branch identifier
     */
    id: string;
    /**
     * Parent organization ID
     */
    organizationId: string;
    /**
     * Branch code
     */
    branchCode: string;
    /**
     * Branch name
     */
    branchName: string;
    /**
     * Branch name in Indonesian
     */
    branchNameId?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Whether branch is active
     */
    isActive: boolean;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When last updated
     */
    updatedAt: string;
};

/**
 * Branch list response with pagination
 */
export type BranchListResponse = {
    /**
     * Array of resources
     */
    data: Array<Branch>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single branch response
 */
export type BranchResponse = {
    /**
     * The resource data
     */
    data: Branch;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Request body for calling next queue
 */
export type CallNextQueueRequest = {
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Counter number
     */
    counterNumber?: string;
};

/**
 * Request body for calling queue
 */
export type CallQueueRequest = {
    /**
     * Counter number
     */
    counterNumber?: string;
};

/**
 * Request body for cancelling
 */
export type CancelAppointmentRequest = {
    /**
     * Cancellation reason
     */
    cancellationReason: string;
};

/**
 * Request body for checking in
 */
export type CheckInAppointmentRequest = {
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for checking in (alias)
 */
export type CheckInRequest = {
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Chronic condition record
 */
export type ChronicCondition = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * ICD-10 code
     */
    icd10Code: string;
    /**
     * Condition name
     */
    conditionName: string;
    /**
     * Condition name in Indonesian
     */
    conditionNameId?: string;
    /**
     * Diagnosis date
     */
    diagnosisDate?: string;
    /**
     * Whether condition is currently active
     */
    isActive: boolean;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Chronic condition list response
 */
export type ChronicConditionListResponse = {
    /**
     * Array of resources
     */
    data: Array<ChronicCondition>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single chronic condition response
 */
export type ChronicConditionResponse = {
    /**
     * The resource data
     */
    data: ChronicCondition;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Clinical Audit
 *
 * Clinical audit tracking
 */
export type ClinicalAudit = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Audit number
     */
    auditNumber: string;
    /**
     * Audit type
     */
    auditType: ClinicalAuditType;
    /**
     * Audit title
     */
    auditTitle: string;
    /**
     * Audit title in Indonesian
     */
    auditTitleId?: string;
    /**
     * Department
     */
    department?: string;
    /**
     * Audit period start
     */
    auditPeriodStart: string;
    /**
     * Audit period end
     */
    auditPeriodEnd: string;
    /**
     * Sample size
     */
    sampleSize?: number;
    /**
     * Population
     */
    population?: number;
    /**
     * Audit criteria
     */
    auditCriteria?: Array<{
        criterion: string;
        standard: string;
        weight?: number;
    }>;
    /**
     * Status
     */
    status: ClinicalAuditStatus;
    /**
     * Planned start date
     */
    plannedStartDate?: string;
    /**
     * Actual start date
     */
    actualStartDate?: string;
    /**
     * Completed date
     */
    completedDate?: string;
    /**
     * Lead auditor user ID
     */
    leadAuditor: string;
    /**
     * Audit team
     */
    auditTeam?: Array<{
        userId?: string;
        name: string;
        role: string;
    }>;
    /**
     * Findings
     */
    findings?: Array<{
        criterion: string;
        finding: string;
        complianceRate?: number;
        severity?: string;
        recommendation?: string;
    }>;
    /**
     * Overall compliance rate
     */
    overallComplianceRate?: number;
    /**
     * Summary
     */
    summary?: string;
    /**
     * Conclusions
     */
    conclusions?: string;
    /**
     * Recommendations
     */
    recommendations?: string;
    /**
     * Follow-up actions
     */
    followUpActions?: Array<{
        action: string;
        responsible: string;
        dueDate: string;
        status: string;
        completedDate?: string;
    }>;
    /**
     * Follow-up date
     */
    followUpDate?: string;
    /**
     * Follow-up completed at
     */
    followUpCompletedAt?: string;
    /**
     * Approved by user ID
     */
    approvedBy?: string;
    /**
     * Approved at
     */
    approvedAt?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Clinical audit list response
 */
export type ClinicalAuditListResponse = {
    /**
     * Array of resources
     */
    data: Array<ClinicalAudit>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single clinical audit response
 */
export type ClinicalAuditResponse = {
    /**
     * The resource data
     */
    data: ClinicalAudit;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Clinical audit status
 */
export type ClinicalAuditStatus = 'planned' | 'inProgress' | 'dataCollection' | 'analysis' | 'reportDraft' | 'completed' | 'followUp';

/**
 * Clinical audit type
 */
export type ClinicalAuditType = 'processAudit' | 'outcomeAudit' | 'structureAudit' | 'topicAudit' | 'medicalRecordAudit';

/**
 * Request body for collecting specimen
 */
export type CollectSpecimenRequest = {
    /**
     * Order item ID
     */
    orderItemId: string;
    /**
     * Specimen type
     */
    specimenType: string;
    /**
     * Specimen condition
     */
    condition?: SpecimenCondition;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request to confirm an upload completed successfully
 */
export type ConfirmUploadRequest = {
    /**
     * Optional: ETag from S3 response for verification
     */
    etag?: string;
};

/**
 * Request body for creating accreditation standard
 */
export type CreateAccreditationStandardRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Accreditation body
     */
    accreditationBody: AccreditationBody;
    /**
     * Target level
     */
    targetLevel?: AccreditationLevel;
    /**
     * Next survey date
     */
    nextSurveyDate?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating an appointment
 */
export type CreateAppointmentRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Appointment slot ID
     */
    appointmentSlotId?: string;
    /**
     * Appointment type
     */
    appointmentType: AppointmentType;
    /**
     * Appointment date
     */
    appointmentDate: string;
    /**
     * Start time (HH:mm)
     */
    startTime: string;
    /**
     * End time (HH:mm)
     */
    endTime?: string;
    /**
     * Reason for visit
     */
    reasonForVisit?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Is walk-in
     */
    isWalkIn?: boolean;
    /**
     * Previous appointment ID (for follow-ups)
     */
    previousAppointmentId?: string;
};

/**
 * Request body for creating a branch
 */
export type CreateBranchRequest = {
    /**
     * Branch code
     */
    branchCode: string;
    /**
     * Branch name
     */
    branchName: string;
    /**
     * Indonesian name
     */
    branchNameId?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Email
     */
    email?: string;
};

/**
 * Request body for creating a chronic condition
 */
export type CreateChronicConditionRequest = {
    /**
     * ICD-10 code
     */
    icd10Code: string;
    /**
     * Condition name
     */
    conditionName: string;
    /**
     * Condition name in Indonesian
     */
    conditionNameId?: string;
    /**
     * Diagnosis date
     */
    diagnosisDate?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating a diagnosis
 */
export type CreateDiagnosisRequest = {
    /**
     * ICD-10 code
     */
    icd10Code: string;
    /**
     * ICD-10 description
     */
    icd10Description?: string;
    /**
     * Diagnosis name
     */
    diagnosisName: string;
    /**
     * Diagnosis name in Indonesian
     */
    diagnosisNameId?: string;
    /**
     * Diagnosis type
     */
    diagnosisType: DiagnosisType;
    /**
     * Verification status
     */
    verificationStatus?: DiagnosisVerification;
    /**
     * Is chronic
     */
    isChronic?: boolean;
    /**
     * Onset date
     */
    onsetDate?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating diagnostic report
 */
export type CreateDiagnosticReportRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Order ID
     */
    orderId?: string;
    /**
     * Conclusion
     */
    conclusion?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating document control
 */
export type CreateDocumentControlRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Document number
     */
    documentNumber: string;
    /**
     * Document type
     */
    documentType: DocumentControlType;
    /**
     * Document title
     */
    documentTitle: string;
    /**
     * Document title in Indonesian
     */
    documentTitleId?: string;
    /**
     * Department
     */
    department?: string;
    /**
     * Category
     */
    category?: string;
    /**
     * Purpose
     */
    purpose?: string;
    /**
     * Scope
     */
    scope?: string;
    /**
     * Content
     */
    content?: string;
};

/**
 * Request body for creating an encounter
 */
export type CreateEncounterRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Appointment ID
     */
    appointmentId?: string;
    /**
     * Encounter type
     */
    encounterType: EncounterType;
    /**
     * Encounter class
     */
    encounterClass: EncounterClass;
    /**
     * Chief complaint
     */
    chiefComplaint?: string;
    /**
     * Reason for visit
     */
    reasonForVisit?: string;
    /**
     * BPJS SEP number
     */
    bpjsSepNumber?: string;
};

/**
 * Request body for creating a new comment
 */
export type CreateExampleCommentRequest = {
    /**
     * Comment content
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
};

/**
 * Request body for creating a new post
 */
export type CreateExamplePostRequest = {
    /**
     * Post title
     */
    title: string;
    /**
     * Post content (supports markdown)
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Post status (default: draft)
     */
    status?: ExamplePostStatus;
};

/**
 * Request body for creating invoice item
 */
export type CreateInvoiceItemRequest = {
    /**
     * Item type
     */
    itemType: BillableItemType;
    /**
     * Item code
     */
    itemCode: string;
    /**
     * Item name
     */
    itemName: string;
    /**
     * Quantity
     */
    quantity: number;
    /**
     * Unit
     */
    unit: string;
    /**
     * Unit price
     */
    unitPrice: number;
    /**
     * Discount amount
     */
    discountAmount?: number;
    /**
     * Reference ID
     */
    referenceId?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating invoice
 */
export type CreateInvoiceRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Encounter ID
     */
    encounterId?: string;
    /**
     * Payment type
     */
    paymentType: PaymentType;
    /**
     * Payer type
     */
    payerType: PayerType;
    /**
     * BPJS number (if JKN)
     */
    bpjsNumber?: string;
    /**
     * Insurance company
     */
    insuranceCompany?: string;
    /**
     * Insurance policy number
     */
    insurancePolicyNumber?: string;
    /**
     * Due date
     */
    dueDate?: string;
    /**
     * Discount percent
     */
    discountPercent?: number;
    /**
     * Discount reason
     */
    discountReason?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Invoice items
     */
    items: Array<CreateInvoiceItemRequest>;
};

/**
 * Request body for creating JKN config
 */
export type CreateJknConfigRequest = {
    /**
     * Branch ID (optional)
     */
    branchId?: string;
    /**
     * API type
     */
    apiType: 'vclaim' | 'antrean' | 'antreanFktp' | 'apotek' | 'aplicares' | 'icare' | 'pcare' | 'rekamMedis';
    /**
     * Environment
     */
    environment: 'development' | 'production';
    /**
     * Consumer ID
     */
    consId: string;
    /**
     * Secret key
     */
    secretKey: string;
    /**
     * User key
     */
    userKey: string;
    /**
     * PPK Pelayanan
     */
    ppkPelayanan?: string;
    /**
     * PPK BPJS
     */
    ppkBpjs?: string;
    /**
     * Facility type
     */
    facilityType?: BpjsFacilityType;
    /**
     * Base URL (optional - defaults based on environment)
     */
    baseUrl?: string;
};

/**
 * Request body for creating a lab order
 */
export type CreateLabOrderRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Queue ID
     */
    queueId?: string;
    /**
     * Priority
     */
    priority?: LabQueuePriority;
    /**
     * Clinical information
     */
    clinicalInfo?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Test IDs to order
     */
    testIds: Array<string>;
};

/**
 * Request body for creating a lab test
 */
export type CreateLabTestRequest = {
    /**
     * Test code
     */
    testCode: string;
    /**
     * Test name
     */
    testName: string;
    /**
     * Test name in Indonesian
     */
    testNameId?: string;
    /**
     * Test category
     */
    testCategory: LabTestCategory;
    /**
     * Test type
     */
    testType: LabTestType;
    /**
     * Description
     */
    description?: string;
    /**
     * Specimen type
     */
    specimenType?: string;
    /**
     * Result type
     */
    resultType: LabResultType;
    /**
     * Unit
     */
    unit?: string;
    /**
     * Normal range
     */
    normalRange?: string;
};

/**
 * Request body for creating an organization
 */
export type CreateOrganizationRequest = {
    /**
     * Organization code (unique)
     */
    orgCode: string;
    /**
     * Organization name
     */
    orgName: string;
    /**
     * Indonesian name
     */
    orgNameId?: string;
    /**
     * Organization type
     */
    orgType: OrgType;
    /**
     * License number
     */
    licenseNumber?: string;
    /**
     * NPWP
     */
    npwp?: string;
    /**
     * BPJS PPK code
     */
    bpjsPpkCode?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Country
     */
    country?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Website
     */
    website?: string;
};

/**
 * Request body for creating a patient allergy
 */
export type CreatePatientAllergyRequest = {
    /**
     * Allergy type
     */
    allergyType: AllergyType;
    /**
     * Allergen name
     */
    allergen: string;
    /**
     * Allergen in Indonesian
     */
    allergenId?: string;
    /**
     * Severity
     */
    severity: AllergySeverity;
    /**
     * Reaction description
     */
    reaction?: string;
    /**
     * Onset date
     */
    onsetDate?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating a patient
 */
export type CreatePatientRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * NIK (16 digits)
     */
    nik?: string;
    /**
     * BPJS number
     */
    bpjsNumber?: string;
    /**
     * First name
     */
    firstName: string;
    /**
     * Last name
     */
    lastName: string;
    /**
     * First name in Indonesian
     */
    firstNameId?: string;
    /**
     * Last name in Indonesian
     */
    lastNameId?: string;
    /**
     * Gender
     */
    gender: Gender;
    /**
     * Date of birth
     */
    dateOfBirth: string;
    /**
     * Place of birth
     */
    placeOfBirth?: string;
    /**
     * Marital status
     */
    maritalStatus?: MaritalStatus;
    /**
     * Blood type
     */
    bloodType?: BloodType;
    /**
     * Rhesus
     */
    rhesus?: Rhesus;
    /**
     * Religion
     */
    religion?: string;
    /**
     * Nationality
     */
    nationality?: string;
    /**
     * Country
     */
    country?: string;
    /**
     * Education level
     */
    education?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Mobile
     */
    mobile?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Occupation
     */
    occupation?: string;
    /**
     * Emergency contact name
     */
    emergencyContactName?: string;
    /**
     * Emergency contact phone
     */
    emergencyContactPhone?: string;
    /**
     * Emergency contact relationship
     */
    emergencyContactRelationship?: string;
};

/**
 * Request body for creating payment
 */
export type CreatePaymentRequest = {
    /**
     * Invoice ID
     */
    invoiceId: string;
    /**
     * Payment method
     */
    paymentMethod: PaymentMethod;
    /**
     * Amount
     */
    amount: number;
    /**
     * Reference number
     */
    referenceNumber?: string;
    /**
     * Card type
     */
    cardType?: string;
    /**
     * Card last 4 digits
     */
    cardLast4?: string;
    /**
     * Bank name
     */
    bankName?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating a polyclinic
 */
export type CreatePolyclinicRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Polyclinic code
     */
    polyclinicCode: string;
    /**
     * Polyclinic name
     */
    polyclinicName: string;
    /**
     * Indonesian name
     */
    polyclinicNameId?: string;
    /**
     * Polyclinic type
     */
    polyclinicType: PolyclinicType;
    /**
     * Description
     */
    description?: string;
    /**
     * Location
     */
    location?: string;
    /**
     * Floor
     */
    floor?: string;
    /**
     * Queue prefix
     */
    queuePrefix?: string;
    /**
     * BPJS poli code
     */
    bpjsPoliCode?: string;
    /**
     * Operating hours
     */
    operatingHours?: {
        [key: string]: unknown;
    };
};

/**
 * Request body for creating practitioner credential
 */
export type CreatePractitionerCredentialRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Credential type
     */
    credentialType: CredentialType;
    /**
     * Credential number
     */
    credentialNumber: string;
    /**
     * Credential name
     */
    credentialName: string;
    /**
     * Issuing authority
     */
    issuingAuthority: string;
    /**
     * Issued date
     */
    issuedDate: string;
    /**
     * Expiry date
     */
    expiryDate?: string;
    /**
     * Document URL
     */
    documentUrl?: string;
};

/**
 * Request body for creating a practitioner
 */
export type CreatePractitionerRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * First name
     */
    firstName: string;
    /**
     * Last name
     */
    lastName: string;
    /**
     * First name in Indonesian
     */
    firstNameId?: string;
    /**
     * Last name in Indonesian
     */
    lastNameId?: string;
    /**
     * Gender
     */
    gender?: Gender;
    /**
     * Date of birth
     */
    dateOfBirth?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Mobile
     */
    mobile?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Practitioner type
     */
    practitionerType: PractitionerType;
    /**
     * Specialty
     */
    specialty?: Specialty;
    /**
     * License number
     */
    licenseNumber?: string;
    /**
     * License expiry
     */
    licenseExpiry?: string;
    /**
     * NIP
     */
    nip?: string;
    /**
     * STR
     */
    str?: string;
    /**
     * SIP
     */
    sip?: string;
    /**
     * Bio
     */
    bio?: string;
};

/**
 * Request body for creating a schedule
 */
export type CreatePractitionerScheduleRequest = {
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Day of week
     */
    dayOfWeek: DayOfWeek;
    /**
     * Start time (HH:mm)
     */
    startTime: string;
    /**
     * End time (HH:mm)
     */
    endTime: string;
    /**
     * Effective from
     */
    effectiveFrom: string;
    /**
     * Effective to
     */
    effectiveTo?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating a prescription item
 */
export type CreatePrescriptionItemRequest = {
    /**
     * Medication ID
     */
    medicationId?: string;
    /**
     * Generic name
     */
    genericName: string;
    /**
     * Generic name in Indonesian
     */
    genericNameId?: string;
    /**
     * Brand name
     */
    brandName?: string;
    /**
     * Dosage form
     */
    dosageForm: DosageForm;
    /**
     * Strength
     */
    strength?: string;
    /**
     * Unit
     */
    unit?: string;
    /**
     * Frequency
     */
    frequency: Frequency;
    /**
     * Frequency description
     */
    frequencyDescription?: string;
    /**
     * Route
     */
    route?: string;
    /**
     * Duration in days
     */
    durationDays?: number;
    /**
     * Quantity
     */
    quantity: number;
    /**
     * Instructions
     */
    instructions?: string;
    /**
     * Dispense as written
     */
    dispenseAsWritten?: boolean;
};

/**
 * Request body for creating a prescription
 */
export type CreatePrescriptionRequest = {
    /**
     * Notes
     */
    notes?: string;
    /**
     * Items
     */
    items: Array<CreatePrescriptionItemRequest>;
};

/**
 * Request body for creating a procedure
 */
export type CreateProcedureRequest = {
    /**
     * ICD-9-CM code
     */
    icd9cmCode?: string;
    /**
     * ICD-9-CM description
     */
    icd9cmDescription?: string;
    /**
     * Procedure name
     */
    procedureName: string;
    /**
     * Procedure name in Indonesian
     */
    procedureNameId?: string;
    /**
     * Category
     */
    category: 'surgical' | 'diagnostic' | 'therapeutic' | 'preventive' | 'palliative' | 'other';
    /**
     * When performed
     */
    performedAt?: string;
    /**
     * Location
     */
    location?: string;
    /**
     * Body site
     */
    bodySite?: string;
    /**
     * Outcome
     */
    outcome?: string;
    /**
     * Complication
     */
    complication?: string;
    /**
     * Follow-up required
     */
    followUpRequired?: boolean;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating quality indicator
 */
export type CreateQualityIndicatorRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Indicator code
     */
    indicatorCode: string;
    /**
     * Indicator name
     */
    indicatorName: string;
    /**
     * Indicator name in Indonesian
     */
    indicatorNameId?: string;
    /**
     * Category
     */
    category: QualityIndicatorCategory;
    /**
     * Description
     */
    description?: string;
    /**
     * Numerator definition
     */
    numeratorDefinition: string;
    /**
     * Denominator definition
     */
    denominatorDefinition: string;
    /**
     * Formula
     */
    formula?: string;
    /**
     * Unit
     */
    unit?: string;
    /**
     * Target value
     */
    targetValue?: number;
    /**
     * Thresholds
     */
    thresholdGreen?: number;
    thresholdYellow?: number;
    thresholdRed?: number;
    /**
     * Measurement frequency
     */
    measurementFrequency?: string;
    /**
     * Responsible department
     */
    responsibleDepartment?: string;
    /**
     * Responsible person ID
     */
    responsiblePerson?: string;
};

/**
 * Request body for creating a queue entry
 */
export type CreateQueueRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Practitioner ID (optional)
     */
    practitionerId?: string;
    /**
     * Appointment ID (if from appointment)
     */
    appointmentId?: string;
    /**
     * Priority
     */
    priority?: QueuePriority;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating a referral
 */
export type CreateReferralRequest = {
    /**
     * Referral type
     */
    referralType: 'internal' | 'external';
    /**
     * Reason for referral
     */
    reason: string;
    /**
     * Referred to facility
     */
    referredToFacility?: string;
    /**
     * Referred to specialty
     */
    referredToSpecialty?: Specialty;
    /**
     * Is urgent
     */
    isUrgent?: boolean;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for creating refund
 */
export type CreateRefundRequest = {
    /**
     * Payment ID
     */
    paymentId: string;
    /**
     * Amount
     */
    amount: number;
    /**
     * Reason
     */
    reason: string;
    /**
     * Refund method
     */
    refundMethod?: PaymentMethod;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request to create a custom role
 */
export type CreateRoleRequest = {
    /**
     * Role name
     */
    name: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions to grant
     */
    permissions: Array<PermissionInput>;
};

/**
 * Request body for creating SatuSehat config
 */
export type CreateSatusehatConfigRequest = {
    /**
     * Branch ID (optional)
     */
    branchId?: string;
    /**
     * Environment
     */
    environment: 'sandbox' | 'production';
    /**
     * OAuth2 client ID
     */
    clientId: string;
    /**
     * OAuth2 client secret
     */
    clientSecret: string;
    /**
     * SatuSehat organization ID
     */
    satusehatOrgId?: string;
    /**
     * Auth URL (optional - defaults based on environment)
     */
    authUrl?: string;
    /**
     * API URL (optional - defaults based on environment)
     */
    apiUrl?: string;
};

/**
 * Request to create a webhook
 */
export type CreateWebhookRequest = {
    /**
     * URL to receive webhook payloads (must be HTTPS)
     */
    url: string;
    /**
     * Human-readable name
     */
    name?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Event types to subscribe to
     */
    events: Array<string>;
    /**
     * Whether the webhook is active (default: true)
     */
    isActive?: boolean;
};

/**
 * Credential status
 */
export type CredentialStatus = 'pending' | 'verified' | 'active' | 'expiringSoon' | 'expired' | 'revoked' | 'suspended';

/**
 * Credential type
 */
export type CredentialType = 'str' | 'sip' | 'sik' | 'sipb' | 'sipa' | 'serkom' | 'certificate' | 'bls' | 'acls' | 'atls';

/**
 * Critical notification method
 */
export type CriticalNotificationMethod = 'phone' | 'sms' | 'whatsapp' | 'email' | 'inPerson';

/**
 * Critical Value Notification
 *
 * Notification for critical lab values
 */
export type CriticalValueNotification = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Lab result ID
     */
    labResultId: string;
    /**
     * Notification date/time
     */
    notificationDate: string;
    /**
     * Notified by user ID
     */
    notifiedBy: string;
    /**
     * Notified to user ID
     */
    notifiedTo?: string;
    /**
     * Notification method
     */
    notificationMethod: CriticalNotificationMethod;
    /**
     * When acknowledged
     */
    acknowledgedAt?: string;
    /**
     * Acknowledged by user ID
     */
    acknowledgedBy?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Cursor-based pagination for large datasets or real-time data
 */
export type CursorPagination = {
    /**
     * Maximum items returned per page
     */
    limit: number;
    /**
     * Whether there is a next page
     */
    hasNext: boolean;
    /**
     * Cursor for fetching the next page (null if no more pages)
     */
    nextCursor: string | null;
    /**
     * Cursor for fetching the previous page (null if on first page)
     */
    previousCursor: string | null;
};

/**
 * Day of week
 */
export type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';

/**
 * Diagnosis record
 */
export type Diagnosis = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Encounter ID
     */
    encounterId: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * ICD-10 code
     */
    icd10Code: string;
    /**
     * ICD-10 description
     */
    icd10Description?: string;
    /**
     * Diagnosis name
     */
    diagnosisName: string;
    /**
     * Diagnosis name in Indonesian
     */
    diagnosisNameId?: string;
    /**
     * Diagnosis type
     */
    diagnosisType: DiagnosisType;
    /**
     * Verification status
     */
    verificationStatus: DiagnosisVerification;
    /**
     * Whether this is a chronic condition
     */
    isChronic: boolean;
    /**
     * Onset date
     */
    onsetDate?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * SatuSehat condition ID
     */
    satusehatConditionId?: string;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * When diagnosed
     */
    diagnosedAt: string;
    /**
     * Diagnosed by user ID
     */
    diagnosedBy: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Diagnosis list response
 */
export type DiagnosisListResponse = {
    /**
     * Array of resources
     */
    data: Array<Diagnosis>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Diagnosis response
 */
export type DiagnosisResponse = {
    /**
     * The resource data
     */
    data: Diagnosis;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Diagnosis type
 */
export type DiagnosisType = 'primary' | 'secondary' | 'admission' | 'discharge';

/**
 * Diagnosis verification status
 */
export type DiagnosisVerification = 'confirmed' | 'provisional' | 'differential' | 'refuted';

/**
 * Diagnostic Report
 *
 * Summary report of laboratory results
 */
export type DiagnosticReport = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Order ID
     */
    orderId?: string;
    /**
     * Report number
     */
    reportNumber: string;
    /**
     * Report date/time
     */
    reportDate: string;
    /**
     * Status
     */
    status: DiagnosticReportStatus;
    /**
     * Generated by user ID
     */
    generatedBy: string;
    /**
     * Conclusion
     */
    conclusion?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * SatuSehat DiagnosticReport ID
     */
    satusehatDiagnosticReportId?: string;
    /**
     * Whether synced to SatuSehat
     */
    isSatusehatSynced: boolean;
    /**
     * When synced to SatuSehat
     */
    satusehatSyncedAt?: string;
    /**
     * SatuSehat sync error
     */
    satusehatSyncError?: string;
    /**
     * Whether synced to JKN
     */
    isJknSynced: boolean;
    /**
     * When synced to JKN
     */
    jknSyncedAt?: string;
    /**
     * JKN sync error
     */
    jknSyncError?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Diagnostic report list response
 */
export type DiagnosticReportListResponse = {
    /**
     * Array of resources
     */
    data: Array<DiagnosticReport>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single diagnostic report response
 */
export type DiagnosticReportResponse = {
    /**
     * The resource data
     */
    data: DiagnosticReport;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Diagnostic report status
 */
export type DiagnosticReportStatus = 'preliminary' | 'final' | 'amended' | 'cancelled';

/**
 * Dispense status
 */
export type DispenseStatus = 'pending' | 'dispensed' | 'partiallyDispensed' | 'cancelled';

/**
 * Document Control
 *
 * Controlled documents for accreditation (SPO, policies)
 */
export type DocumentControl = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Document number
     */
    documentNumber: string;
    /**
     * Document type
     */
    documentType: DocumentControlType;
    /**
     * Document title
     */
    documentTitle: string;
    /**
     * Document title in Indonesian
     */
    documentTitleId?: string;
    /**
     * Department
     */
    department?: string;
    /**
     * Category
     */
    category?: string;
    /**
     * Version
     */
    version: string;
    /**
     * Previous version
     */
    previousVersion?: string;
    /**
     * Status
     */
    status: DocumentControlStatus;
    /**
     * Purpose
     */
    purpose?: string;
    /**
     * Scope
     */
    scope?: string;
    /**
     * Content
     */
    content?: string;
    /**
     * Attachment URL
     */
    attachmentUrl?: string;
    /**
     * Drafted at
     */
    draftedAt?: string;
    /**
     * Drafted by user ID
     */
    draftedBy?: string;
    /**
     * Reviewed at
     */
    reviewedAt?: string;
    /**
     * Reviewed by user ID
     */
    reviewedBy?: string;
    /**
     * Approved at
     */
    approvedAt?: string;
    /**
     * Approved by user ID
     */
    approvedBy?: string;
    /**
     * Published at
     */
    publishedAt?: string;
    /**
     * Published by user ID
     */
    publishedBy?: string;
    /**
     * Effective date
     */
    effectiveDate?: string;
    /**
     * Review date
     */
    reviewDate?: string;
    /**
     * Retirement date
     */
    retirementDate?: string;
    /**
     * Distribution list
     */
    distributionList?: Array<string>;
    /**
     * Whether acknowledgement required
     */
    acknowledgementRequired: boolean;
    /**
     * Revision history
     */
    revisionHistory?: Array<{
        version: string;
        date: string;
        changedBy: string;
        changes: string;
    }>;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Document control list response
 */
export type DocumentControlListResponse = {
    /**
     * Array of resources
     */
    data: Array<DocumentControl>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single document control response
 */
export type DocumentControlResponse = {
    /**
     * The resource data
     */
    data: DocumentControl;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Document control status
 */
export type DocumentControlStatus = 'draft' | 'review' | 'approved' | 'published' | 'underRevision' | 'retired';

/**
 * Document control type
 */
export type DocumentControlType = 'spo' | 'policy' | 'clinicalGuideline' | 'form' | 'instruction' | 'standard';

/**
 * Dosage form
 */
export type DosageForm = 'tablet' | 'capsule' | 'syrup' | 'injection' | 'ointment' | 'drops' | 'inhaler' | 'suppository' | 'other';

/**
 * Encounter (Clinical Visit) resource
 *
 * Represents a clinical encounter between patient and practitioner.
 * Aligned with FHIR Encounter resource for SatuSehat integration.
 */
export type Encounter = {
    /**
     * Unique encounter identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Encounter number
     */
    encounterNumber: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Appointment ID (if from appointment)
     */
    appointmentId?: string;
    /**
     * Encounter type
     */
    encounterType: EncounterType;
    /**
     * Encounter class (FHIR)
     */
    encounterClass: EncounterClass;
    /**
     * Encounter status
     */
    status: EncounterStatus;
    /**
     * Start time
     */
    startTime: string;
    /**
     * End time
     */
    endTime?: string;
    /**
     * Chief complaint
     */
    chiefComplaint?: string;
    /**
     * Reason for visit
     */
    reasonForVisit?: string;
    /**
     * Physical examination notes (JSON)
     */
    physicalExamination?: {
        [key: string]: unknown;
    };
    /**
     * Assessment notes
     */
    assessment?: string;
    /**
     * Plan notes
     */
    plan?: string;
    /**
     * BPJS SEP number
     */
    bpjsSepNumber?: string;
    /**
     * SatuSehat encounter ID
     */
    satusehatEncounterId?: string;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * When synced to SatuSehat
     */
    satusehatSyncedAt?: string;
    /**
     * SatuSehat sync error
     */
    satusehatSyncError?: string;
    /**
     * JKN sync status
     */
    isJknSynced: boolean;
    /**
     * Soft delete status
     */
    isDeleted: boolean;
    /**
     * When deleted
     */
    deletedAt?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Encounter class (FHIR-aligned)
 */
export type EncounterClass = 'ambulatory' | 'inpatient' | 'emergency' | 'observation';

/**
 * Encounter list response
 */
export type EncounterListResponse = {
    /**
     * Array of resources
     */
    data: Array<Encounter>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single encounter response
 */
export type EncounterResponse = {
    /**
     * The resource data
     */
    data: Encounter;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Encounter status (FHIR-aligned)
 */
export type EncounterStatus = 'planned' | 'arrived' | 'inProgress' | 'onLeave' | 'finished' | 'cancelled';

/**
 * Encounter type
 */
export type EncounterType = 'outpatient' | 'inpatient' | 'emergency' | 'homeVisit' | 'virtual';

/**
 * Complete encounter with all related data
 */
export type EncounterWithRelationsResponse = {
    data: {
        /**
         * Unique encounter identifier
         */
        id: string;
        /**
         * Organization ID (tenant scope)
         */
        organizationId: string;
        /**
         * Branch ID
         */
        branchId?: string;
        /**
         * Encounter number
         */
        encounterNumber: string;
        /**
         * Patient ID
         */
        patientId: string;
        /**
         * Practitioner ID
         */
        practitionerId: string;
        /**
         * Polyclinic ID
         */
        polyclinicId: string;
        /**
         * Appointment ID (if from appointment)
         */
        appointmentId?: string;
        /**
         * Encounter type
         */
        encounterType: EncounterType;
        /**
         * Encounter class (FHIR)
         */
        encounterClass: EncounterClass;
        /**
         * Encounter status
         */
        status: EncounterStatus;
        /**
         * Start time
         */
        startTime: string;
        /**
         * End time
         */
        endTime?: string;
        /**
         * Chief complaint
         */
        chiefComplaint?: string;
        /**
         * Reason for visit
         */
        reasonForVisit?: string;
        /**
         * Physical examination notes (JSON)
         */
        physicalExamination?: {
            [key: string]: unknown;
        };
        /**
         * Assessment notes
         */
        assessment?: string;
        /**
         * Plan notes
         */
        plan?: string;
        /**
         * BPJS SEP number
         */
        bpjsSepNumber?: string;
        /**
         * SatuSehat encounter ID
         */
        satusehatEncounterId?: string;
        /**
         * SatuSehat sync status
         */
        isSatusehatSynced: boolean;
        /**
         * When synced to SatuSehat
         */
        satusehatSyncedAt?: string;
        /**
         * SatuSehat sync error
         */
        satusehatSyncError?: string;
        /**
         * JKN sync status
         */
        isJknSynced: boolean;
        /**
         * Soft delete status
         */
        isDeleted: boolean;
        /**
         * When deleted
         */
        deletedAt?: string;
        /**
         * When created
         */
        createdAt: string;
        /**
         * When updated
         */
        updatedAt: string;
        patient?: {
            id: string;
            fullName: string;
            medicalRecordNumber: string;
            dateOfBirth: string;
            gender: Gender;
        };
        practitioner?: {
            id: string;
            fullName: string;
            specialty?: Specialty;
        };
        polyclinic?: {
            id: string;
            polyclinicName: string;
        };
        vitalSigns?: VitalSigns;
        diagnoses?: Array<Diagnosis>;
        prescriptions?: Array<Prescription>;
        procedures?: Array<Procedure>;
        referrals?: Array<Referral>;
    };
    meta: ResponseMeta;
};

/**
 * Request body for entering lab result
 */
export type EnterLabResultRequest = {
    /**
     * Specimen ID
     */
    specimenId?: string;
    /**
     * Result value
     */
    resultValue?: string;
    /**
     * Result text
     */
    resultText?: string;
    /**
     * Interpretation
     */
    interpretation?: LabResultInterpretation;
    /**
     * Whether abnormal
     */
    isAbnormal?: boolean;
    /**
     * Whether critical
     */
    isCritical?: boolean;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Standard error object
 */
export type Error = {
    /**
     * Machine-readable error code
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Array of detailed error information (e.g., validation errors)
     */
    details?: Array<ErrorDetail>;
    /**
     * Request ID for tracking and debugging
     */
    requestId: string;
    /**
     * URL to documentation about this error (optional)
     */
    documentationUrl?: string;
};

/**
 * Detailed error information for a specific field or validation
 */
export type ErrorDetail = {
    /**
     * The field that caused the error (for validation errors)
     */
    field: string;
    /**
     * Specific error code for this detail
     */
    code: string;
    /**
     * Human-readable error message
     */
    message: string;
    /**
     * Additional metadata about the error
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Standard error response envelope
 */
export type ErrorResponse = {
    /**
     * The error object
     */
    error: Error;
};

/**
 * ExampleComment resource model (nested under ExamplePost)
 *
 * Demonstrates:
 * - Nested sub-resource pattern (belongs to a post)
 * - Multi-tenant scoping (orgId)
 * - Soft delete with restore capability
 */
export type ExampleComment = {
    /**
     * Unique comment identifier (format: cmt_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Parent post ID
     */
    postId: string;
    /**
     * Comment content
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Whether the comment is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the comment was soft deleted
     */
    deletedAt?: string;
    /**
     * User ID who deleted this comment
     */
    deletedBy?: string;
    /**
     * Timestamp when the comment was created
     */
    createdAt: string;
    /**
     * Timestamp when the comment was last updated
     */
    updatedAt: string;
};

/**
 * Comment collection response
 */
export type ExampleCommentListResponse = {
    data: Array<ExampleComment>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single comment response
 */
export type ExampleCommentResponse = {
    data: ExampleComment;
    meta: ResponseMeta;
};

/**
 * ExamplePost resource model
 *
 * Demonstrates a typical content resource with:
 * - Multi-tenant scoping (orgId)
 * - Status workflow (draft  published  archived)
 * - Soft delete with restore capability
 */
export type ExamplePost = {
    /**
     * Unique post identifier (format: post_{randomString})
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    orgId: string;
    /**
     * Post title
     */
    title: string;
    /**
     * Post content (supports markdown)
     */
    content: string;
    /**
     * Author user ID
     */
    authorId: string;
    /**
     * Post status
     */
    status: ExamplePostStatus;
    /**
     * Timestamp when the post was published (null if not published)
     */
    publishedAt?: string;
    /**
     * Whether the post is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the post was soft deleted (null if not deleted)
     */
    deletedAt?: string;
    /**
     * User ID who deleted this post (null if not deleted)
     */
    deletedBy?: string;
    /**
     * Timestamp when the post was created
     */
    createdAt: string;
    /**
     * Timestamp when the post was last updated
     */
    updatedAt: string;
};

/**
 * Post collection response (cursor-based)
 *
 * Used for streaming/real-time scenarios or large datasets
 */
export type ExamplePostCursorListResponse = {
    data: Array<ExamplePost>;
    pagination: CursorPagination;
    meta: ResponseMeta;
};

/**
 * Post collection response (page-based)
 */
export type ExamplePostListResponse = {
    data: Array<ExamplePost>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single post response
 */
export type ExamplePostResponse = {
    data: ExamplePost;
    meta: ResponseMeta;
};

/**
 * Post status enum
 */
export type ExamplePostStatus = 'draft' | 'published' | 'archived';

/**
 * File resource model
 *
 * Represents an uploaded file with metadata, security status, and access info.
 */
export type File = {
    /**
     * Unique file identifier (format: file_abc123)
     */
    id: string;
    /**
     * Original filename (sanitized)
     */
    filename: string;
    /**
     * File size in bytes
     */
    size: number;
    /**
     * MIME type (verified via magic bytes, not client-provided)
     */
    mimeType: string;
    /**
     * Storage path (internal, not exposed to clients in production)
     */
    storagePath: string;
    /**
     * Signed URL for file access (time-limited)
     */
    url?: string;
    /**
     * File metadata (user-provided)
     */
    metadata?: {
        [key: string]: string;
    };
    /**
     * User ID who uploaded the file
     */
    uploadedBy: string;
    /**
     * Timestamp when the file was uploaded
     */
    uploadedAt: string;
    /**
     * Virus scan status
     */
    virusScanStatus: VirusScanStatus;
    /**
     * Timestamp when virus scan completed
     */
    virusScanCompletedAt?: string;
    /**
     * Access level
     */
    access: FileAccess;
    /**
     * Whether the file is soft deleted
     */
    isDeleted: boolean;
    /**
     * Timestamp when the file was deleted
     */
    deletedAt?: string;
    /**
     * User ID who deleted this file
     */
    deletedBy?: string;
};

/**
 * File access level
 */
export type FileAccess = 'private' | 'public';

/**
 * File deletion response
 */
export type FileDeleteResponse = {
    data: {
        /**
         * ID of the deleted file
         */
        id: string;
        /**
         * When the file was deleted
         */
        deletedAt: string;
        /**
         * Who deleted the file
         */
        deletedBy: string;
    };
    meta: ResponseMeta;
};

/**
 * File list response with pagination
 */
export type FileListResponse = {
    data: Array<File>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single file response
 */
export type FileResponse = {
    data: File;
    meta: ResponseMeta;
};

/**
 * Medication frequency
 */
export type Frequency = 'onceDaily' | 'twiceDaily' | 'threeTimesDaily' | 'fourTimesDaily' | 'every8Hours' | 'every12Hours' | 'every24Hours' | 'asNeeded' | 'other';

/**
 * Gender (FHIR-aligned)
 */
export type Gender = 'male' | 'female' | 'other';

/**
 * Request body for generating slots
 */
export type GenerateSlotsRequest = {
    /**
     * Schedule ID
     */
    scheduleId: string;
    /**
     * Date from
     */
    dateFrom: string;
    /**
     * Date to
     */
    dateTo: string;
    /**
     * Slot duration in minutes
     */
    slotDurationMinutes?: number;
};

/**
 * Patient safety incident severity
 */
export type IncidentSeverity = 'nearMiss' | 'noHarm' | 'mild' | 'moderate' | 'severe' | 'sentinel';

/**
 * Incident status
 */
export type IncidentStatus = 'reported' | 'investigating' | 'actionRequired' | 'resolved' | 'closed';

/**
 * Infection control category
 */
export type InfectionControlCategory = 'iad' | 'vap' | 'cauti' | 'ssi' | 'clabsi' | 'haiOther';

/**
 * Infection Surveillance
 *
 * Healthcare-associated infection (HAI) tracking for PPI
 */
export type InfectionSurveillance = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Surveillance number
     */
    surveillanceNumber: string;
    /**
     * Category
     */
    category: InfectionControlCategory;
    /**
     * Status
     */
    status: InfectionSurveillanceStatus;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Encounter ID
     */
    encounterId?: string;
    /**
     * Detection date
     */
    detectionDate: string;
    /**
     * Reported date
     */
    reportedDate: string;
    /**
     * Reported by user ID
     */
    reportedBy: string;
    /**
     * Ward
     */
    ward?: string;
    /**
     * Room number
     */
    roomNumber?: string;
    /**
     * Infection site
     */
    infectionSite?: string;
    /**
     * Organism (pathogen)
     */
    organism?: string;
    /**
     * Culture result
     */
    cultureResult?: string;
    /**
     * Antibiotic sensitivity
     */
    antibioticSensitivity?: Array<{
        antibiotic: string;
        result: 'sensitive' | 'intermediate' | 'resistant';
    }>;
    /**
     * Whether device-related
     */
    deviceRelated: boolean;
    /**
     * Device type
     */
    deviceType?: string;
    /**
     * Device insertion date
     */
    deviceInsertionDate?: string;
    /**
     * Device removal date
     */
    deviceRemovalDate?: string;
    /**
     * Whether surgery-related
     */
    surgeryRelated: boolean;
    /**
     * Surgery date
     */
    surgeryDate?: string;
    /**
     * Surgery type
     */
    surgeryType?: string;
    /**
     * Outcome
     */
    outcome?: string;
    /**
     * Resolved date
     */
    resolvedDate?: string;
    /**
     * Days of infection
     */
    daysOfInfection?: number;
    /**
     * Investigated by user ID
     */
    investigatedBy?: string;
    /**
     * Investigation notes
     */
    investigationNotes?: string;
    /**
     * Bundle compliance checked
     */
    bundleComplianceChecked: boolean;
    /**
     * Bundle compliance score
     */
    bundleComplianceScore?: number;
    /**
     * Actions taken
     */
    actionsTaken?: Array<{
        action: string;
        date: string;
        performedBy: string;
    }>;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Infection surveillance list response
 */
export type InfectionSurveillanceListResponse = {
    /**
     * Array of resources
     */
    data: Array<InfectionSurveillance>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single infection surveillance response
 */
export type InfectionSurveillanceResponse = {
    /**
     * The resource data
     */
    data: InfectionSurveillance;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Infection surveillance status
 */
export type InfectionSurveillanceStatus = 'suspected' | 'confirmed' | 'resolved' | 'notInfection';

/**
 * Request to initiate a presigned URL upload
 */
export type InitiateUploadRequest = {
    /**
     * Original filename
     */
    filename: string;
    /**
     * MIME type of the file
     */
    contentType: string;
    /**
     * File size in bytes
     */
    size: number;
    /**
     * Optional metadata
     */
    metadata?: {
        [key: string]: string;
    };
};

/**
 * Response with presigned URL for direct upload to storage
 */
export type InitiateUploadResponse = {
    data: {
        /**
         * Upload ID for confirmation step
         */
        uploadId: string;
        /**
         * Presigned URL to upload to
         */
        presignedUrl: string;
        /**
         * HTTP method to use
         */
        method: 'PUT';
        /**
         * Required headers for the upload
         */
        headers: {
            [key: string]: string;
        };
        /**
         * When the presigned URL expires
         */
        expiresAt: string;
        /**
         * Maximum allowed file size
         */
        maxSize: number;
    };
    meta: ResponseMeta;
};

/**
 * Integration dashboard/summary
 */
export type IntegrationDashboardResponse = {
    data: {
        /**
         * SatuSehat stats
         */
        satusehat: {
            /**
             * Whether configured
             */
            isConfigured: boolean;
            /**
             * Health status
             */
            healthStatus: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
            /**
             * Last sync time
             */
            lastSyncAt?: string;
            /**
             * Pending syncs count
             */
            pendingSyncs: number;
            /**
             * Failed syncs count
             */
            failedSyncs: number;
            /**
             * Total synced today
             */
            syncedToday: number;
        };
        /**
         * JKN stats
         */
        jkn: {
            /**
             * Configured APIs
             */
            configuredApis: Array<string>;
            /**
             * Health status
             */
            healthStatus: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
            /**
             * Last sync time
             */
            lastSyncAt?: string;
            /**
             * Pending syncs count
             */
            pendingSyncs: number;
            /**
             * Failed syncs count
             */
            failedSyncs: number;
            /**
             * Total synced today
             */
            syncedToday: number;
        };
        /**
         * Recent errors
         */
        recentErrors: Array<IntegrationErrorLog>;
    };
    meta: ResponseMeta;
};

/**
 * Integration error log
 */
export type IntegrationErrorLog = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Integration type
     */
    integrationType: 'satusehat' | 'jkn';
    /**
     * Sync queue ID
     */
    syncQueueId?: string;
    /**
     * Resource type
     */
    resourceType: string;
    /**
     * Resource ID
     */
    resourceId?: string;
    /**
     * Error category
     */
    errorCategory: 'transient' | 'client' | 'auth' | 'notFound' | 'server' | 'validation' | 'unknown';
    /**
     * Error code
     */
    errorCode?: string;
    /**
     * Error message
     */
    errorMessage: string;
    /**
     * Request payload
     */
    requestPayload?: {
        [key: string]: unknown;
    };
    /**
     * Response payload
     */
    responsePayload?: {
        [key: string]: unknown;
    };
    /**
     * Stack trace
     */
    stackTrace?: string;
    /**
     * Resolution status
     */
    resolution: 'pending' | 'resolved' | 'autoResolved' | 'ignored';
    /**
     * Resolved by user ID
     */
    resolvedBy?: string;
    /**
     * When resolved
     */
    resolvedAt?: string;
    /**
     * Resolution notes
     */
    resolutionNotes?: string;
    /**
     * When created
     */
    createdAt: string;
};

/**
 * Error log list response
 */
export type IntegrationErrorLogListResponse = {
    /**
     * Array of resources
     */
    data: Array<IntegrationErrorLog>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Error log response
 */
export type IntegrationErrorLogResponse = {
    /**
     * The resource data
     */
    data: IntegrationErrorLog;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Integration sync queue entry
 *
 * Tracks pending synchronization operations
 */
export type IntegrationSyncQueue = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Integration type
     */
    integrationType: 'satusehat' | 'jkn';
    /**
     * Resource type
     */
    resourceType: string;
    /**
     * Resource ID
     */
    resourceId: string;
    /**
     * Operation type
     */
    operation: 'create' | 'update' | 'delete' | 'search' | 'validate';
    /**
     * Sync status
     */
    status: 'pending' | 'processing' | 'completed' | 'failed' | 'skipped';
    /**
     * Priority (lower = higher priority)
     */
    priority: number;
    /**
     * Request payload (JSON)
     */
    requestPayload?: {
        [key: string]: unknown;
    };
    /**
     * Response payload (JSON)
     */
    responsePayload?: {
        [key: string]: unknown;
    };
    /**
     * External ID (from SatuSehat/JKN)
     */
    externalId?: string;
    /**
     * Error message
     */
    errorMessage?: string;
    /**
     * Error category
     */
    errorCategory?: 'transient' | 'client' | 'auth' | 'notFound' | 'server' | 'validation' | 'unknown';
    /**
     * Retry count
     */
    retryCount: number;
    /**
     * Max retries
     */
    maxRetries: number;
    /**
     * Next retry time
     */
    nextRetryAt?: string;
    /**
     * Correlation ID for tracking
     */
    correlationId?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
    /**
     * When completed
     */
    completedAt?: string;
};

/**
 * Sync queue list response
 */
export type IntegrationSyncQueueListResponse = {
    /**
     * Array of resources
     */
    data: Array<IntegrationSyncQueue>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Sync queue response
 */
export type IntegrationSyncQueueResponse = {
    /**
     * The resource data
     */
    data: IntegrationSyncQueue;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Integration test result
 */
export type IntegrationTestResponse = {
    data: {
        /**
         * Test status
         */
        status: 'success' | 'partial' | 'failed';
        /**
         * Test results
         */
        results: Array<{
            /**
             * Test name
             */
            test: string;
            /**
             * Test passed
             */
            passed: boolean;
            /**
             * Error message if failed
             */
            error?: string;
            /**
             * Response time in ms
             */
            responseTimeMs?: number;
        }>;
        /**
         * Overall health status
         */
        healthStatus: 'healthy' | 'degraded' | 'unhealthy';
        /**
         * Timestamp
         */
        testedAt: string;
    };
    meta: ResponseMeta;
};

/**
 * Integration webhook (incoming events from SatuSehat/JKN)
 */
export type IntegrationWebhook = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Source
     */
    source: 'satusehat' | 'jkn';
    /**
     * Event type
     */
    eventType: string;
    /**
     * Webhook payload
     */
    payload: {
        [key: string]: unknown;
    };
    /**
     * Processing status
     */
    status: 'received' | 'processing' | 'processed' | 'failed' | 'ignored';
    /**
     * Error message
     */
    errorMessage?: string;
    /**
     * Sync queue ID (if created)
     */
    syncQueueId?: string;
    /**
     * When received
     */
    receivedAt: string;
    /**
     * When processed
     */
    processedAt?: string;
};

/**
 * Invoice
 *
 * Bill for services rendered to a patient
 */
export type Invoice = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Encounter ID
     */
    encounterId?: string;
    /**
     * Invoice number
     */
    invoiceNumber: string;
    /**
     * Invoice date
     */
    invoiceDate: string;
    /**
     * Due date
     */
    dueDate?: string;
    /**
     * Status
     */
    status: InvoiceStatus;
    /**
     * Payment type
     */
    paymentType: PaymentType;
    /**
     * Payer type
     */
    payerType: PayerType;
    /**
     * BPJS number (if JKN)
     */
    bpjsNumber?: string;
    /**
     * Insurance company (if private insurance)
     */
    insuranceCompany?: string;
    /**
     * Insurance policy number
     */
    insurancePolicyNumber?: string;
    /**
     * Subtotal (before discount/tax)
     */
    subtotal: number;
    /**
     * Discount amount
     */
    discountAmount: number;
    /**
     * Discount percentage
     */
    discountPercent?: number;
    /**
     * Discount reason
     */
    discountReason?: string;
    /**
     * Tax amount
     */
    taxAmount: number;
    /**
     * Total amount
     */
    totalAmount: number;
    /**
     * Amount paid
     */
    amountPaid: number;
    /**
     * Balance due
     */
    balanceDue: number;
    /**
     * Currency
     */
    currency: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Invoice items
     */
    items?: Array<InvoiceItem>;
    /**
     * When approved
     */
    approvedAt?: string;
    /**
     * Approved by user ID
     */
    approvedBy?: string;
    /**
     * When voided
     */
    voidedAt?: string;
    /**
     * Voided by user ID
     */
    voidedBy?: string;
    /**
     * Void reason
     */
    voidReason?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Invoice Item
 *
 * Individual billable item on an invoice
 */
export type InvoiceItem = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Invoice ID
     */
    invoiceId: string;
    /**
     * Item type
     */
    itemType: BillableItemType;
    /**
     * Item code
     */
    itemCode: string;
    /**
     * Item name
     */
    itemName: string;
    /**
     * Quantity
     */
    quantity: number;
    /**
     * Unit
     */
    unit: string;
    /**
     * Unit price
     */
    unitPrice: number;
    /**
     * Discount amount
     */
    discountAmount: number;
    /**
     * Total amount
     */
    totalAmount: number;
    /**
     * Reference ID (e.g., prescription ID, procedure ID)
     */
    referenceId?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Invoice list response
 */
export type InvoiceListResponse = {
    /**
     * Array of resources
     */
    data: Array<Invoice>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single invoice response
 */
export type InvoiceResponse = {
    /**
     * The resource data
     */
    data: Invoice;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Invoice status
 */
export type InvoiceStatus = 'draft' | 'pending' | 'partial' | 'paid' | 'cancelled' | 'voided';

/**
 * JKN/BPJS Kesehatan configuration per tenant
 *
 * Stores API credentials for all JKN APIs:
 * - VClaim (SEP, Rujukan, Peserta)
 * - Antrean (Queue management)
 * - Apotek (Pharmacy)
 * - Aplicares (Bed availability)
 * - ICare (Mobile integration)
 * - PCare (Primary care)
 * - Rekam Medis (Medical records)
 */
export type JknConfig = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID (optional)
     */
    branchId?: string;
    /**
     * JKN API type
     */
    apiType: 'vclaim' | 'antrean' | 'antreanFktp' | 'apotek' | 'aplicares' | 'icare' | 'pcare' | 'rekamMedis';
    /**
     * Environment
     */
    environment: 'development' | 'production';
    /**
     * Consumer ID (cons_id)
     */
    consId: string;
    /**
     * Secret key (masked in responses)
     */
    secretKeyMasked: string;
    /**
     * User key (masked in responses)
     */
    userKeyMasked: string;
    /**
     * PPK Pelayanan (facility code)
     */
    ppkPelayanan?: string;
    /**
     * PPK BPJS code
     */
    ppkBpjs?: string;
    /**
     * Facility type
     */
    facilityType?: BpjsFacilityType;
    /**
     * API base URL
     */
    baseUrl: string;
    /**
     * Whether config is active
     */
    isActive: boolean;
    /**
     * Last health check status
     */
    healthStatus: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
    /**
     * Last health check time
     */
    lastHealthCheckAt?: string;
    /**
     * Last successful sync time
     */
    lastSyncAt?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * JKN config list response
 */
export type JknConfigListResponse = {
    /**
     * Array of resources
     */
    data: Array<JknConfig>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single JKN config response
 */
export type JknConfigResponse = {
    /**
     * The resource data
     */
    data: JknConfig;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Async job resource
 *
 * Represents a long-running operation that can be polled for status.
 */
export type Job = {
    /**
     * Unique job identifier (format: job_abc123)
     */
    jobId: string;
    /**
     * Tenant this job belongs to
     */
    tenantId: string;
    /**
     * Type of operation (e.g., "bulkImport", "reportGeneration")
     */
    type: string;
    /**
     * Current job status
     */
    status: JobStatus;
    /**
     * Progress percentage (0-100, if available)
     */
    progress?: number;
    /**
     * Human-readable status message
     */
    message?: string;
    /**
     * Result data (when completed)
     */
    result?: {
        [key: string]: unknown;
    };
    /**
     * Error details (when failed)
     */
    error?: {
        /**
         * Error code
         */
        code: string;
        /**
         * Error message
         */
        message: string;
        /**
         * Additional error details
         */
        details?: {
            [key: string]: unknown;
        };
    };
    /**
     * Who initiated the job
     */
    createdBy: string;
    /**
     * When the job was created
     */
    createdAt: string;
    /**
     * When the job started processing
     */
    startedAt?: string;
    /**
     * When the job completed (success or failure)
     */
    completedAt?: string;
    /**
     * Estimated completion time (if available)
     */
    estimatedCompletion?: string;
};

/**
 * Job list response
 */
export type JobListResponse = {
    data: Array<Job>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Job status response
 */
export type JobResponse = {
    data: Job;
    meta: ResponseMeta;
};

/**
 * Job status
 */
export type JobStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';

/**
 * Lab Order
 *
 * Order for laboratory tests
 */
export type LabOrder = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Queue ID
     */
    queueId?: string;
    /**
     * Order number
     */
    orderNumber: string;
    /**
     * When ordered
     */
    orderedAt: string;
    /**
     * Ordered by user ID
     */
    orderedBy: string;
    /**
     * Priority
     */
    priority: LabQueuePriority;
    /**
     * Status
     */
    status: LabQueueStatus;
    /**
     * Clinical information
     */
    clinicalInfo?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Order items
     */
    items?: Array<LabOrderItem>;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Lab Order Item
 *
 * Individual test within a lab order
 */
export type LabOrderItem = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Order ID
     */
    orderId: string;
    /**
     * Lab test ID
     */
    labTestId: string;
    /**
     * Test code
     */
    testCode: string;
    /**
     * Test name
     */
    testName: string;
    /**
     * Test name in Indonesian
     */
    testNameId?: string;
    /**
     * Priority
     */
    priority: LabQueuePriority;
    /**
     * Status
     */
    status: LabQueueStatus;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Lab order list response
 */
export type LabOrderListResponse = {
    /**
     * Array of resources
     */
    data: Array<LabOrder>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single lab order response
 */
export type LabOrderResponse = {
    /**
     * The resource data
     */
    data: LabOrder;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Lab Queue entry
 *
 * Patient queue for lab specimen collection
 */
export type LabQueue = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Queue number
     */
    queueNumber: string;
    /**
     * Queue status
     */
    status: LabQueueStatus;
    /**
     * Priority
     */
    priority: LabQueuePriority;
    /**
     * Whether fasting required
     */
    isFasting: boolean;
    /**
     * Whether fasting verified
     */
    fastingVerified: boolean;
    /**
     * When fasting verified
     */
    fastingVerifiedAt?: string;
    /**
     * Fasting verified by user ID
     */
    fastingVerifiedBy?: string;
    /**
     * Clinical information
     */
    clinicalInfo?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Lab queue priority
 */
export type LabQueuePriority = 'routine' | 'urgent' | 'stat' | 'cito';

/**
 * Lab queue status
 */
export type LabQueueStatus = 'pending' | 'collecting' | 'received' | 'processing' | 'resulted' | 'authorized' | 'completed' | 'cancelled';

/**
 * Lab Result
 *
 * Result from laboratory analysis
 */
export type LabResult = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Order item ID
     */
    orderItemId: string;
    /**
     * Specimen ID
     */
    specimenId?: string;
    /**
     * Result date/time
     */
    resultDate: string;
    /**
     * Result value
     */
    resultValue?: string;
    /**
     * Result text (for narrative results)
     */
    resultText?: string;
    /**
     * Interpretation
     */
    interpretation?: LabResultInterpretation;
    /**
     * Whether result is abnormal
     */
    isAbnormal: boolean;
    /**
     * Whether result is critical
     */
    isCritical: boolean;
    /**
     * Status
     */
    status: LabResultStatus;
    /**
     * When verified
     */
    verifiedAt?: string;
    /**
     * Verified by user ID
     */
    verifiedBy?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * SatuSehat Observation ID
     */
    satusehatObservationId?: string;
    /**
     * Whether synced to SatuSehat
     */
    isSatusehatSynced: boolean;
    /**
     * When synced to SatuSehat
     */
    satusehatSyncedAt?: string;
    /**
     * SatuSehat sync error
     */
    satusehatSyncError?: string;
    /**
     * Whether synced to JKN
     */
    isJknSynced: boolean;
    /**
     * When synced to JKN
     */
    jknSyncedAt?: string;
    /**
     * JKN sync error
     */
    jknSyncError?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Lab result interpretation
 */
export type LabResultInterpretation = 'normal' | 'low' | 'high' | 'criticalLow' | 'criticalHigh' | 'abnormal';

/**
 * Lab result list response
 */
export type LabResultListResponse = {
    /**
     * Array of resources
     */
    data: Array<LabResult>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single lab result response
 */
export type LabResultResponse = {
    /**
     * The resource data
     */
    data: LabResult;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Lab result status
 */
export type LabResultStatus = 'preliminary' | 'final' | 'amended' | 'cancelled';

/**
 * Lab result type
 */
export type LabResultType = 'numeric' | 'text' | 'positiveNegative' | 'image';

/**
 * Lab Test definition
 *
 * Defines available laboratory tests with reference ranges
 */
export type LabTest = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Test code
     */
    testCode: string;
    /**
     * Test name
     */
    testName: string;
    /**
     * Test name in Indonesian
     */
    testNameId?: string;
    /**
     * Test category
     */
    testCategory: LabTestCategory;
    /**
     * Test type
     */
    testType: LabTestType;
    /**
     * Description
     */
    description?: string;
    /**
     * Specimen type required
     */
    specimenType?: string;
    /**
     * Result type
     */
    resultType: LabResultType;
    /**
     * Unit of measurement
     */
    unit?: string;
    /**
     * Normal range description
     */
    normalRange?: string;
    /**
     * Whether test is active
     */
    isActive: boolean;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Lab test category
 */
export type LabTestCategory = 'hematology' | 'chemistry' | 'urinalysis' | 'serology' | 'microbiology' | 'histopathology' | 'other';

/**
 * Lab test list response
 */
export type LabTestListResponse = {
    /**
     * Array of resources
     */
    data: Array<LabTest>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Lab Test Reference Range
 *
 * Reference ranges by age and gender
 */
export type LabTestReferenceRange = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Lab test ID
     */
    labTestId: string;
    /**
     * Gender filter
     */
    gender?: string;
    /**
     * Minimum age
     */
    ageMin?: number;
    /**
     * Maximum age
     */
    ageMax?: number;
    /**
     * Age unit
     */
    ageUnit?: string;
    /**
     * Minimum normal value
     */
    minValue?: string;
    /**
     * Maximum normal value
     */
    maxValue?: string;
    /**
     * Critical low value
     */
    minValueCritical?: string;
    /**
     * Critical high value
     */
    maxValueCritical?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Single lab test response
 */
export type LabTestResponse = {
    /**
     * The resource data
     */
    data: LabTest;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Lab test type
 */
export type LabTestType = 'quantitative' | 'qualitative' | 'semiQuantitative' | 'culture';

/**
 * Patient marital status
 */
export type MaritalStatus = 'single' | 'married' | 'divorced' | 'widowed';

/**
 * Mark all as read response
 */
export type MarkAllReadResponse = {
    data: {
        /**
         * Number of notifications marked as read
         */
        markedCount: number;
    };
    meta: ResponseMeta;
};

/**
 * Version lifecycle status
 */
export type MigrationStatus = 'current' | 'deprecated' | 'sunset';

/**
 * Migration status for an API version
 */
export type MigrationStatusResponse = {
    /**
     * API version (e.g., "v1")
     */
    version: string;
    /**
     * Version lifecycle status
     */
    status: MigrationStatus;
    /**
     * ISO 8601 date when this version will be removed (if deprecated)
     */
    sunsetDate?: string;
    /**
     * Days remaining until sunset (if deprecated)
     */
    daysUntilSunset?: number;
    /**
     * Version to migrate to (if deprecated)
     */
    replacementVersion?: string;
    /**
     * URL to the migration guide
     */
    migrationGuideUrl?: string;
    /**
     * List of breaking changes in the replacement version
     */
    breakingChanges?: Array<string>;
    /**
     * Steps to complete the migration
     */
    migrationChecklist?: Array<string>;
};

/**
 * Notification resource model
 */
export type Notification = {
    /**
     * Unique notification identifier
     */
    id: string;
    /**
     * User ID who should receive this notification
     */
    userId?: string;
    /**
     * Notification channel
     */
    channel: NotificationChannel;
    /**
     * Notification category
     */
    category: NotificationCategory;
    /**
     * Notification priority
     */
    priority: NotificationPriority;
    /**
     * Current notification status
     */
    status: NotificationStatus;
    /**
     * Email address this was sent to
     */
    recipientEmail?: string;
    /**
     * Phone number this was sent to
     */
    recipientPhone?: string;
    /**
     * Telegram ID this was sent to
     */
    recipientTelegramId?: string;
    /**
     * Template ID used (if any)
     */
    templateId?: string;
    /**
     * Subject line (for email)
     */
    subject?: string;
    /**
     * Plain text body
     */
    body?: string;
    /**
     * HTML body (for email)
     */
    bodyHtml?: string;
    /**
     * Template data used for rendering
     */
    templateData?: {
        [key: string]: unknown;
    };
    /**
     * Campaign ID for bulk sends
     */
    campaignId?: string;
    /**
     * Provider used to send (e.g., "nodemailer", "twilio")
     */
    provider?: string;
    /**
     * Provider's message ID
     */
    providerMessageId?: string;
    /**
     * Timestamp when notification was sent
     */
    sentAt?: string;
    /**
     * Timestamp when notification was delivered
     */
    deliveredAt?: string;
    /**
     * Timestamp when notification failed
     */
    failedAt?: string;
    /**
     * Timestamp when notification was read by user
     */
    readAt?: string;
    /**
     * Timestamp when notification was soft deleted
     */
    deletedAt?: string;
    /**
     * Number of retry attempts
     */
    retryCount: number;
    /**
     * Maximum retry attempts allowed
     */
    maxRetries: number;
    /**
     * Next retry timestamp
     */
    nextRetryAt?: string;
    /**
     * Status message (error details if failed)
     */
    statusMessage?: string;
    /**
     * Metadata for custom data
     */
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Timestamp when notification was created
     */
    createdAt: string;
    /**
     * Timestamp when notification was last updated
     */
    updatedAt: string;
};

/**
 * Notification category enum
 */
export type NotificationCategory = 'transactional' | 'marketing' | 'security' | 'system';

/**
 * Notification channel enum
 */
export type NotificationChannel = 'email' | 'sms' | 'whatsapp' | 'telegram' | 'push';

/**
 * Notification collection response
 */
export type NotificationListResponse = {
    data: Array<Notification>;
    meta: ResponseMeta;
};

/**
 * Notification preferences model
 */
export type NotificationPreferences = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Email notifications enabled
     */
    emailEnabled: boolean;
    /**
     * SMS notifications enabled
     */
    smsEnabled: boolean;
    /**
     * WhatsApp notifications enabled
     */
    whatsappEnabled: boolean;
    /**
     * Telegram notifications enabled
     */
    telegramEnabled: boolean;
    /**
     * Push notifications enabled
     */
    pushEnabled: boolean;
    /**
     * Marketing notifications enabled
     */
    marketingEnabled: boolean;
    /**
     * Transactional notifications enabled
     */
    transactionalEnabled: boolean;
    /**
     * Security notifications enabled
     */
    securityEnabled: boolean;
    /**
     * System notifications enabled
     */
    systemEnabled: boolean;
    /**
     * Preferred email address
     */
    preferredEmail?: string;
    /**
     * Preferred phone number
     */
    preferredPhone?: string;
    /**
     * Preferred Telegram ID
     */
    preferredTelegramId?: string;
    /**
     * Quiet hours enabled
     */
    quietHoursEnabled: boolean;
    /**
     * Quiet hours start time (HH:mm format)
     */
    quietHoursStart?: string;
    /**
     * Quiet hours end time (HH:mm format)
     */
    quietHoursEnd?: string;
    /**
     * Quiet hours timezone (IANA format)
     */
    quietHoursTimezone?: string;
    /**
     * Timestamp when created
     */
    createdAt: string;
    /**
     * Timestamp when last updated
     */
    updatedAt: string;
};

/**
 * Notification preferences response
 */
export type NotificationPreferencesResponse = {
    data: NotificationPreferences;
    meta: ResponseMeta;
};

/**
 * Notification priority enum
 */
export type NotificationPriority = 'urgent' | 'high' | 'normal' | 'low';

/**
 * Notification recipient information
 */
export type NotificationRecipient = {
    /**
     * Email address (required for email channel)
     */
    email?: string;
    /**
     * Phone number in E.164 format (required for SMS/WhatsApp)
     */
    phone?: string;
    /**
     * Telegram chat ID (required for Telegram channel)
     */
    telegramId?: string;
};

/**
 * Single notification response
 */
export type NotificationResponse = {
    data: Notification;
    meta: ResponseMeta;
};

/**
 * Notification status enum
 */
export type NotificationStatus = 'pending' | 'queued' | 'processing' | 'sent' | 'delivered' | 'failed' | 'bounced';

/**
 * Organization type
 */
export type OrgType = 'clinic' | 'hospital' | 'polyclinic' | 'pharmacy' | 'laboratory';

/**
 * Organization (Tenant) resource
 *
 * Represents a healthcare facility such as clinic, hospital, or pharmacy.
 * All resources are scoped to an organization (multi-tenant).
 */
export type Organization = {
    /**
     * Unique organization identifier
     */
    id: string;
    /**
     * Organization code (unique per system)
     */
    orgCode: string;
    /**
     * Organization name
     */
    orgName: string;
    /**
     * Organization name in Indonesian (if different)
     */
    orgNameId?: string;
    /**
     * Organization type
     */
    orgType: OrgType;
    /**
     * Health facility license number
     */
    licenseNumber?: string;
    /**
     * NPWP (Tax ID)
     */
    npwp?: string;
    /**
     * BPJS PPK code
     */
    bpjsPpkCode?: string;
    /**
     * SatuSehat organization ID
     */
    satusehatOrgId?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Country (default: Indonesia)
     */
    country: string;
    /**
     * Phone number
     */
    phone?: string;
    /**
     * Email address
     */
    email?: string;
    /**
     * Website URL
     */
    website?: string;
    /**
     * Logo URL
     */
    logoUrl?: string;
    /**
     * Operating hours (JSON)
     */
    operatingHours?: {
        [key: string]: unknown;
    };
    /**
     * Whether organization is active
     */
    isActive: boolean;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * When synced to SatuSehat
     */
    satusehatSyncedAt?: string;
    /**
     * Soft delete status
     */
    isDeleted: boolean;
    /**
     * When soft deleted
     */
    deletedAt?: string;
    /**
     * Who deleted
     */
    deletedBy?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When last updated
     */
    updatedAt: string;
};

/**
 * Organization list response with pagination
 */
export type OrganizationListResponse = {
    /**
     * Array of resources
     */
    data: Array<Organization>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single organization response
 */
export type OrganizationResponse = {
    /**
     * The resource data
     */
    data: Organization;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Page-based pagination metadata for collection responses
 */
export type Pagination = {
    /**
     * Current page number (1-indexed)
     */
    page: number;
    /**
     * Number of items per page
     */
    pageSize: number;
    /**
     * Total number of pages
     */
    totalPages: number;
    /**
     * Total number of items across all pages
     */
    totalCount: number;
    /**
     * Whether there is a next page
     */
    hasNext: boolean;
    /**
     * Whether there is a previous page
     */
    hasPrevious: boolean;
    /**
     * Navigation links for pagination
     */
    links?: PaginationLinks;
    /**
     * Original requested page size (included if pageSize was capped)
     */
    requestedPageSize?: number;
};

/**
 * Pagination links for navigating through paginated results
 */
export type PaginationLinks = {
    /**
     * URL for the first page
     */
    first: string | null;
    /**
     * URL for the previous page (null if on first page)
     */
    previous: string | null;
    /**
     * URL for the next page (null if on last page)
     */
    next: string | null;
    /**
     * URL for the last page
     */
    last: string | null;
};

/**
 * Patient resource
 *
 * Represents a patient in the healthcare system.
 * Aligned with FHIR Patient resource for SatuSehat integration.
 */
export type Patient = {
    /**
     * Unique patient identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID (optional location scope)
     */
    branchId?: string;
    /**
     * Medical record number
     */
    medicalRecordNumber: string;
    /**
     * NIK (Indonesian National ID - 16 digits)
     */
    nik?: string;
    /**
     * BPJS number
     */
    bpjsNumber?: string;
    /**
     * SatuSehat IHS ID
     */
    satusehatIhsId?: string;
    /**
     * First name
     */
    firstName: string;
    /**
     * Last name
     */
    lastName: string;
    /**
     * First name in Indonesian (if different)
     */
    firstNameId?: string;
    /**
     * Last name in Indonesian
     */
    lastNameId?: string;
    /**
     * Full name (computed)
     */
    fullName: string;
    /**
     * Full name in Indonesian
     */
    fullNameId?: string;
    /**
     * Gender
     */
    gender: Gender;
    /**
     * Date of birth
     */
    dateOfBirth: string;
    /**
     * Place of birth
     */
    placeOfBirth?: string;
    /**
     * Marital status
     */
    maritalStatus?: MaritalStatus;
    /**
     * Blood type
     */
    bloodType?: BloodType;
    /**
     * Rhesus factor
     */
    rhesus?: Rhesus;
    /**
     * Religion
     */
    religion?: string;
    /**
     * Nationality (default: Indonesia)
     */
    nationality: string;
    /**
     * Country (default: Indonesia)
     */
    country?: string;
    /**
     * Education level
     */
    education?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Phone number
     */
    phone?: string;
    /**
     * Mobile number
     */
    mobile?: string;
    /**
     * Email address
     */
    email?: string;
    /**
     * Occupation
     */
    occupation?: string;
    /**
     * Emergency contact name
     */
    emergencyContactName?: string;
    /**
     * Emergency contact phone
     */
    emergencyContactPhone?: string;
    /**
     * Emergency contact relationship
     */
    emergencyContactRelationship?: string;
    /**
     * Photo URL
     */
    photoUrl?: string;
    /**
     * Patient status
     */
    status: PatientStatus;
    /**
     * JKN verification status
     */
    isJknVerified: boolean;
    /**
     * When JKN was verified
     */
    jknVerifiedAt?: string;
    /**
     * JKN verification error message
     */
    jknVerificationError?: string;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * When synced to SatuSehat
     */
    satusehatSyncedAt?: string;
    /**
     * SatuSehat sync error message
     */
    satusehatSyncError?: string;
    /**
     * Soft delete status
     */
    isDeleted: boolean;
    /**
     * When soft deleted
     */
    deletedAt?: string;
    /**
     * Who deleted
     */
    deletedBy?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When last updated
     */
    updatedAt: string;
};

/**
 * Patient allergy record
 */
export type PatientAllergy = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Allergy type
     */
    allergyType: AllergyType;
    /**
     * Allergen name
     */
    allergen: string;
    /**
     * Allergen in Indonesian
     */
    allergenId?: string;
    /**
     * Severity
     */
    severity: AllergySeverity;
    /**
     * Reaction description
     */
    reaction?: string;
    /**
     * Onset date
     */
    onsetDate?: string;
    /**
     * Whether allergy is still active
     */
    isActive: boolean;
    /**
     * Notes
     */
    notes?: string;
    /**
     * SatuSehat AllergyIntolerance ID
     */
    satusehatAllergyIntoleranceId?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Allergy list response
 */
export type PatientAllergyListResponse = {
    /**
     * Array of resources
     */
    data: Array<PatientAllergy>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single allergy response
 */
export type PatientAllergyResponse = {
    /**
     * The resource data
     */
    data: PatientAllergy;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Patient list response with pagination
 */
export type PatientListResponse = {
    /**
     * Array of resources
     */
    data: Array<Patient>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single patient response
 */
export type PatientResponse = {
    /**
     * The resource data
     */
    data: Patient;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Patient Safety Incident
 *
 * Insiden Keselamatan Pasien (IKP) tracking
 */
export type PatientSafetyIncident = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Incident number
     */
    incidentNumber: string;
    /**
     * Incident date/time
     */
    incidentDate: string;
    /**
     * Reported date/time
     */
    reportedDate: string;
    /**
     * Severity
     */
    severity: IncidentSeverity;
    /**
     * Status
     */
    status: IncidentStatus;
    /**
     * Location description
     */
    locationDescription?: string;
    /**
     * Department
     */
    department?: string;
    /**
     * Patient ID (optional)
     */
    patientId?: string;
    /**
     * Encounter ID (optional)
     */
    encounterId?: string;
    /**
     * Incident type
     */
    incidentType: string;
    /**
     * Incident description
     */
    incidentDescription: string;
    /**
     * Immediate action taken
     */
    immediateAction?: string;
    /**
     * Patient outcome
     */
    patientOutcome?: string;
    /**
     * Reported by user ID
     */
    reportedBy: string;
    /**
     * Involved staff
     */
    involvedStaff?: Array<{
        userId?: string;
        name: string;
        role: string;
        involvement: string;
    }>;
    /**
     * Witness information
     */
    witnessInfo?: Array<{
        name: string;
        role?: string;
        statement?: string;
    }>;
    /**
     * Investigation started at
     */
    investigationStartedAt?: string;
    /**
     * Investigation completed at
     */
    investigationCompletedAt?: string;
    /**
     * Investigated by user ID
     */
    investigatedBy?: string;
    /**
     * Root cause analysis
     */
    rootCauseAnalysis?: string;
    /**
     * Contributing factors
     */
    contributingFactors?: Array<string>;
    /**
     * Corrective actions
     */
    correctiveActions?: Array<{
        action: string;
        responsible: string;
        dueDate: string;
        status: string;
        completedDate?: string;
    }>;
    /**
     * Resolved at
     */
    resolvedAt?: string;
    /**
     * Resolved by user ID
     */
    resolvedBy?: string;
    /**
     * Lesson learned
     */
    lessonLearned?: string;
    /**
     * Preventive measures
     */
    preventiveMeasures?: string;
    /**
     * Whether reported to KNKP
     */
    isReportedToKnkp: boolean;
    /**
     * KNKP reported at
     */
    knkpReportedAt?: string;
    /**
     * KNKP report number
     */
    knkpReportNumber?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Patient safety incident list response
 */
export type PatientSafetyIncidentListResponse = {
    /**
     * Array of resources
     */
    data: Array<PatientSafetyIncident>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single patient safety incident response
 */
export type PatientSafetyIncidentResponse = {
    /**
     * The resource data
     */
    data: PatientSafetyIncident;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Patient status
 */
export type PatientStatus = 'active' | 'inactive' | 'deceased';

/**
 * Patient with related data (allergies, chronic conditions)
 */
export type PatientWithRelationsResponse = {
    data: {
        /**
         * Unique patient identifier
         */
        id: string;
        /**
         * Organization ID (tenant scope)
         */
        organizationId: string;
        /**
         * Branch ID (optional location scope)
         */
        branchId?: string;
        /**
         * Medical record number
         */
        medicalRecordNumber: string;
        /**
         * NIK (Indonesian National ID - 16 digits)
         */
        nik?: string;
        /**
         * BPJS number
         */
        bpjsNumber?: string;
        /**
         * SatuSehat IHS ID
         */
        satusehatIhsId?: string;
        /**
         * First name
         */
        firstName: string;
        /**
         * Last name
         */
        lastName: string;
        /**
         * First name in Indonesian (if different)
         */
        firstNameId?: string;
        /**
         * Last name in Indonesian
         */
        lastNameId?: string;
        /**
         * Full name (computed)
         */
        fullName: string;
        /**
         * Full name in Indonesian
         */
        fullNameId?: string;
        /**
         * Gender
         */
        gender: Gender;
        /**
         * Date of birth
         */
        dateOfBirth: string;
        /**
         * Place of birth
         */
        placeOfBirth?: string;
        /**
         * Marital status
         */
        maritalStatus?: MaritalStatus;
        /**
         * Blood type
         */
        bloodType?: BloodType;
        /**
         * Rhesus factor
         */
        rhesus?: Rhesus;
        /**
         * Religion
         */
        religion?: string;
        /**
         * Nationality (default: Indonesia)
         */
        nationality: string;
        /**
         * Country (default: Indonesia)
         */
        country?: string;
        /**
         * Education level
         */
        education?: string;
        /**
         * Address
         */
        address?: string;
        /**
         * City
         */
        city?: string;
        /**
         * Province
         */
        province?: string;
        /**
         * Postal code
         */
        postalCode?: string;
        /**
         * Phone number
         */
        phone?: string;
        /**
         * Mobile number
         */
        mobile?: string;
        /**
         * Email address
         */
        email?: string;
        /**
         * Occupation
         */
        occupation?: string;
        /**
         * Emergency contact name
         */
        emergencyContactName?: string;
        /**
         * Emergency contact phone
         */
        emergencyContactPhone?: string;
        /**
         * Emergency contact relationship
         */
        emergencyContactRelationship?: string;
        /**
         * Photo URL
         */
        photoUrl?: string;
        /**
         * Patient status
         */
        status: PatientStatus;
        /**
         * JKN verification status
         */
        isJknVerified: boolean;
        /**
         * When JKN was verified
         */
        jknVerifiedAt?: string;
        /**
         * JKN verification error message
         */
        jknVerificationError?: string;
        /**
         * SatuSehat sync status
         */
        isSatusehatSynced: boolean;
        /**
         * When synced to SatuSehat
         */
        satusehatSyncedAt?: string;
        /**
         * SatuSehat sync error message
         */
        satusehatSyncError?: string;
        /**
         * Soft delete status
         */
        isDeleted: boolean;
        /**
         * When soft deleted
         */
        deletedAt?: string;
        /**
         * Who deleted
         */
        deletedBy?: string;
        /**
         * When created
         */
        createdAt: string;
        /**
         * When last updated
         */
        updatedAt: string;
        allergies?: Array<PatientAllergy>;
        chronicConditions?: Array<ChronicCondition>;
    };
    meta: ResponseMeta;
};

/**
 * Payer type
 */
export type PayerType = 'selfPay' | 'bpjs' | 'insurance' | 'corporate';

/**
 * Payment
 *
 * Payment received for an invoice
 */
export type Payment = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Invoice ID
     */
    invoiceId: string;
    /**
     * Payment number
     */
    paymentNumber: string;
    /**
     * Payment date
     */
    paymentDate: string;
    /**
     * Payment method
     */
    paymentMethod: PaymentMethod;
    /**
     * Amount
     */
    amount: number;
    /**
     * Currency
     */
    currency: string;
    /**
     * Status
     */
    status: PaymentStatus;
    /**
     * Reference number (e.g., bank transfer ref)
     */
    referenceNumber?: string;
    /**
     * Card type (if card payment)
     */
    cardType?: string;
    /**
     * Last 4 digits (if card payment)
     */
    cardLast4?: string;
    /**
     * Bank name (if bank transfer)
     */
    bankName?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When verified
     */
    verifiedAt?: string;
    /**
     * Verified by user ID
     */
    verifiedBy?: string;
    /**
     * Received by user ID
     */
    receivedBy?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Payment list response
 */
export type PaymentListResponse = {
    /**
     * Array of resources
     */
    data: Array<Payment>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Payment method
 */
export type PaymentMethod = 'cash' | 'debit' | 'credit' | 'qris' | 'transfer' | 'deposit' | 'insurance' | 'bpjs';

/**
 * Single payment response
 */
export type PaymentResponse = {
    /**
     * The resource data
     */
    data: Payment;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Payment status
 */
export type PaymentStatus = 'completed' | 'partial' | 'cancelled' | 'refunded';

/**
 * Payment type
 */
export type PaymentType = 'selfPay' | 'jkn' | 'insurance' | 'corporate' | 'mixed';

/**
 * Permission definition
 *
 * Permissions define what actions can be performed on resources.
 * They support allow/deny effects and optional conditions.
 */
export type Permission = {
    /**
     * Resource identifier (e.g., "users", "invoices", "settings")
     */
    resource: string;
    /**
     * Action to perform on the resource
     */
    action: PermissionAction | string;
    /**
     * Whether to allow or deny this action
     */
    effect: PermissionEffect;
    /**
     * Optional condition for when this permission applies
     */
    condition?: PermissionCondition;
};

/**
 * Permission actions
 */
export type PermissionAction = 'read' | 'create' | 'update' | 'delete' | 'manage' | '*';

/**
 * Permission condition - when the permission applies
 *
 * Conditions enable dynamic, context-aware access control.
 */
export type PermissionCondition = '' | 'owner' | 'shared';

/**
 * Permission effect - whether to allow or deny access
 *
 * When a user has multiple roles, permissions are combined:
 * - If ANY role denies an action, it is denied (deny wins)
 * - If no role denies and ANY role allows, it is allowed
 * - If no rules match, access is denied (default deny)
 */
export type PermissionEffect = 'allow' | 'deny';

/**
 * Permission input for creating/updating roles
 */
export type PermissionInput = {
    /**
     * Resource identifier
     */
    resource: string;
    /**
     * Action to perform
     */
    action: string;
    /**
     * Effect (defaults to "allow" if not specified)
     */
    effect?: PermissionEffect;
    /**
     * Optional condition
     */
    condition?: PermissionCondition;
};

/**
 * Polyclinic resource
 *
 * Represents a department/unit within the organization
 */
export type Polyclinic = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Polyclinic code
     */
    polyclinicCode: string;
    /**
     * Polyclinic name
     */
    polyclinicName: string;
    /**
     * Polyclinic name in Indonesian
     */
    polyclinicNameId?: string;
    /**
     * Polyclinic type
     */
    polyclinicType: PolyclinicType;
    /**
     * Description
     */
    description?: string;
    /**
     * Physical location
     */
    location?: string;
    /**
     * Floor
     */
    floor?: string;
    /**
     * Queue prefix (e.g., "A", "B")
     */
    queuePrefix?: string;
    /**
     * SatuSehat location ID
     */
    satusehatLocationId?: string;
    /**
     * BPJS polyclinic code
     */
    bpjsPoliCode?: string;
    /**
     * Operating hours (JSON)
     */
    operatingHours?: {
        [key: string]: unknown;
    };
    /**
     * Whether polyclinic is active
     */
    isActive: boolean;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * When synced to SatuSehat
     */
    satusehatSyncedAt?: string;
    /**
     * SatuSehat sync error message
     */
    satusehatSyncError?: string;
    /**
     * JKN sync status
     */
    isJknSynced: boolean;
    /**
     * When synced to JKN
     */
    jknSyncedAt?: string;
    /**
     * JKN sync error message
     */
    jknSyncError?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Polyclinic list response
 */
export type PolyclinicListResponse = {
    /**
     * Array of resources
     */
    data: Array<Polyclinic>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single polyclinic response
 */
export type PolyclinicResponse = {
    /**
     * The resource data
     */
    data: Polyclinic;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Polyclinic type
 */
export type PolyclinicType = 'general' | 'dental' | 'kia' | 'specialist' | 'emergency' | 'lab' | 'pharmacy';

/**
 * Practitioner resource
 *
 * Represents healthcare providers such as doctors, nurses, etc.
 * Aligned with FHIR Practitioner resource for SatuSehat integration.
 */
export type Practitioner = {
    /**
     * Unique practitioner identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Practitioner number (unique)
     */
    practitionerNumber: string;
    /**
     * First name
     */
    firstName: string;
    /**
     * Last name
     */
    lastName: string;
    /**
     * First name in Indonesian
     */
    firstNameId?: string;
    /**
     * Last name in Indonesian
     */
    lastNameId?: string;
    /**
     * Full name (computed)
     */
    fullName: string;
    /**
     * Gender
     */
    gender?: Gender;
    /**
     * Date of birth
     */
    dateOfBirth?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Mobile
     */
    mobile?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Practitioner type
     */
    practitionerType: PractitionerType;
    /**
     * Medical specialty
     */
    specialty?: Specialty;
    /**
     * License number
     */
    licenseNumber?: string;
    /**
     * License expiry date
     */
    licenseExpiry?: string;
    /**
     * SatuSehat IHS ID
     */
    satusehatIhsId?: string;
    /**
     * NIP (Indonesian employee number)
     */
    nip?: string;
    /**
     * STR (Surat Tanda Registrasi)
     */
    str?: string;
    /**
     * SIP (Surat Izin Praktik)
     */
    sip?: string;
    /**
     * Photo URL
     */
    photoUrl?: string;
    /**
     * Bio
     */
    bio?: string;
    /**
     * Education history (JSON array)
     */
    education?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Certifications (JSON array)
     */
    certifications?: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Whether practitioner is active
     */
    isActive: boolean;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * When synced to SatuSehat
     */
    satusehatSyncedAt?: string;
    /**
     * SatuSehat sync error message
     */
    satusehatSyncError?: string;
    /**
     * JKN sync status
     */
    isJknSynced: boolean;
    /**
     * When synced to JKN
     */
    jknSyncedAt?: string;
    /**
     * JKN sync error message
     */
    jknSyncError?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Practitioner Credential
 *
 * STR, SIP, and other credentials verification
 */
export type PractitionerCredential = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Credential type
     */
    credentialType: CredentialType;
    /**
     * Credential number
     */
    credentialNumber: string;
    /**
     * Credential name
     */
    credentialName: string;
    /**
     * Issuing authority
     */
    issuingAuthority: string;
    /**
     * Issued date
     */
    issuedDate: string;
    /**
     * Expiry date
     */
    expiryDate?: string;
    /**
     * Status
     */
    status: CredentialStatus;
    /**
     * Verified at
     */
    verifiedAt?: string;
    /**
     * Verified by user ID
     */
    verifiedBy?: string;
    /**
     * Verification method
     */
    verificationMethod?: string;
    /**
     * Document URL
     */
    documentUrl?: string;
    /**
     * Document hash (SHA-256)
     */
    documentHash?: string;
    /**
     * Renewal reminder sent
     */
    renewalReminderSent: boolean;
    /**
     * Renewal reminder sent at
     */
    renewalReminderSentAt?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Practitioner credential list response
 */
export type PractitionerCredentialListResponse = {
    /**
     * Array of resources
     */
    data: Array<PractitionerCredential>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single practitioner credential response
 */
export type PractitionerCredentialResponse = {
    /**
     * The resource data
     */
    data: PractitionerCredential;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Practitioner list response
 */
export type PractitionerListResponse = {
    /**
     * Array of resources
     */
    data: Array<Practitioner>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single practitioner response
 */
export type PractitionerResponse = {
    /**
     * The resource data
     */
    data: Practitioner;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Practitioner schedule
 */
export type PractitionerSchedule = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Day of week
     */
    dayOfWeek: DayOfWeek;
    /**
     * Start time (HH:mm)
     */
    startTime: string;
    /**
     * End time (HH:mm)
     */
    endTime: string;
    /**
     * Whether schedule is available
     */
    isAvailable: boolean;
    /**
     * Effective from date
     */
    effectiveFrom: string;
    /**
     * Effective to date (null = ongoing)
     */
    effectiveTo?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Schedule list response
 */
export type PractitionerScheduleListResponse = {
    /**
     * Array of resources
     */
    data: Array<PractitionerSchedule>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single schedule response
 */
export type PractitionerScheduleResponse = {
    /**
     * The resource data
     */
    data: PractitionerSchedule;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Practitioner type
 */
export type PractitionerType = 'doctor' | 'nurse' | 'midwife' | 'pharmacist' | 'labTech' | 'radiologist' | 'specialist';

/**
 * Practitioner with schedules
 */
export type PractitionerWithSchedulesResponse = {
    data: {
        /**
         * Unique practitioner identifier
         */
        id: string;
        /**
         * Organization ID (tenant scope)
         */
        organizationId: string;
        /**
         * Branch ID
         */
        branchId?: string;
        /**
         * Practitioner number (unique)
         */
        practitionerNumber: string;
        /**
         * First name
         */
        firstName: string;
        /**
         * Last name
         */
        lastName: string;
        /**
         * First name in Indonesian
         */
        firstNameId?: string;
        /**
         * Last name in Indonesian
         */
        lastNameId?: string;
        /**
         * Full name (computed)
         */
        fullName: string;
        /**
         * Gender
         */
        gender?: Gender;
        /**
         * Date of birth
         */
        dateOfBirth?: string;
        /**
         * Phone
         */
        phone?: string;
        /**
         * Mobile
         */
        mobile?: string;
        /**
         * Email
         */
        email?: string;
        /**
         * Practitioner type
         */
        practitionerType: PractitionerType;
        /**
         * Medical specialty
         */
        specialty?: Specialty;
        /**
         * License number
         */
        licenseNumber?: string;
        /**
         * License expiry date
         */
        licenseExpiry?: string;
        /**
         * SatuSehat IHS ID
         */
        satusehatIhsId?: string;
        /**
         * NIP (Indonesian employee number)
         */
        nip?: string;
        /**
         * STR (Surat Tanda Registrasi)
         */
        str?: string;
        /**
         * SIP (Surat Izin Praktik)
         */
        sip?: string;
        /**
         * Photo URL
         */
        photoUrl?: string;
        /**
         * Bio
         */
        bio?: string;
        /**
         * Education history (JSON array)
         */
        education?: Array<{
            [key: string]: unknown;
        }>;
        /**
         * Certifications (JSON array)
         */
        certifications?: Array<{
            [key: string]: unknown;
        }>;
        /**
         * Whether practitioner is active
         */
        isActive: boolean;
        /**
         * SatuSehat sync status
         */
        isSatusehatSynced: boolean;
        /**
         * When synced to SatuSehat
         */
        satusehatSyncedAt?: string;
        /**
         * SatuSehat sync error message
         */
        satusehatSyncError?: string;
        /**
         * JKN sync status
         */
        isJknSynced: boolean;
        /**
         * When synced to JKN
         */
        jknSyncedAt?: string;
        /**
         * JKN sync error message
         */
        jknSyncError?: string;
        /**
         * When created
         */
        createdAt: string;
        /**
         * When updated
         */
        updatedAt: string;
        schedules?: Array<PractitionerSchedule>;
        polyclinics?: Array<Polyclinic>;
    };
    meta: ResponseMeta;
};

/**
 * Prescription record
 */
export type Prescription = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Encounter ID
     */
    encounterId: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Prescription number
     */
    prescriptionNumber: string;
    /**
     * Prescription status
     */
    status: PrescriptionStatus;
    /**
     * When prescribed
     */
    prescribedAt: string;
    /**
     * Prescribed by user ID
     */
    prescribedBy: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Dispense status
     */
    dispenseStatus: DispenseStatus;
    /**
     * When dispensed
     */
    dispensedAt?: string;
    /**
     * Sign-off status (for accreditation)
     */
    isSignedOff: boolean;
    /**
     * When signed off
     */
    signedOffAt?: string;
    /**
     * Signed off by user ID
     */
    signedOffBy?: string;
    /**
     * SatuSehat medication request ID
     */
    satusehatMedicationRequestId?: string;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * JKN sync status
     */
    isJknSynced: boolean;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Prescription item (single medication in prescription)
 */
export type PrescriptionItem = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Prescription ID
     */
    prescriptionId: string;
    /**
     * Medication ID (from pharmacy stock)
     */
    medicationId?: string;
    /**
     * Generic name
     */
    genericName: string;
    /**
     * Generic name in Indonesian
     */
    genericNameId?: string;
    /**
     * Brand name
     */
    brandName?: string;
    /**
     * Brand name in Indonesian
     */
    brandNameId?: string;
    /**
     * Dosage form
     */
    dosageForm: DosageForm;
    /**
     * Strength (e.g., "500mg")
     */
    strength?: string;
    /**
     * Unit (e.g., "tablet", "ml")
     */
    unit?: string;
    /**
     * Frequency
     */
    frequency: Frequency;
    /**
     * Frequency description (if other)
     */
    frequencyDescription?: string;
    /**
     * Route (e.g., "oral", "IV")
     */
    route?: string;
    /**
     * Duration in days
     */
    durationDays?: number;
    /**
     * Quantity
     */
    quantity: number;
    /**
     * Repeat count (refills)
     */
    repeatCount?: number;
    /**
     * Instructions
     */
    instructions?: string;
    /**
     * Dispense as written flag
     */
    dispenseAsWritten: boolean;
    /**
     * Whether this is a controlled substance
     */
    isControlled: boolean;
    /**
     * RxNorm code
     */
    rxNormCode?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Quantity dispensed
     */
    quantityDispensed?: number;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Prescription list response
 */
export type PrescriptionListResponse = {
    /**
     * Array of resources
     */
    data: Array<Prescription>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Prescription response
 */
export type PrescriptionResponse = {
    /**
     * The resource data
     */
    data: Prescription;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Prescription status
 */
export type PrescriptionStatus = 'draft' | 'active' | 'completed' | 'cancelled' | 'onHold';

/**
 * Procedure record
 */
export type Procedure = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Encounter ID
     */
    encounterId: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Procedure number
     */
    procedureNumber: string;
    /**
     * ICD-9-CM code
     */
    icd9cmCode?: string;
    /**
     * ICD-9-CM description
     */
    icd9cmDescription?: string;
    /**
     * Procedure name
     */
    procedureName: string;
    /**
     * Procedure name in Indonesian
     */
    procedureNameId?: string;
    /**
     * Procedure status
     */
    status: 'preparation' | 'inProgress' | 'completed' | 'notDone' | 'stopped';
    /**
     * Procedure category
     */
    category: 'surgical' | 'diagnostic' | 'therapeutic' | 'preventive' | 'palliative' | 'other';
    /**
     * When performed
     */
    performedAt: string;
    /**
     * Performed by user ID
     */
    performedBy: string;
    /**
     * Assisted by user IDs
     */
    assistedBy?: Array<string>;
    /**
     * Location/room
     */
    location?: string;
    /**
     * Body site
     */
    bodySite?: string;
    /**
     * Outcome
     */
    outcome?: string;
    /**
     * Complication
     */
    complication?: string;
    /**
     * Follow-up required
     */
    followUpRequired: boolean;
    /**
     * Notes
     */
    notes?: string;
    /**
     * Sign-off status
     */
    isSignedOff: boolean;
    /**
     * When signed off
     */
    signedOffAt?: string;
    /**
     * Signed off by
     */
    signedOffBy?: string;
    /**
     * SatuSehat procedure ID
     */
    satusehatProcedureId?: string;
    /**
     * SatuSehat sync status
     */
    isSatusehatSynced: boolean;
    /**
     * JKN sync status
     */
    isJknSynced: boolean;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Procedure list response
 */
export type ProcedureListResponse = {
    /**
     * Array of resources
     */
    data: Array<Procedure>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Procedure response
 */
export type ProcedureResponse = {
    /**
     * The resource data
     */
    data: Procedure;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Request body for processing refund
 */
export type ProcessRefundRequest = {
    /**
     * Reference number
     */
    referenceNumber?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Quality Indicator
 *
 * Definition of a quality metric for monitoring
 */
export type QualityIndicator = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Indicator code
     */
    indicatorCode: string;
    /**
     * Indicator name
     */
    indicatorName: string;
    /**
     * Indicator name in Indonesian
     */
    indicatorNameId?: string;
    /**
     * Category
     */
    category: QualityIndicatorCategory;
    /**
     * Description
     */
    description?: string;
    /**
     * Numerator definition
     */
    numeratorDefinition: string;
    /**
     * Denominator definition
     */
    denominatorDefinition: string;
    /**
     * Formula
     */
    formula?: string;
    /**
     * Unit
     */
    unit: string;
    /**
     * Target value
     */
    targetValue?: number;
    /**
     * Green threshold (good)
     */
    thresholdGreen?: number;
    /**
     * Yellow threshold (warning)
     */
    thresholdYellow?: number;
    /**
     * Red threshold (critical)
     */
    thresholdRed?: number;
    /**
     * Measurement frequency
     */
    measurementFrequency: string;
    /**
     * Whether active
     */
    isActive: boolean;
    /**
     * Effective from date
     */
    effectiveFrom?: string;
    /**
     * Effective to date
     */
    effectiveTo?: string;
    /**
     * Responsible department
     */
    responsibleDepartment?: string;
    /**
     * Responsible person ID
     */
    responsiblePerson?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Quality indicator category
 */
export type QualityIndicatorCategory = 'patientSafety' | 'clinicalOutcome' | 'operational' | 'patientExperience' | 'infectionControl' | 'medicationSafety' | 'surgicalSafety' | 'maternalChild' | 'emergency' | 'laboratory' | 'radiology';

/**
 * Quality indicator list response
 */
export type QualityIndicatorListResponse = {
    /**
     * Array of resources
     */
    data: Array<QualityIndicator>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single quality indicator response
 */
export type QualityIndicatorResponse = {
    /**
     * The resource data
     */
    data: QualityIndicator;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Quality Indicator Result
 *
 * Measurement result for a quality indicator
 */
export type QualityIndicatorResult = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Indicator ID
     */
    indicatorId: string;
    /**
     * Period start date
     */
    periodStart: string;
    /**
     * Period end date
     */
    periodEnd: string;
    /**
     * Period type
     */
    periodType: string;
    /**
     * Numerator value
     */
    numeratorValue: number;
    /**
     * Denominator value
     */
    denominatorValue: number;
    /**
     * Result value
     */
    resultValue: number;
    /**
     * Target value
     */
    targetValue?: number;
    /**
     * Whether target met
     */
    isTargetMet?: boolean;
    /**
     * Performance level (green, yellow, red)
     */
    performanceLevel?: string;
    /**
     * Analysis
     */
    analysis?: string;
    /**
     * Root cause
     */
    rootCause?: string;
    /**
     * Improvement plan
     */
    improvementPlan?: string;
    /**
     * Measured by user ID
     */
    measuredBy: string;
    /**
     * Measured at
     */
    measuredAt: string;
    /**
     * Verified by user ID
     */
    verifiedBy?: string;
    /**
     * Verified at
     */
    verifiedAt?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Quality indicator result list response
 */
export type QualityIndicatorResultListResponse = {
    /**
     * Array of resources
     */
    data: Array<QualityIndicatorResult>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single quality indicator result response
 */
export type QualityIndicatorResultResponse = {
    /**
     * The resource data
     */
    data: QualityIndicatorResult;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Queue entry
 *
 * Represents a patient's position in the queue
 */
export type Queue = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Appointment ID
     */
    appointmentId: string;
    /**
     * Polyclinic ID
     */
    polyclinicId: string;
    /**
     * Practitioner ID
     */
    practitionerId: string;
    /**
     * Queue date
     */
    queueDate: string;
    /**
     * Queue number
     */
    queueNumber: string;
    /**
     * Queue status
     */
    status: QueueStatus;
    /**
     * Priority
     */
    priority: QueuePriority;
    /**
     * Whether this is a walk-in queue
     */
    isWalkIn: boolean;
    /**
     * Whether this is an online queue
     */
    isOnline: boolean;
    /**
     * Estimated service time
     */
    estimatedServiceTime?: string;
    /**
     * Actual service start time
     */
    serviceStartedAt?: string;
    /**
     * Actual service end time
     */
    serviceEndedAt?: string;
    /**
     * Who called the queue
     */
    calledBy?: string;
    /**
     * When called
     */
    calledAt?: string;
    /**
     * Counter/room number
     */
    counterNumber?: string;
    /**
     * Wait time in minutes
     */
    waitTimeMinutes?: number;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Queue call log
 */
export type QueueCallLog = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Queue ID
     */
    queueId: string;
    /**
     * Called by user ID
     */
    calledBy: string;
    /**
     * When called
     */
    calledAt: string;
    /**
     * Counter number
     */
    counterNumber?: string;
    /**
     * Whether patient responded
     */
    responded: boolean;
    /**
     * Response time (when patient arrived at counter)
     */
    respondedAt?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Queue display info (for display boards)
 */
export type QueueDisplayResponse = {
    data: {
        /**
         * Current serving queue numbers by polyclinic
         */
        currentServing: Array<{
            polyclinicId: string;
            polyclinicName: string;
            queueNumber: string;
            counterNumber?: string;
        }>;
        /**
         * Waiting queues
         */
        waiting: Array<{
            queueNumber: string;
            polyclinicName: string;
            priority: QueuePriority;
            estimatedWaitMinutes?: number;
        }>;
        /**
         * Statistics
         */
        stats: {
            totalWaiting: number;
            totalServing: number;
            totalCompleted: number;
            averageWaitMinutes: number;
        };
    };
    meta: ResponseMeta;
};

/**
 * Queue list response
 */
export type QueueListResponse = {
    /**
     * Array of resources
     */
    data: Array<Queue>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Queue priority
 */
export type QueuePriority = 'routine' | 'urgent' | 'emergency';

/**
 * Single queue response
 */
export type QueueResponse = {
    /**
     * The resource data
     */
    data: Queue;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Queue status
 */
export type QueueStatus = 'waiting' | 'called' | 'serving' | 'completed' | 'skipped' | 'cancelled';

/**
 * Request body for receiving specimen
 */
export type ReceiveSpecimenRequest = {
    /**
     * Specimen condition on receipt
     */
    condition?: SpecimenCondition;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for recording quality indicator result
 */
export type RecordQualityIndicatorResultRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Indicator ID
     */
    indicatorId: string;
    /**
     * Period start
     */
    periodStart: string;
    /**
     * Period end
     */
    periodEnd: string;
    /**
     * Period type
     */
    periodType: string;
    /**
     * Numerator value
     */
    numeratorValue: number;
    /**
     * Denominator value
     */
    denominatorValue: number;
    /**
     * Analysis
     */
    analysis?: string;
    /**
     * Root cause
     */
    rootCause?: string;
    /**
     * Improvement plan
     */
    improvementPlan?: string;
};

/**
 * Request body for recording vital signs
 */
export type RecordVitalSignsRequest = {
    /**
     * Temperature (Celsius)
     */
    temperature?: number;
    /**
     * Heart rate (bpm)
     */
    heartRate?: number;
    /**
     * Systolic BP (mmHg)
     */
    systolicBp?: number;
    /**
     * Diastolic BP (mmHg)
     */
    diastolicBp?: number;
    /**
     * Respiratory rate
     */
    respiratoryRate?: number;
    /**
     * Oxygen saturation (%)
     */
    oxygenSaturation?: number;
    /**
     * Weight (kg)
     */
    weight?: number;
    /**
     * Height (cm)
     */
    height?: number;
    /**
     * Blood glucose (mg/dL)
     */
    bloodGlucose?: number;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Referral record
 */
export type Referral = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Encounter ID
     */
    encounterId: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Referral number
     */
    referralNumber: string;
    /**
     * Referral type
     */
    referralType: 'internal' | 'external' | 'bpjs';
    /**
     * Referred to facility name
     */
    referredToFacility?: string;
    /**
     * Referred to specialty
     */
    referredToSpecialty?: Specialty;
    /**
     * Referred to practitioner name
     */
    referredToPractitioner?: string;
    /**
     * Referral reason
     */
    referralReason?: string;
    /**
     * Diagnosis
     */
    diagnosis?: string;
    /**
     * BPJS rujukan number
     */
    bpjsRujukanNumber?: string;
    /**
     * Is urgent
     */
    isUrgent: boolean;
    /**
     * Status
     */
    status: 'pending' | 'accepted' | 'rejected' | 'completed';
    /**
     * Notes
     */
    notes?: string;
    /**
     * Sign-off status
     */
    isSignedOff: boolean;
    /**
     * When signed off
     */
    signedOffAt?: string;
    /**
     * Signed off by user ID
     */
    signedOffBy?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Referral list response
 */
export type ReferralListResponse = {
    /**
     * Array of resources
     */
    data: Array<Referral>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Referral response
 */
export type ReferralResponse = {
    /**
     * The resource data
     */
    data: Referral;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Refund
 *
 * Refund for a payment
 */
export type Refund = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Payment ID
     */
    paymentId: string;
    /**
     * Invoice ID
     */
    invoiceId: string;
    /**
     * Refund number
     */
    refundNumber: string;
    /**
     * Refund date
     */
    refundDate: string;
    /**
     * Amount
     */
    amount: number;
    /**
     * Currency
     */
    currency: string;
    /**
     * Reason
     */
    reason: string;
    /**
     * Status
     */
    status: RefundStatus;
    /**
     * Refund method
     */
    refundMethod?: PaymentMethod;
    /**
     * Reference number
     */
    referenceNumber?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When approved
     */
    approvedAt?: string;
    /**
     * Approved by user ID
     */
    approvedBy?: string;
    /**
     * When processed
     */
    processedAt?: string;
    /**
     * Processed by user ID
     */
    processedBy?: string;
    /**
     * When rejected
     */
    rejectedAt?: string;
    /**
     * Rejected by user ID
     */
    rejectedBy?: string;
    /**
     * Rejection reason
     */
    rejectionReason?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Refund list response
 */
export type RefundListResponse = {
    /**
     * Array of resources
     */
    data: Array<Refund>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single refund response
 */
export type RefundResponse = {
    /**
     * The resource data
     */
    data: Refund;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Refund status
 */
export type RefundStatus = 'requested' | 'approved' | 'processed' | 'rejected';

/**
 * Request body for rejecting refund
 */
export type RejectRefundRequest = {
    /**
     * Rejection reason
     */
    reason: string;
};

/**
 * Request body for reporting infection surveillance
 */
export type ReportInfectionSurveillanceRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Category
     */
    category: InfectionControlCategory;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Encounter ID
     */
    encounterId?: string;
    /**
     * Detection date
     */
    detectionDate: string;
    /**
     * Ward
     */
    ward?: string;
    /**
     * Room number
     */
    roomNumber?: string;
    /**
     * Infection site
     */
    infectionSite?: string;
    /**
     * Whether device-related
     */
    deviceRelated?: boolean;
    /**
     * Device type
     */
    deviceType?: string;
    /**
     * Whether surgery-related
     */
    surgeryRelated?: boolean;
    /**
     * Surgery type
     */
    surgeryType?: string;
};

/**
 * Request body for reporting patient safety incident
 */
export type ReportPatientSafetyIncidentRequest = {
    /**
     * Branch ID
     */
    branchId?: string;
    /**
     * Incident date
     */
    incidentDate: string;
    /**
     * Severity
     */
    severity: IncidentSeverity;
    /**
     * Location description
     */
    locationDescription?: string;
    /**
     * Department
     */
    department?: string;
    /**
     * Patient ID
     */
    patientId?: string;
    /**
     * Encounter ID
     */
    encounterId?: string;
    /**
     * Incident type
     */
    incidentType: string;
    /**
     * Incident description
     */
    incidentDescription: string;
    /**
     * Immediate action
     */
    immediateAction?: string;
    /**
     * Patient outcome
     */
    patientOutcome?: string;
};

/**
 * Request body for rescheduling
 */
export type RescheduleAppointmentRequest = {
    /**
     * New appointment date
     */
    appointmentDate: string;
    /**
     * New start time
     */
    startTime: string;
    /**
     * New end time
     */
    endTime?: string;
    /**
     * New practitioner ID
     */
    practitionerId?: string;
    /**
     * Reschedule reason
     */
    reason?: string;
};

/**
 * Response metadata included in all API responses
 */
export type ResponseMeta = {
    /**
     * Unique request identifier for tracking and debugging
     */
    requestId: string;
    /**
     * Timestamp when the response was generated
     */
    timestamp: string;
    /**
     * API version used for this request
     */
    apiVersion?: string;
    /**
     * Tenant/organization ID for multi-tenant requests
     */
    tenantId?: string;
    /**
     * Tenant/organization name for multi-tenant requests
     */
    tenantName?: string;
    /**
     * Processing time in milliseconds
     */
    durationMs?: number;
};

/**
 * Request body for retrying sync
 */
export type RetrySyncRequest = {
    /**
     * Sync queue IDs to retry
     */
    syncQueueIds: Array<string>;
    /**
     * Force retry even if max retries reached
     */
    force?: boolean;
};

/**
 * Rhesus factor
 */
export type Rhesus = 'positive' | 'negative';

/**
 * Role resource model
 *
 * Roles can be:
 * - **Global roles**: App-scoped (tenantId is null), apply across all tenants
 * - **Tenant roles**: Scoped to a specific organization
 *
 * Users can have multiple roles, and permissions are combined with
 * deny-override semantics.
 */
export type Role = {
    /**
     * Unique role identifier (format: role_abc123)
     */
    id: string;
    /**
     * Application this role belongs to
     */
    applicationId: string;
    /**
     * Tenant this role belongs to (null for global roles)
     */
    tenantId?: string;
    /**
     * Role name
     */
    name: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions granted by this role
     */
    permissions: Array<Permission>;
    /**
     * Whether this is a system-defined role (cannot be deleted or renamed)
     */
    isSystemRole: boolean;
    /**
     * Whether this is a global role (tenantId is null)
     */
    isGlobalRole: boolean;
    /**
     * Timestamp when the role was created
     */
    createdAt: string;
    /**
     * Timestamp when the role was last updated
     */
    updatedAt: string;
    /**
     * User who created this role
     */
    createdBy?: string;
};

/**
 * Role list response
 */
export type RoleListResponse = {
    data: Array<Role>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Single role response
 */
export type RoleResponse = {
    data: Role;
    meta: ResponseMeta;
};

/**
 * SatuSehat configuration per tenant
 *
 * Stores OAuth2 credentials and settings for SatuSehat FHIR integration.
 * Each organization can have its own SatuSehat credentials.
 */
export type SatusehatConfig = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Organization ID (tenant scope)
     */
    organizationId: string;
    /**
     * Branch ID (optional - config can be org-wide or branch-specific)
     */
    branchId?: string;
    /**
     * Environment (sandbox or production)
     */
    environment: 'sandbox' | 'production';
    /**
     * OAuth2 client ID
     */
    clientId: string;
    /**
     * OAuth2 client secret (masked in responses)
     */
    clientSecretMasked: string;
    /**
     * SatuSehat organization ID
     */
    satusehatOrgId?: string;
    /**
     * Auth URL
     */
    authUrl: string;
    /**
     * API base URL
     */
    apiUrl: string;
    /**
     * Whether config is active
     */
    isActive: boolean;
    /**
     * Last health check status
     */
    healthStatus: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
    /**
     * Last health check time
     */
    lastHealthCheckAt?: string;
    /**
     * Last successful sync time
     */
    lastSyncAt?: string;
    /**
     * Total resources synced
     */
    totalResourcesSynced?: number;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * SatuSehat config list response
 */
export type SatusehatConfigListResponse = {
    /**
     * Array of resources
     */
    data: Array<SatusehatConfig>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single SatuSehat config response
 */
export type SatusehatConfigResponse = {
    /**
     * The resource data
     */
    data: SatusehatConfig;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Request body for sending a notification
 */
export type SendNotificationRequest = {
    /**
     * Notification channel
     */
    channel: NotificationChannel;
    /**
     * Notification category
     */
    category: NotificationCategory;
    /**
     * Notification priority (default: normal)
     */
    priority?: NotificationPriority;
    /**
     * Recipient information
     */
    recipient: NotificationRecipient;
    /**
     * Template ID to use for rendering
     */
    templateId?: string;
    /**
     * Data for template rendering
     */
    templateData?: {
        [key: string]: unknown;
    };
    /**
     * Subject line (for email, required if not using template)
     */
    subject?: string;
    /**
     * Plain text body (required if not using template)
     */
    body?: string;
    /**
     * HTML body (for email)
     */
    bodyHtml?: string;
    /**
     * Custom metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
};

/**
 * Send notification success response
 */
export type SendNotificationResponse = {
    data: {
        /**
         * Message ID assigned to the notification
         */
        messageId: string;
        /**
         * Provider used to send
         */
        provider: string;
    };
    meta: ResponseMeta;
};

/**
 * Response for soft delete operations
 *
 * Includes resource ID, deletion metadata, and restore information
 */
export type SoftDeleteResponse = {
    data: {
        /**
         * ID of the deleted resource
         */
        id: string;
        /**
         * Timestamp when the resource was soft deleted
         */
        deletedAt: string;
        /**
         * User ID who performed the deletion
         */
        deletedBy: string;
        /**
         * Reason for deletion (optional, from request)
         */
        deletionReason?: string;
        /**
         * Whether the resource can be restored
         */
        canRestore: boolean;
        /**
         * Deadline for restoration (after which hard delete may occur)
         */
        restoreUntil?: string;
    };
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Medical specialty
 */
export type Specialty = 'generalPractice' | 'internalMedicine' | 'pediatrics' | 'obgyn' | 'surgery' | 'dentistry' | 'ophthalmology' | 'dermatology' | 'psychiatry' | 'radiology' | 'pathology' | 'other';

/**
 * Specimen
 *
 * Collected specimen for laboratory analysis
 */
export type Specimen = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Order item ID
     */
    orderItemId: string;
    /**
     * Specimen number
     */
    specimenNumber: string;
    /**
     * Specimen type
     */
    specimenType: string;
    /**
     * Collection date/time
     */
    collectionDate: string;
    /**
     * Collected by user ID
     */
    collectedBy: string;
    /**
     * Status
     */
    status: SpecimenStatus;
    /**
     * Specimen condition
     */
    condition?: SpecimenCondition;
    /**
     * When received at lab
     */
    receivedAt?: string;
    /**
     * Received by user ID
     */
    receivedBy?: string;
    /**
     * Notes
     */
    notes?: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Specimen condition
 */
export type SpecimenCondition = 'adequate' | 'hemolyzed' | 'lipemic' | 'icteric' | 'clotted' | 'insufficient' | 'contaminated';

/**
 * Specimen list response
 */
export type SpecimenListResponse = {
    /**
     * Array of resources
     */
    data: Array<Specimen>;
    /**
     * Pagination information
     */
    pagination: Pagination;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Single specimen response
 */
export type SpecimenResponse = {
    /**
     * The resource data
     */
    data: Specimen;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Specimen status
 */
export type SpecimenStatus = 'collected' | 'received' | 'processing' | 'analyzed' | 'rejected';

/**
 * Request to switch active context (application and/or tenant)
 */
export type SwitchContextRequest = {
    /**
     * Target application ID (optional, defaults to current)
     */
    applicationId?: string;
    /**
     * Target tenant ID (optional, null to clear tenant context)
     */
    tenantId?: string;
};

/**
 * Context switch response
 */
export type SwitchContextResponse = {
    data: {
        /**
         * New active application ID
         */
        applicationId: string;
        /**
         * New active tenant ID (null if no tenant)
         */
        tenantId?: string;
        /**
         * Tenant name (if tenant selected)
         */
        tenantName?: string;
        /**
         * Roles in the new context
         */
        roles: Array<string>;
        /**
         * Effective permissions in the new context
         */
        permissions: Array<Permission>;
    };
    meta: ResponseMeta;
};

/**
 * Request body for testing integration connection
 */
export type TestIntegrationRequest = {
    /**
     * Optional specific test to run
     */
    testType?: 'auth' | 'search' | 'full';
};

/**
 * Unread count response
 */
export type UnreadCountResponse = {
    data: {
        /**
         * Number of unread notifications
         */
        unreadCount: number;
    };
    meta: ResponseMeta;
};

/**
 * Request body for updating accreditation standard
 */
export type UpdateAccreditationStandardRequest = {
    /**
     * Current level
     */
    currentLevel?: AccreditationLevel;
    /**
     * Target level
     */
    targetLevel?: AccreditationLevel;
    /**
     * Status
     */
    status?: AccreditationStatus;
    /**
     * Next survey date
     */
    nextSurveyDate?: string;
    /**
     * Self-assessment score
     */
    selfAssessmentScore?: number;
    /**
     * Survey score
     */
    surveyScore?: number;
    /**
     * Surveyor organization
     */
    surveyorOrganization?: string;
    /**
     * Certificate number
     */
    certificateNumber?: string;
    /**
     * Certificate URL
     */
    certificateUrl?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating an appointment
 */
export type UpdateAppointmentRequest = {
    /**
     * Practitioner ID
     */
    practitionerId?: string;
    /**
     * Polyclinic ID
     */
    polyclinicId?: string;
    /**
     * Appointment date
     */
    appointmentDate?: string;
    /**
     * Start time
     */
    startTime?: string;
    /**
     * End time
     */
    endTime?: string;
    /**
     * Reason for visit
     */
    reasonForVisit?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating a branch
 */
export type UpdateBranchRequest = {
    /**
     * Branch name
     */
    branchName?: string;
    /**
     * Indonesian name
     */
    branchNameId?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Active status
     */
    isActive?: boolean;
};

/**
 * Request body for updating a chronic condition
 */
export type UpdateChronicConditionRequest = {
    /**
     * ICD-10 code
     */
    icd10Code?: string;
    /**
     * Condition name
     */
    conditionName?: string;
    /**
     * Condition name in Indonesian
     */
    conditionNameId?: string;
    /**
     * Diagnosis date
     */
    diagnosisDate?: string;
    /**
     * Is active
     */
    isActive?: boolean;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating a diagnosis
 */
export type UpdateDiagnosisRequest = {
    /**
     * ICD-10 code
     */
    icd10Code?: string;
    /**
     * ICD-10 description
     */
    icd10Description?: string;
    /**
     * Diagnosis name
     */
    diagnosisName?: string;
    /**
     * Diagnosis name in Indonesian
     */
    diagnosisNameId?: string;
    /**
     * Diagnosis type
     */
    diagnosisType?: DiagnosisType;
    /**
     * Verification status
     */
    verificationStatus?: DiagnosisVerification;
    /**
     * Is chronic
     */
    isChronic?: boolean;
    /**
     * Onset date
     */
    onsetDate?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating an encounter
 */
export type UpdateEncounterRequest = {
    /**
     * Status
     */
    status?: EncounterStatus;
    /**
     * Chief complaint
     */
    chiefComplaint?: string;
    /**
     * Reason for visit
     */
    reasonForVisit?: string;
    /**
     * Physical examination
     */
    physicalExamination?: {
        [key: string]: unknown;
    };
    /**
     * Assessment
     */
    assessment?: string;
    /**
     * Plan
     */
    plan?: string;
    /**
     * End time
     */
    endTime?: string;
};

/**
 * Request body for updating a comment
 */
export type UpdateExampleCommentRequest = {
    /**
     * Comment content (optional)
     */
    content?: string;
};

/**
 * Request body for updating a post
 */
export type UpdateExamplePostRequest = {
    /**
     * Post title (optional)
     */
    title?: string;
    /**
     * Post content (optional)
     */
    content?: string;
    /**
     * Post status (optional)
     */
    status?: ExamplePostStatus;
};

/**
 * Request to update file properties
 */
export type UpdateFileRequest = {
    /**
     * New access level
     */
    access?: FileAccess;
};

/**
 * Request body for updating invoice
 */
export type UpdateInvoiceRequest = {
    /**
     * Due date
     */
    dueDate?: string;
    /**
     * Discount percent
     */
    discountPercent?: number;
    /**
     * Discount reason
     */
    discountReason?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating JKN config
 */
export type UpdateJknConfigRequest = {
    /**
     * Environment
     */
    environment?: 'development' | 'production';
    /**
     * Consumer ID
     */
    consId?: string;
    /**
     * Secret key (only set if changing)
     */
    secretKey?: string;
    /**
     * User key (only set if changing)
     */
    userKey?: string;
    /**
     * PPK Pelayanan
     */
    ppkPelayanan?: string;
    /**
     * PPK BPJS
     */
    ppkBpjs?: string;
    /**
     * Facility type
     */
    facilityType?: BpjsFacilityType;
    /**
     * Base URL
     */
    baseUrl?: string;
    /**
     * Is active
     */
    isActive?: boolean;
};

/**
 * Request body for updating lab order status
 */
export type UpdateLabOrderStatusRequest = {
    /**
     * Status
     */
    status?: LabQueueStatus;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating a lab test
 */
export type UpdateLabTestRequest = {
    /**
     * Test name
     */
    testName?: string;
    /**
     * Test name in Indonesian
     */
    testNameId?: string;
    /**
     * Test category
     */
    testCategory?: LabTestCategory;
    /**
     * Test type
     */
    testType?: LabTestType;
    /**
     * Description
     */
    description?: string;
    /**
     * Specimen type
     */
    specimenType?: string;
    /**
     * Result type
     */
    resultType?: LabResultType;
    /**
     * Unit
     */
    unit?: string;
    /**
     * Normal range
     */
    normalRange?: string;
    /**
     * Is active
     */
    isActive?: boolean;
};

/**
 * Request body for updating an organization
 */
export type UpdateOrganizationRequest = {
    /**
     * Organization name
     */
    orgName?: string;
    /**
     * Indonesian name
     */
    orgNameId?: string;
    /**
     * License number
     */
    licenseNumber?: string;
    /**
     * NPWP
     */
    npwp?: string;
    /**
     * BPJS PPK code
     */
    bpjsPpkCode?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Website
     */
    website?: string;
    /**
     * Operating hours
     */
    operatingHours?: {
        [key: string]: unknown;
    };
    /**
     * Active status
     */
    isActive?: boolean;
};

/**
 * Request body for updating a patient allergy
 */
export type UpdatePatientAllergyRequest = {
    /**
     * Allergy type
     */
    allergyType?: AllergyType;
    /**
     * Allergen name
     */
    allergen?: string;
    /**
     * Allergen in Indonesian
     */
    allergenId?: string;
    /**
     * Severity
     */
    severity?: AllergySeverity;
    /**
     * Reaction description
     */
    reaction?: string;
    /**
     * Onset date
     */
    onsetDate?: string;
    /**
     * Is active
     */
    isActive?: boolean;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating a patient
 */
export type UpdatePatientRequest = {
    /**
     * First name
     */
    firstName?: string;
    /**
     * Last name
     */
    lastName?: string;
    /**
     * First name in Indonesian
     */
    firstNameId?: string;
    /**
     * Last name in Indonesian
     */
    lastNameId?: string;
    /**
     * BPJS number
     */
    bpjsNumber?: string;
    /**
     * Address
     */
    address?: string;
    /**
     * City
     */
    city?: string;
    /**
     * Province
     */
    province?: string;
    /**
     * Postal code
     */
    postalCode?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Mobile
     */
    mobile?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Occupation
     */
    occupation?: string;
    /**
     * Education level
     */
    education?: string;
    /**
     * Country
     */
    country?: string;
    /**
     * Emergency contact name
     */
    emergencyContactName?: string;
    /**
     * Emergency contact phone
     */
    emergencyContactPhone?: string;
    /**
     * Emergency contact relationship
     */
    emergencyContactRelationship?: string;
    /**
     * Status
     */
    status?: PatientStatus;
};

/**
 * Request body for updating a polyclinic
 */
export type UpdatePolyclinicRequest = {
    /**
     * Polyclinic name
     */
    polyclinicName?: string;
    /**
     * Indonesian name
     */
    polyclinicNameId?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Location
     */
    location?: string;
    /**
     * Floor
     */
    floor?: string;
    /**
     * Queue prefix
     */
    queuePrefix?: string;
    /**
     * BPJS poli code
     */
    bpjsPoliCode?: string;
    /**
     * Operating hours
     */
    operatingHours?: {
        [key: string]: unknown;
    };
    /**
     * Is active
     */
    isActive?: boolean;
};

/**
 * Request body for updating a practitioner
 */
export type UpdatePractitionerRequest = {
    /**
     * First name
     */
    firstName?: string;
    /**
     * Last name
     */
    lastName?: string;
    /**
     * Phone
     */
    phone?: string;
    /**
     * Mobile
     */
    mobile?: string;
    /**
     * Email
     */
    email?: string;
    /**
     * Specialty
     */
    specialty?: Specialty;
    /**
     * License number
     */
    licenseNumber?: string;
    /**
     * License expiry
     */
    licenseExpiry?: string;
    /**
     * NIP
     */
    nip?: string;
    /**
     * STR
     */
    str?: string;
    /**
     * SIP
     */
    sip?: string;
    /**
     * Bio
     */
    bio?: string;
    /**
     * Active status
     */
    isActive?: boolean;
};

/**
 * Request body for updating a schedule
 */
export type UpdatePractitionerScheduleRequest = {
    /**
     * Start time (HH:mm)
     */
    startTime?: string;
    /**
     * End time (HH:mm)
     */
    endTime?: string;
    /**
     * Is available
     */
    isAvailable?: boolean;
    /**
     * Effective to
     */
    effectiveTo?: string;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for updating notification preferences
 */
export type UpdatePreferencesRequest = {
    /**
     * Email notifications enabled
     */
    emailEnabled?: boolean;
    /**
     * SMS notifications enabled
     */
    smsEnabled?: boolean;
    /**
     * WhatsApp notifications enabled
     */
    whatsappEnabled?: boolean;
    /**
     * Telegram notifications enabled
     */
    telegramEnabled?: boolean;
    /**
     * Push notifications enabled
     */
    pushEnabled?: boolean;
    /**
     * Marketing notifications enabled
     */
    marketingEnabled?: boolean;
    /**
     * Transactional notifications enabled
     */
    transactionalEnabled?: boolean;
    /**
     * Security notifications enabled
     */
    securityEnabled?: boolean;
    /**
     * System notifications enabled
     */
    systemEnabled?: boolean;
    /**
     * Preferred email address
     */
    preferredEmail?: string;
    /**
     * Preferred phone number
     */
    preferredPhone?: string;
    /**
     * Preferred Telegram ID
     */
    preferredTelegramId?: string;
    /**
     * Quiet hours enabled
     */
    quietHoursEnabled?: boolean;
    /**
     * Quiet hours start time (HH:mm format)
     */
    quietHoursStart?: string;
    /**
     * Quiet hours end time (HH:mm format)
     */
    quietHoursEnd?: string;
    /**
     * Quiet hours timezone (IANA format)
     */
    quietHoursTimezone?: string;
};

/**
 * Request body for updating a procedure
 */
export type UpdateProcedureRequest = {
    /**
     * Status
     */
    status?: 'preparation' | 'inProgress' | 'completed' | 'notDone' | 'stopped';
    /**
     * Outcome
     */
    outcome?: string;
    /**
     * Complication
     */
    complication?: string;
    /**
     * Follow-up required
     */
    followUpRequired?: boolean;
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request to update a role
 */
export type UpdateRoleRequest = {
    /**
     * Role name
     */
    name?: string;
    /**
     * Role description
     */
    description?: string;
    /**
     * Permissions to grant (replaces existing permissions)
     */
    permissions?: Array<PermissionInput>;
};

/**
 * Request body for updating SatuSehat config
 */
export type UpdateSatusehatConfigRequest = {
    /**
     * Environment
     */
    environment?: 'sandbox' | 'production';
    /**
     * OAuth2 client ID
     */
    clientId?: string;
    /**
     * OAuth2 client secret (only set if changing)
     */
    clientSecret?: string;
    /**
     * SatuSehat organization ID
     */
    satusehatOrgId?: string;
    /**
     * Auth URL
     */
    authUrl?: string;
    /**
     * API URL
     */
    apiUrl?: string;
    /**
     * Is active
     */
    isActive?: boolean;
};

/**
 * Request to update a webhook
 */
export type UpdateWebhookRequest = {
    /**
     * URL to receive webhook payloads
     */
    url?: string;
    /**
     * Human-readable name
     */
    name?: string;
    /**
     * Description
     */
    description?: string;
    /**
     * Event types to subscribe to
     */
    events?: Array<string>;
    /**
     * Whether the webhook is active
     */
    isActive?: boolean;
};

/**
 * User's context across applications and tenants
 */
export type UserContext = {
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Application name
     */
    applicationName: string;
    /**
     * Tenant ID
     */
    tenantId: string;
    /**
     * Tenant name
     */
    tenantName: string;
    /**
     * Role names in this context
     */
    roles: Array<string>;
};

/**
 * User available contexts response (all apps/tenants user belongs to)
 */
export type UserContextListResponse = {
    data: Array<UserContext>;
    meta: ResponseMeta;
};

/**
 * User's effective permissions
 *
 * Represents the combined permissions from all roles assigned to a user
 * within a specific application and tenant context.
 */
export type UserEffectivePermissions = {
    /**
     * User ID
     */
    userId: string;
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Tenant ID (context for permission calculation)
     */
    tenantId?: string;
    /**
     * Global roles (app-scoped, no tenant)
     */
    globalRoles: Array<{
        /**
         * Role ID
         */
        id: string;
        /**
         * Role name
         */
        name: string;
        /**
         * Permissions from this role
         */
        permissions: Array<Permission>;
    }>;
    /**
     * Tenant-specific roles
     */
    tenantRoles: Array<{
        /**
         * Role ID
         */
        id: string;
        /**
         * Role name
         */
        name: string;
        /**
         * Permissions from this role
         */
        permissions: Array<Permission>;
    }>;
    /**
     * Combined effective permissions (after deny-override resolution)
     */
    effectivePermissions: Array<Permission>;
    /**
     * Simple list of allowed actions (for quick checks)
     */
    allowedActions: Array<string>;
};

/**
 * User effective permissions response
 */
export type UserEffectivePermissionsResponse = {
    data: UserEffectivePermissions;
    meta: ResponseMeta;
};

/**
 * User's role assignment
 *
 * Represents a single role assigned to a user within a specific
 * application and optional tenant context.
 */
export type UserRoleAssignment = {
    /**
     * Assignment ID
     */
    id: string;
    /**
     * User ID
     */
    userId: string;
    /**
     * Application ID
     */
    applicationId: string;
    /**
     * Tenant ID (null for global role assignments)
     */
    tenantId?: string;
    /**
     * Role ID
     */
    roleId: string;
    /**
     * Role name (denormalized for convenience)
     */
    roleName: string;
    /**
     * Whether this is a global role assignment
     */
    isGlobalRole: boolean;
    /**
     * When the role was assigned
     */
    assignedAt: string;
    /**
     * Who assigned the role
     */
    assignedBy?: string;
};

/**
 * User role assignments list response
 */
export type UserRoleAssignmentListResponse = {
    data: Array<UserRoleAssignment>;
    meta: ResponseMeta;
};

/**
 * User role assignment response
 */
export type UserRoleAssignmentResponse = {
    data: UserRoleAssignment;
    meta: ResponseMeta;
};

/**
 * Request body for verifying lab result
 */
export type VerifyLabResultRequest = {
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Request body for verifying payment
 */
export type VerifyPaymentRequest = {
    /**
     * Notes
     */
    notes?: string;
};

/**
 * Virus scan status for uploaded files
 */
export type VirusScanStatus = 'pending' | 'scanning' | 'clean' | 'infected' | 'failed';

/**
 * Vital Signs record
 */
export type VitalSigns = {
    /**
     * Unique identifier
     */
    id: string;
    /**
     * Encounter ID
     */
    encounterId: string;
    /**
     * Patient ID
     */
    patientId: string;
    /**
     * Temperature (Celsius)
     */
    temperature?: number;
    /**
     * Heart rate (bpm)
     */
    heartRate?: number;
    /**
     * Systolic blood pressure (mmHg)
     */
    systolicBp?: number;
    /**
     * Diastolic blood pressure (mmHg)
     */
    diastolicBp?: number;
    /**
     * Respiratory rate (per minute)
     */
    respiratoryRate?: number;
    /**
     * Oxygen saturation (%)
     */
    oxygenSaturation?: number;
    /**
     * Weight (kg)
     */
    weight?: number;
    /**
     * Height (cm)
     */
    height?: number;
    /**
     * BMI (calculated)
     */
    bmi?: number;
    /**
     * Blood glucose (mg/dL)
     */
    bloodGlucose?: number;
    /**
     * Notes
     */
    notes?: string;
    /**
     * SatuSehat observation ID
     */
    satusehatObservationId?: string;
    /**
     * When recorded
     */
    recordedAt: string;
    /**
     * Recorded by user ID
     */
    recordedBy: string;
    /**
     * When created
     */
    createdAt: string;
    /**
     * When updated
     */
    updatedAt: string;
};

/**
 * Vital signs response
 */
export type VitalSignsResponse = {
    /**
     * The resource data
     */
    data: VitalSigns;
    /**
     * Non-fatal warnings (e.g., deprecation notices)
     */
    warnings?: Array<Warning>;
    /**
     * Response metadata
     */
    meta: ResponseMeta;
};

/**
 * Request body for voiding invoice
 */
export type VoidInvoiceRequest = {
    /**
     * Void reason
     */
    reason: string;
};

/**
 * Warning message included in responses for non-fatal issues
 *
 * Examples: deprecated endpoints, capped page size, rate limit approaching
 */
export type Warning = {
    /**
     * Warning code (e.g., endpointDeprecated, pageSizeCapped)
     */
    code: string;
    /**
     * Human-readable warning message
     */
    message: string;
    /**
     * URL to documentation about this warning (optional)
     */
    documentationUrl?: string;
};

/**
 * Webhook configuration
 *
 * Defines an endpoint to receive event notifications.
 */
export type Webhook = {
    /**
     * Unique webhook identifier (format: wh_abc123)
     */
    id: string;
    /**
     * Tenant this webhook belongs to
     */
    tenantId: string;
    /**
     * URL to receive webhook payloads
     */
    url: string;
    /**
     * Human-readable name for this webhook
     */
    name?: string;
    /**
     * Description of what this webhook is used for
     */
    description?: string;
    /**
     * Event types to subscribe to (e.g., "user.created", "invoice.paid")
     */
    events: Array<string>;
    /**
     * Secret for HMAC-SHA256 signature verification (masked after creation)
     */
    secret: string;
    /**
     * Whether the webhook is currently active
     */
    isActive: boolean;
    /**
     * Number of consecutive failures (resets on success)
     */
    consecutiveFailures: number;
    /**
     * When the webhook was last triggered
     */
    lastTriggeredAt?: string;
    /**
     * When the webhook last succeeded
     */
    lastSuccessAt?: string;
    /**
     * When the webhook last failed
     */
    lastFailureAt?: string;
    /**
     * User who created this webhook
     */
    createdBy: string;
    /**
     * When the webhook was created
     */
    createdAt: string;
    /**
     * When the webhook was last updated
     */
    updatedAt: string;
};

/**
 * Webhook creation response (includes secret once)
 */
export type WebhookCreatedResponse = {
    data: WebhookWithSecret;
    meta: ResponseMeta;
};

/**
 * Webhook delivery attempt record
 *
 * Tracks each attempt to deliver a webhook payload.
 */
export type WebhookDelivery = {
    /**
     * Unique delivery identifier (format: whd_abc123)
     */
    id: string;
    /**
     * Webhook ID this delivery belongs to
     */
    webhookId: string;
    /**
     * Event ID that triggered this delivery
     */
    eventId: string;
    /**
     * Event type
     */
    eventType: string;
    /**
     * Delivery status
     */
    status: WebhookDeliveryStatus;
    /**
     * Number of delivery attempts made
     */
    attemptCount: number;
    /**
     * HTTP status code from last attempt (null if not yet attempted)
     */
    httpStatus?: number;
    /**
     * Response body from last attempt (truncated)
     */
    responseBody?: string;
    /**
     * Error message if failed
     */
    errorMessage?: string;
    /**
     * Duration of last request in milliseconds
     */
    durationMs?: number;
    /**
     * When the next retry will be attempted
     */
    nextRetryAt?: string;
    /**
     * When this delivery was created
     */
    createdAt: string;
    /**
     * When the delivery was last attempted
     */
    lastAttemptAt?: string;
    /**
     * When the delivery completed (success or exhausted)
     */
    completedAt?: string;
};

/**
 * Webhook delivery list response
 */
export type WebhookDeliveryListResponse = {
    data: Array<WebhookDelivery>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Webhook delivery response
 */
export type WebhookDeliveryResponse = {
    data: WebhookDelivery;
    meta: ResponseMeta;
};

/**
 * Webhook delivery status
 */
export type WebhookDeliveryStatus = 'pending' | 'delivered' | 'failed' | 'exhausted';

/**
 * Available webhook event types
 */
export type WebhookEventTypesResponse = {
    data: {
        /**
         * Available event types grouped by resource
         */
        eventTypes: {
            [key: string]: Array<string>;
        };
    };
    meta: ResponseMeta;
};

/**
 * Webhook list response
 */
export type WebhookListResponse = {
    data: Array<Webhook>;
    pagination: Pagination;
    meta: ResponseMeta;
};

/**
 * Webhook response (secret masked)
 */
export type WebhookResponse = {
    data: Webhook;
    meta: ResponseMeta;
};

/**
 * Webhook with unmasked secret (only returned on creation)
 */
export type WebhookWithSecret = {
    /**
     * Unique webhook identifier
     */
    id: string;
    /**
     * Tenant this webhook belongs to
     */
    tenantId: string;
    /**
     * URL to receive webhook payloads
     */
    url: string;
    /**
     * Webhook name
     */
    name?: string;
    /**
     * Event types subscribed to
     */
    events: Array<string>;
    /**
     * The webhook secret - ONLY RETURNED ONCE
     * Use this for signature verification
     */
    secret: string;
    /**
     * Whether the webhook is active
     */
    isActive: boolean;
    /**
     * When the webhook was created
     */
    createdAt: string;
};

export type HealthCheckData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};

export type HealthCheckResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Service status
         */
        status: 'ok' | 'degraded' | 'down';
        /**
         * Current timestamp
         */
        timestamp: string;
        /**
         * API version
         */
        version?: string;
        /**
         * Additional service information
         */
        services?: {
            database?: 'ok' | 'degraded' | 'down';
            cache?: 'ok' | 'degraded' | 'down';
            storage?: 'ok' | 'degraded' | 'down';
        };
    };
};

export type HealthCheckResponse = HealthCheckResponses[keyof HealthCheckResponses];

export type MigrationGetStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/migration/status';
};

export type MigrationGetStatusResponses = {
    /**
     * The request has succeeded.
     */
    200: MigrationStatusResponse;
};

export type MigrationGetStatusResponse = MigrationGetStatusResponses[keyof MigrationGetStatusResponses];

export type NotificationsListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Number of items to return (max: 100)
         */
        limit?: number;
        /**
         * Number of items to skip
         */
        offset?: number;
        /**
         * Filter by notification channel
         */
        channel?: NotificationChannel;
        /**
         * Filter by notification category
         */
        category?: NotificationCategory;
        /**
         * Filter by notification status
         */
        status?: NotificationStatus;
    };
    url: '/v1/notifications';
};

export type NotificationsListResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationListResponse | ErrorResponse;
};

export type NotificationsListResponse = NotificationsListResponses[keyof NotificationsListResponses];

export type NotificationsMarkAllReadData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/notifications/mark-all-read';
};

export type NotificationsMarkAllReadResponses = {
    /**
     * The request has succeeded.
     */
    200: MarkAllReadResponse | ErrorResponse;
};

export type NotificationsMarkAllReadResponse = NotificationsMarkAllReadResponses[keyof NotificationsMarkAllReadResponses];

export type NotificationsSendData = {
    body: SendNotificationRequest;
    path?: never;
    query?: never;
    url: '/v1/notifications/send';
};

export type NotificationsSendResponses = {
    /**
     * The request has succeeded.
     */
    200: SendNotificationResponse | ErrorResponse;
};

export type NotificationsSendResponse = NotificationsSendResponses[keyof NotificationsSendResponses];

export type NotificationsGetUnreadCountData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/notifications/unread/count';
};

export type NotificationsGetUnreadCountResponses = {
    /**
     * The request has succeeded.
     */
    200: UnreadCountResponse | ErrorResponse;
};

export type NotificationsGetUnreadCountResponse = NotificationsGetUnreadCountResponses[keyof NotificationsGetUnreadCountResponses];

export type NotificationsDeleteData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}';
};

export type NotificationsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsDeleteResponse = NotificationsDeleteResponses[keyof NotificationsDeleteResponses];

export type NotificationsGetData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}';
};

export type NotificationsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationResponse | ErrorResponse;
};

export type NotificationsGetResponse = NotificationsGetResponses[keyof NotificationsGetResponses];

export type NotificationsMarkReadData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/read';
};

export type NotificationsMarkReadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsMarkReadResponse = NotificationsMarkReadResponses[keyof NotificationsMarkReadResponses];

export type NotificationsRestoreData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/restore';
};

export type NotificationsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsRestoreResponse = NotificationsRestoreResponses[keyof NotificationsRestoreResponses];

export type NotificationsMarkUnreadData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/v1/notifications/{id}/unread';
};

export type NotificationsMarkUnreadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type NotificationsMarkUnreadResponse = NotificationsMarkUnreadResponses[keyof NotificationsMarkUnreadResponses];

export type OrganizationsListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by type
         */
        type?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by name
         */
        search?: string;
    };
    url: '/v1/organizations';
};

export type OrganizationsListResponses = {
    /**
     * The request has succeeded.
     */
    200: OrganizationListResponse | ErrorResponse;
};

export type OrganizationsListResponse = OrganizationsListResponses[keyof OrganizationsListResponses];

export type OrganizationsCreateData = {
    body: CreateOrganizationRequest;
    path?: never;
    query?: never;
    url: '/v1/organizations';
};

export type OrganizationsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: OrganizationResponse;
};

export type OrganizationsCreateResponse = OrganizationsCreateResponses[keyof OrganizationsCreateResponses];

export type OrganizationsDeleteData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/organizations/{orgId}';
};

export type OrganizationsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type OrganizationsDeleteResponse = OrganizationsDeleteResponses[keyof OrganizationsDeleteResponses];

export type OrganizationsGetData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/organizations/{orgId}';
};

export type OrganizationsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: OrganizationResponse | ErrorResponse;
};

export type OrganizationsGetResponse = OrganizationsGetResponses[keyof OrganizationsGetResponses];

export type OrganizationsUpdateData = {
    body: UpdateOrganizationRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/organizations/{orgId}';
};

export type OrganizationsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: OrganizationResponse | ErrorResponse;
};

export type OrganizationsUpdateResponse = OrganizationsUpdateResponses[keyof OrganizationsUpdateResponses];

export type AccreditationStandardsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by accreditation body
         */
        accreditationBody?: string;
        /**
         * Filter by status
         */
        status?: string;
    };
    url: '/v1/orgs/{orgId}/accreditation';
};

export type AccreditationStandardsListResponses = {
    /**
     * The request has succeeded.
     */
    200: AccreditationStandardListResponse | ErrorResponse;
};

export type AccreditationStandardsListResponse = AccreditationStandardsListResponses[keyof AccreditationStandardsListResponses];

export type AccreditationStandardsCreateData = {
    body: CreateAccreditationStandardRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/accreditation';
};

export type AccreditationStandardsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: AccreditationStandardResponse;
};

export type AccreditationStandardsCreateResponse = AccreditationStandardsCreateResponses[keyof AccreditationStandardsCreateResponses];

export type AccreditationStandardsGetData = {
    body?: never;
    path: {
        orgId: string;
        accreditationId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/accreditation/{accreditationId}';
};

export type AccreditationStandardsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: AccreditationStandardResponse | ErrorResponse;
};

export type AccreditationStandardsGetResponse = AccreditationStandardsGetResponses[keyof AccreditationStandardsGetResponses];

export type AccreditationStandardsUpdateData = {
    body: UpdateAccreditationStandardRequest;
    path: {
        orgId: string;
        accreditationId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/accreditation/{accreditationId}';
};

export type AccreditationStandardsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: AccreditationStandardResponse | ErrorResponse;
};

export type AccreditationStandardsUpdateResponse = AccreditationStandardsUpdateResponses[keyof AccreditationStandardsUpdateResponses];

export type AppointmentsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by patient
         */
        patientId?: string;
        /**
         * Filter by practitioner
         */
        practitionerId?: string;
        /**
         * Filter by polyclinic
         */
        polyclinicId?: string;
        /**
         * Filter by date
         */
        date?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
        /**
         * Filter by status
         */
        status?: string;
    };
    url: '/v1/orgs/{orgId}/appointments';
};

export type AppointmentsListResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentListResponse | ErrorResponse;
};

export type AppointmentsListResponse = AppointmentsListResponses[keyof AppointmentsListResponses];

export type AppointmentsCreateData = {
    body: CreateAppointmentRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/appointments';
};

export type AppointmentsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: AppointmentResponse;
};

export type AppointmentsCreateResponse = AppointmentsCreateResponses[keyof AppointmentsCreateResponses];

export type AppointmentsGetData = {
    body?: never;
    path: {
        orgId: string;
        appointmentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/appointments/{appointmentId}';
};

export type AppointmentsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentResponse | ErrorResponse;
};

export type AppointmentsGetResponse = AppointmentsGetResponses[keyof AppointmentsGetResponses];

export type AppointmentsUpdateData = {
    body: UpdateAppointmentRequest;
    path: {
        orgId: string;
        appointmentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/appointments/{appointmentId}';
};

export type AppointmentsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentResponse | ErrorResponse;
};

export type AppointmentsUpdateResponse = AppointmentsUpdateResponses[keyof AppointmentsUpdateResponses];

export type AppointmentsCancelData = {
    body: CancelAppointmentRequest;
    path: {
        orgId: string;
        appointmentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/appointments/{appointmentId}/cancel';
};

export type AppointmentsCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentResponse | ErrorResponse;
};

export type AppointmentsCancelResponse = AppointmentsCancelResponses[keyof AppointmentsCancelResponses];

export type AppointmentsCheckInData = {
    body: CheckInRequest;
    path: {
        orgId: string;
        appointmentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/appointments/{appointmentId}/check-in';
};

export type AppointmentsCheckInResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentResponse | ErrorResponse;
};

export type AppointmentsCheckInResponse = AppointmentsCheckInResponses[keyof AppointmentsCheckInResponses];

export type AppointmentsNoShowData = {
    body?: never;
    path: {
        orgId: string;
        appointmentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/appointments/{appointmentId}/no-show';
};

export type AppointmentsNoShowResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentResponse | ErrorResponse;
};

export type AppointmentsNoShowResponse = AppointmentsNoShowResponses[keyof AppointmentsNoShowResponses];

export type AppointmentsRescheduleData = {
    body: RescheduleAppointmentRequest;
    path: {
        orgId: string;
        appointmentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/appointments/{appointmentId}/reschedule';
};

export type AppointmentsRescheduleResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentResponse | ErrorResponse;
};

export type AppointmentsRescheduleResponse = AppointmentsRescheduleResponses[keyof AppointmentsRescheduleResponses];

export type AuditLogsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Filter by event type (e.g., "user.created", "user.*")
         */
        eventType?: string;
        /**
         * Filter by actor ID
         */
        actorId?: string;
        /**
         * Filter by actor type
         */
        actorType?: AuditActorType;
        /**
         * Filter by resource type (e.g., "user", "invoice")
         */
        resourceType?: string;
        /**
         * Filter by resource ID
         */
        resourceId?: string;
        /**
         * Filter events after this timestamp
         */
        timestampAfter?: string;
        /**
         * Filter events before this timestamp
         */
        timestampBefore?: string;
        /**
         * Filter by IP address
         */
        ipAddress?: string;
        /**
         * Filter by request ID
         */
        requestId?: string;
    };
    url: '/v1/orgs/{orgId}/audit-logs';
};

export type AuditLogsListResponses = {
    /**
     * The request has succeeded.
     */
    200: AuditLogListResponse | ErrorResponse;
};

export type AuditLogsListResponse = AuditLogsListResponses[keyof AuditLogsListResponses];

export type AuditLogsExportData = {
    /**
     * Export configuration
     */
    body: {
        /**
         * Export format
         */
        format: 'csv' | 'json';
        /**
         * Filter events after this timestamp
         */
        timestampAfter?: string;
        /**
         * Filter events before this timestamp
         */
        timestampBefore?: string;
        /**
         * Event types to include (empty = all)
         */
        eventTypes?: Array<string>;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/audit-logs/export';
};

export type AuditLogsExportResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        data: {
            /**
             * Download URL (signed, expires in 1 hour)
             */
            downloadUrl: string;
            /**
             * Number of events exported
             */
            eventCount: number;
            /**
             * When the URL expires
             */
            expiresAt: string;
        };
        meta: ResponseMeta;
    } | ErrorResponse;
    /**
     * The request has been accepted for processing, but processing has not yet completed.
     */
    202: AsyncJobResponse;
};

export type AuditLogsExportResponse = AuditLogsExportResponses[keyof AuditLogsExportResponses];

export type AuditLogsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Event ID
         */
        eventId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/audit-logs/{eventId}';
};

export type AuditLogsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: AuditLogResponse | ErrorResponse;
};

export type AuditLogsGetResponse = AuditLogsGetResponses[keyof AuditLogsGetResponses];

export type BranchesListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by name
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/branches';
};

export type BranchesListResponses = {
    /**
     * The request has succeeded.
     */
    200: BranchListResponse | ErrorResponse;
};

export type BranchesListResponse = BranchesListResponses[keyof BranchesListResponses];

export type BranchesCreateData = {
    body: CreateBranchRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/branches';
};

export type BranchesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: BranchResponse;
};

export type BranchesCreateResponse = BranchesCreateResponses[keyof BranchesCreateResponses];

export type BranchesDeleteData = {
    body?: never;
    path: {
        orgId: string;
        branchId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/branches/{branchId}';
};

export type BranchesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type BranchesDeleteResponse = BranchesDeleteResponses[keyof BranchesDeleteResponses];

export type BranchesGetData = {
    body?: never;
    path: {
        orgId: string;
        branchId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/branches/{branchId}';
};

export type BranchesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: BranchResponse | ErrorResponse;
};

export type BranchesGetResponse = BranchesGetResponses[keyof BranchesGetResponses];

export type BranchesUpdateData = {
    body: UpdateBranchRequest;
    path: {
        orgId: string;
        branchId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/branches/{branchId}';
};

export type BranchesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: BranchResponse | ErrorResponse;
};

export type BranchesUpdateResponse = BranchesUpdateResponses[keyof BranchesUpdateResponses];

export type ClinicalAuditsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by audit type
         */
        auditType?: string;
        /**
         * Filter by status
         */
        status?: string;
    };
    url: '/v1/orgs/{orgId}/clinical-audits';
};

export type ClinicalAuditsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ClinicalAuditListResponse | ErrorResponse;
};

export type ClinicalAuditsListResponse = ClinicalAuditsListResponses[keyof ClinicalAuditsListResponses];

export type ClinicalAuditsCreateData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/clinical-audits';
};

export type ClinicalAuditsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ClinicalAuditResponse;
};

export type ClinicalAuditsCreateResponse = ClinicalAuditsCreateResponses[keyof ClinicalAuditsCreateResponses];

export type ClinicalAuditsGetData = {
    body?: never;
    path: {
        orgId: string;
        auditId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/clinical-audits/{auditId}';
};

export type ClinicalAuditsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ClinicalAuditResponse | ErrorResponse;
};

export type ClinicalAuditsGetResponse = ClinicalAuditsGetResponses[keyof ClinicalAuditsGetResponses];

export type ClinicalAuditsApproveData = {
    body?: never;
    path: {
        orgId: string;
        auditId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/clinical-audits/{auditId}/approve';
};

export type ClinicalAuditsApproveResponses = {
    /**
     * The request has succeeded.
     */
    200: ClinicalAuditResponse | ErrorResponse;
};

export type ClinicalAuditsApproveResponse = ClinicalAuditsApproveResponses[keyof ClinicalAuditsApproveResponses];

export type ClinicalAuditsCompleteData = {
    body?: never;
    path: {
        orgId: string;
        auditId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/clinical-audits/{auditId}/complete';
};

export type ClinicalAuditsCompleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ClinicalAuditResponse | ErrorResponse;
};

export type ClinicalAuditsCompleteResponse = ClinicalAuditsCompleteResponses[keyof ClinicalAuditsCompleteResponses];

export type DiagnosticReportsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by patient
         */
        patientId?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/diagnostic-reports';
};

export type DiagnosticReportsListResponses = {
    /**
     * The request has succeeded.
     */
    200: DiagnosticReportListResponse | ErrorResponse;
};

export type DiagnosticReportsListResponse = DiagnosticReportsListResponses[keyof DiagnosticReportsListResponses];

export type DiagnosticReportsCreateData = {
    body: CreateDiagnosticReportRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/diagnostic-reports';
};

export type DiagnosticReportsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: DiagnosticReportResponse;
};

export type DiagnosticReportsCreateResponse = DiagnosticReportsCreateResponses[keyof DiagnosticReportsCreateResponses];

export type DiagnosticReportsGetData = {
    body?: never;
    path: {
        orgId: string;
        reportId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/diagnostic-reports/{reportId}';
};

export type DiagnosticReportsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: DiagnosticReportResponse | ErrorResponse;
};

export type DiagnosticReportsGetResponse = DiagnosticReportsGetResponses[keyof DiagnosticReportsGetResponses];

export type DiagnosticReportsFinalizeData = {
    body?: never;
    path: {
        orgId: string;
        reportId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/diagnostic-reports/{reportId}/finalize';
};

export type DiagnosticReportsFinalizeResponses = {
    /**
     * The request has succeeded.
     */
    200: DiagnosticReportResponse | ErrorResponse;
};

export type DiagnosticReportsFinalizeResponse = DiagnosticReportsFinalizeResponses[keyof DiagnosticReportsFinalizeResponses];

export type DocumentControlsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by document type
         */
        documentType?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter by department
         */
        department?: string;
    };
    url: '/v1/orgs/{orgId}/documents';
};

export type DocumentControlsListResponses = {
    /**
     * The request has succeeded.
     */
    200: DocumentControlListResponse | ErrorResponse;
};

export type DocumentControlsListResponse = DocumentControlsListResponses[keyof DocumentControlsListResponses];

export type DocumentControlsCreateData = {
    body: CreateDocumentControlRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/documents';
};

export type DocumentControlsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: DocumentControlResponse;
};

export type DocumentControlsCreateResponse = DocumentControlsCreateResponses[keyof DocumentControlsCreateResponses];

export type DocumentControlsGetData = {
    body?: never;
    path: {
        orgId: string;
        documentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/documents/{documentId}';
};

export type DocumentControlsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: DocumentControlResponse | ErrorResponse;
};

export type DocumentControlsGetResponse = DocumentControlsGetResponses[keyof DocumentControlsGetResponses];

export type DocumentControlsApproveData = {
    body?: never;
    path: {
        orgId: string;
        documentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/documents/{documentId}/approve';
};

export type DocumentControlsApproveResponses = {
    /**
     * The request has succeeded.
     */
    200: DocumentControlResponse | ErrorResponse;
};

export type DocumentControlsApproveResponse = DocumentControlsApproveResponses[keyof DocumentControlsApproveResponses];

export type DocumentControlsPublishData = {
    body?: never;
    path: {
        orgId: string;
        documentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/documents/{documentId}/publish';
};

export type DocumentControlsPublishResponses = {
    /**
     * The request has succeeded.
     */
    200: DocumentControlResponse | ErrorResponse;
};

export type DocumentControlsPublishResponse = DocumentControlsPublishResponses[keyof DocumentControlsPublishResponses];

export type DocumentControlsRetireData = {
    body?: never;
    path: {
        orgId: string;
        documentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/documents/{documentId}/retire';
};

export type DocumentControlsRetireResponses = {
    /**
     * The request has succeeded.
     */
    200: DocumentControlResponse | ErrorResponse;
};

export type DocumentControlsRetireResponse = DocumentControlsRetireResponses[keyof DocumentControlsRetireResponses];

export type DocumentControlsSubmitForReviewData = {
    body?: never;
    path: {
        orgId: string;
        documentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/documents/{documentId}/submit-for-review';
};

export type DocumentControlsSubmitForReviewResponses = {
    /**
     * The request has succeeded.
     */
    200: DocumentControlResponse | ErrorResponse;
};

export type DocumentControlsSubmitForReviewResponse = DocumentControlsSubmitForReviewResponses[keyof DocumentControlsSubmitForReviewResponses];

export type EncountersListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by patient
         */
        patientId?: string;
        /**
         * Filter by practitioner
         */
        practitionerId?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter by encounter class
         */
        encounterClass?: string;
    };
    url: '/v1/orgs/{orgId}/encounters';
};

export type EncountersListResponses = {
    /**
     * The request has succeeded.
     */
    200: EncounterListResponse | ErrorResponse;
};

export type EncountersListResponse = EncountersListResponses[keyof EncountersListResponses];

export type EncountersCreateData = {
    body: CreateEncounterRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters';
};

export type EncountersCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: EncounterResponse;
};

export type EncountersCreateResponse = EncountersCreateResponses[keyof EncountersCreateResponses];

export type EncountersGetData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}';
};

export type EncountersGetResponses = {
    /**
     * The request has succeeded.
     */
    200: EncounterResponse | ErrorResponse;
};

export type EncountersGetResponse = EncountersGetResponses[keyof EncountersGetResponses];

export type EncountersUpdateData = {
    body: UpdateEncounterRequest;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}';
};

export type EncountersUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: EncounterResponse | ErrorResponse;
};

export type EncountersUpdateResponse = EncountersUpdateResponses[keyof EncountersUpdateResponses];

export type EncountersCancelData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/cancel';
};

export type EncountersCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: EncounterResponse | ErrorResponse;
};

export type EncountersCancelResponse = EncountersCancelResponses[keyof EncountersCancelResponses];

export type EncountersCompleteData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/complete';
};

export type EncountersCompleteResponses = {
    /**
     * The request has succeeded.
     */
    200: EncounterResponse | ErrorResponse;
};

export type EncountersCompleteResponse = EncountersCompleteResponses[keyof EncountersCompleteResponses];

export type DiagnosesListData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/diagnoses';
};

export type DiagnosesListResponses = {
    /**
     * The request has succeeded.
     */
    200: DiagnosisListResponse | ErrorResponse;
};

export type DiagnosesListResponse = DiagnosesListResponses[keyof DiagnosesListResponses];

export type DiagnosesCreateData = {
    body: CreateDiagnosisRequest;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/diagnoses';
};

export type DiagnosesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: DiagnosisResponse;
};

export type DiagnosesCreateResponse = DiagnosesCreateResponses[keyof DiagnosesCreateResponses];

export type DiagnosesDeleteData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
        diagnosisId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/diagnoses/{diagnosisId}';
};

export type DiagnosesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type DiagnosesDeleteResponse = DiagnosesDeleteResponses[keyof DiagnosesDeleteResponses];

export type DiagnosesUpdateData = {
    body: UpdateDiagnosisRequest;
    path: {
        orgId: string;
        encounterId: string;
        diagnosisId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/diagnoses/{diagnosisId}';
};

export type DiagnosesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: DiagnosisResponse | ErrorResponse;
};

export type DiagnosesUpdateResponse = DiagnosesUpdateResponses[keyof DiagnosesUpdateResponses];

export type PrescriptionsListData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/prescriptions';
};

export type PrescriptionsListResponses = {
    /**
     * The request has succeeded.
     */
    200: PrescriptionListResponse | ErrorResponse;
};

export type PrescriptionsListResponse = PrescriptionsListResponses[keyof PrescriptionsListResponses];

export type PrescriptionsCreateData = {
    body: CreatePrescriptionRequest;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/prescriptions';
};

export type PrescriptionsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PrescriptionResponse;
};

export type PrescriptionsCreateResponse = PrescriptionsCreateResponses[keyof PrescriptionsCreateResponses];

export type PrescriptionsGetData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
        prescriptionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/prescriptions/{prescriptionId}';
};

export type PrescriptionsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PrescriptionResponse | ErrorResponse;
};

export type PrescriptionsGetResponse = PrescriptionsGetResponses[keyof PrescriptionsGetResponses];

export type PrescriptionsCancelData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
        prescriptionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/prescriptions/{prescriptionId}/cancel';
};

export type PrescriptionsCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: PrescriptionResponse | ErrorResponse;
};

export type PrescriptionsCancelResponse = PrescriptionsCancelResponses[keyof PrescriptionsCancelResponses];

export type PrescriptionsSignOffData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
        prescriptionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/prescriptions/{prescriptionId}/sign-off';
};

export type PrescriptionsSignOffResponses = {
    /**
     * The request has succeeded.
     */
    200: PrescriptionResponse | ErrorResponse;
};

export type PrescriptionsSignOffResponse = PrescriptionsSignOffResponses[keyof PrescriptionsSignOffResponses];

export type ProceduresListData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/procedures';
};

export type ProceduresListResponses = {
    /**
     * The request has succeeded.
     */
    200: ProcedureListResponse | ErrorResponse;
};

export type ProceduresListResponse = ProceduresListResponses[keyof ProceduresListResponses];

export type ProceduresCreateData = {
    body: CreateProcedureRequest;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/procedures';
};

export type ProceduresCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ProcedureResponse;
};

export type ProceduresCreateResponse = ProceduresCreateResponses[keyof ProceduresCreateResponses];

export type ProceduresUpdateData = {
    body: UpdateProcedureRequest;
    path: {
        orgId: string;
        encounterId: string;
        procedureId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/procedures/{procedureId}';
};

export type ProceduresUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ProcedureResponse | ErrorResponse;
};

export type ProceduresUpdateResponse = ProceduresUpdateResponses[keyof ProceduresUpdateResponses];

export type ProceduresCompleteData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
        procedureId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/procedures/{procedureId}/complete';
};

export type ProceduresCompleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ProcedureResponse | ErrorResponse;
};

export type ProceduresCompleteResponse = ProceduresCompleteResponses[keyof ProceduresCompleteResponses];

export type ReferralsListData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/referrals';
};

export type ReferralsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ReferralListResponse | ErrorResponse;
};

export type ReferralsListResponse = ReferralsListResponses[keyof ReferralsListResponses];

export type ReferralsCreateData = {
    body: CreateReferralRequest;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/referrals';
};

export type ReferralsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ReferralResponse;
};

export type ReferralsCreateResponse = ReferralsCreateResponses[keyof ReferralsCreateResponses];

export type ReferralsGetData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
        referralId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/referrals/{referralId}';
};

export type ReferralsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ReferralResponse | ErrorResponse;
};

export type ReferralsGetResponse = ReferralsGetResponses[keyof ReferralsGetResponses];

export type VitalSignsApiGetData = {
    body?: never;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/vital-signs';
};

export type VitalSignsApiGetResponses = {
    /**
     * The request has succeeded.
     */
    200: VitalSignsResponse | ErrorResponse;
};

export type VitalSignsApiGetResponse = VitalSignsApiGetResponses[keyof VitalSignsApiGetResponses];

export type VitalSignsApiUpdateData = {
    body: RecordVitalSignsRequest;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/vital-signs';
};

export type VitalSignsApiUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: VitalSignsResponse | ErrorResponse;
};

export type VitalSignsApiUpdateResponse = VitalSignsApiUpdateResponses[keyof VitalSignsApiUpdateResponses];

export type VitalSignsApiCreateData = {
    body: RecordVitalSignsRequest;
    path: {
        orgId: string;
        encounterId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/encounters/{encounterId}/vital-signs';
};

export type VitalSignsApiCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: VitalSignsResponse;
};

export type VitalSignsApiCreateResponse = VitalSignsApiCreateResponses[keyof VitalSignsApiCreateResponses];

export type ExamplePostsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-createdAt,title" for desc createdAt, then asc title)
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return (e.g., "id,title,status")
         */
        fields?: string;
        /**
         * Comma-separated list of relations to include (e.g., "comments")
         */
        include?: string;
        /**
         * Full-text search query
         */
        search?: string;
        /**
         * Filter by post status (exact match)
         */
        status?: ExamplePostStatus;
        /**
         * Filter by status NOT equal to value
         */
        statusNe?: string;
        /**
         * Filter by status IN list (comma-separated values)
         */
        statusIn?: string;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Filter by title contains
         */
        titleContains?: string;
        /**
         * Filter by content contains
         */
        contentContains?: string;
        /**
         * Filter posts created after this timestamp
         */
        createdAfter?: string;
        /**
         * Filter posts created before this timestamp
         */
        createdBefore?: string;
        /**
         * Filter posts published after this timestamp
         */
        publishedAfter?: string;
        /**
         * Filter posts published before this timestamp
         */
        publishedBefore?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts';
};

export type ExamplePostsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostListResponse | ErrorResponse;
};

export type ExamplePostsListResponse = ExamplePostsListResponses[keyof ExamplePostsListResponses];

export type ExamplePostsCreateData = {
    /**
     * Post creation data
     */
    body: CreateExamplePostRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts';
};

export type ExamplePostsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ExamplePostResponse;
};

export type ExamplePostsCreateResponse = ExamplePostsCreateResponses[keyof ExamplePostsCreateResponses];

export type ExamplePostsBatchUpdateData = {
    /**
     * Batch update request
     */
    body: {
        items?: Array<{
            id: string;
            updates: UpdateExamplePostRequest;
        }>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch';
};

export type ExamplePostsBatchUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type ExamplePostsBatchUpdateResponse = ExamplePostsBatchUpdateResponses[keyof ExamplePostsBatchUpdateResponses];

export type ExamplePostsBatchCreateData = {
    /**
     * Batch create request
     */
    body: {
        items: Array<CreateExamplePostRequest>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch';
};

export type ExamplePostsBatchCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * Generic batch response envelope
     *
     * Uses results array with status field for each item, matching documentation
     */
    201: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    };
};

export type ExamplePostsBatchCreateResponse = ExamplePostsBatchCreateResponses[keyof ExamplePostsBatchCreateResponses];

export type ExamplePostsBatchRestoreData = {
    /**
     * Post IDs to restore
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch/restore';
};

export type ExamplePostsBatchRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExamplePost;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type ExamplePostsBatchRestoreResponse = ExamplePostsBatchRestoreResponses[keyof ExamplePostsBatchRestoreResponses];

export type ExamplePostsBatchSoftDeleteData = {
    /**
     * Post IDs to soft delete
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/batch/soft-delete';
};

export type ExamplePostsBatchSoftDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: BatchDeleteResponse | ErrorResponse;
};

export type ExamplePostsBatchSoftDeleteResponse = ExamplePostsBatchSoftDeleteResponses[keyof ExamplePostsBatchSoftDeleteResponses];

export type ExamplePostsListCursorData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Cursor for fetching next page (post ID from previous response)
         */
        cursor?: string;
        /**
         * Maximum items to return (max: 100, default: 50)
         */
        limit?: number;
        /**
         * Sort order (e.g., "-createdAt" for desc, "createdAt" for asc)
         */
        orderBy?: string;
        /**
         * Filter by post status
         */
        status?: ExamplePostStatus;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Full-text search query
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/cursor';
};

export type ExamplePostsListCursorResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostCursorListResponse | ErrorResponse;
};

export type ExamplePostsListCursorResponse = ExamplePostsListCursorResponses[keyof ExamplePostsListCursorResponses];

export type ExamplePostsListDeletedData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Items per page (max 100)
         */
        pageSize?: number;
    };
    url: '/v1/orgs/{orgId}/example-posts/deleted';
};

export type ExamplePostsListDeletedResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostListResponse | ErrorResponse;
};

export type ExamplePostsListDeletedResponse = ExamplePostsListDeletedResponses[keyof ExamplePostsListDeletedResponses];

export type ExamplePostsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ExamplePostsDeleteResponse = ExamplePostsDeleteResponses[keyof ExamplePostsDeleteResponses];

export type ExamplePostsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Comma-separated list of relations to include
         */
        include?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsGetResponse = ExamplePostsGetResponses[keyof ExamplePostsGetResponses];

export type ExamplePostsUpdateData = {
    /**
     * Post update data
     */
    body: UpdateExamplePostRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}';
};

export type ExamplePostsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsUpdateResponse = ExamplePostsUpdateResponses[keyof ExamplePostsUpdateResponses];

export type ExamplePostsDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}/permanent';
};

export type ExamplePostsDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type ExamplePostsDeletePermanentResponse = ExamplePostsDeletePermanentResponses[keyof ExamplePostsDeletePermanentResponses];

export type ExamplePostsRestoreData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Post ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{id}/restore';
};

export type ExamplePostsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ExamplePostResponse | ErrorResponse;
};

export type ExamplePostsRestoreResponse = ExamplePostsRestoreResponses[keyof ExamplePostsRestoreResponses];

export type ExampleCommentsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-createdAt" for newest first)
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Filter by author ID
         */
        authorId?: string;
        /**
         * Filter by content contains
         */
        contentContains?: string;
        /**
         * Filter comments created after this timestamp
         */
        createdAfter?: string;
        /**
         * Filter comments created before this timestamp
         */
        createdBefore?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments';
};

export type ExampleCommentsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentListResponse | ErrorResponse;
};

export type ExampleCommentsListResponse = ExampleCommentsListResponses[keyof ExampleCommentsListResponses];

export type ExampleCommentsCreateData = {
    /**
     * Comment creation data
     */
    body: CreateExampleCommentRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments';
};

export type ExampleCommentsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ExampleCommentResponse;
};

export type ExampleCommentsCreateResponse = ExampleCommentsCreateResponses[keyof ExampleCommentsCreateResponses];

export type ExampleCommentsBatchCreateData = {
    /**
     * Batch create request
     */
    body: {
        items: Array<CreateExampleCommentRequest>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch';
};

export type ExampleCommentsBatchCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * Generic batch response envelope
     *
     * Uses results array with status field for each item, matching documentation
     */
    201: {
        /**
         * Results for each item in the batch
         */
        results: Array<{
            /**
             * Index of the item in the original request array
             */
            index: number;
            /**
             * Status of the operation for this item
             */
            status: 'success' | 'error' | 'skipped';
            /**
             * The created/updated data (present if status is success)
             */
            data?: ExampleComment;
            /**
             * Error details (present if status is error)
             */
            error?: {
                /**
                 * Error code
                 */
                code: string;
                /**
                 * Error message
                 */
                message: string;
            };
            /**
             * Original input (included for failed items to help with retry/debugging)
             */
            input?: {
                [key: string]: unknown;
            };
        }>;
        /**
         * Summary of operation results
         */
        summary: BatchSummary;
        /**
         * Response metadata
         */
        meta: ResponseMeta;
    };
};

export type ExampleCommentsBatchCreateResponse = ExampleCommentsBatchCreateResponses[keyof ExampleCommentsBatchCreateResponses];

export type ExampleCommentsBatchSoftDeleteData = {
    /**
     * Comment IDs to soft delete
     */
    body: {
        ids: Array<string>;
        options?: BatchOptions;
    };
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/batch/soft-delete';
};

export type ExampleCommentsBatchSoftDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: BatchDeleteResponse | ErrorResponse;
};

export type ExampleCommentsBatchSoftDeleteResponse = ExampleCommentsBatchSoftDeleteResponses[keyof ExampleCommentsBatchSoftDeleteResponses];

export type ExampleCommentsDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: SoftDeleteResponse | ErrorResponse;
};

export type ExampleCommentsDeleteResponse = ExampleCommentsDeleteResponses[keyof ExampleCommentsDeleteResponses];

export type ExampleCommentsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
    };
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsGetResponse = ExampleCommentsGetResponses[keyof ExampleCommentsGetResponses];

export type ExampleCommentsUpdateData = {
    /**
     * Comment update data
     */
    body: UpdateExampleCommentRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}';
};

export type ExampleCommentsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsUpdateResponse = ExampleCommentsUpdateResponses[keyof ExampleCommentsUpdateResponses];

export type ExampleCommentsDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/permanent';
};

export type ExampleCommentsDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type ExampleCommentsDeletePermanentResponse = ExampleCommentsDeletePermanentResponses[keyof ExampleCommentsDeletePermanentResponses];

export type ExampleCommentsRestoreData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Parent post ID
         */
        postId: string;
        /**
         * Comment ID
         */
        id: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/example-posts/{postId}/example-comments/{id}/restore';
};

export type ExampleCommentsRestoreResponses = {
    /**
     * The request has succeeded.
     */
    200: ExampleCommentResponse | ErrorResponse;
};

export type ExampleCommentsRestoreResponse = ExampleCommentsRestoreResponses[keyof ExampleCommentsRestoreResponses];

export type FilesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page (max: 100)
         */
        pageSize?: number;
        /**
         * Sort order (e.g., "-uploadedAt,filename")
         */
        orderBy?: string;
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
        /**
         * Filter by MIME type
         */
        mimeType?: string;
        /**
         * Filter by virus scan status
         */
        virusScanStatus?: VirusScanStatus;
        /**
         * Filter by access level
         */
        access?: FileAccess;
        /**
         * Filter files uploaded after this timestamp
         */
        uploadedAfter?: string;
        /**
         * Filter files uploaded before this timestamp
         */
        uploadedBefore?: string;
        /**
         * Filter by uploader user ID
         */
        uploadedBy?: string;
    };
    url: '/v1/orgs/{orgId}/files';
};

export type FilesListResponses = {
    /**
     * The request has succeeded.
     */
    200: FileListResponse | ErrorResponse;
};

export type FilesListResponse = FilesListResponses[keyof FilesListResponses];

export type FilesDirectUploadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files';
};

export type FilesDirectUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: FileResponse;
};

export type FilesDirectUploadResponse = FilesDirectUploadResponses[keyof FilesDirectUploadResponses];

export type FilesInitiateUploadData = {
    /**
     * Upload request with file metadata
     */
    body: InitiateUploadRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/uploads';
};

export type FilesInitiateUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: InitiateUploadResponse | ErrorResponse;
};

export type FilesInitiateUploadResponse = FilesInitiateUploadResponses[keyof FilesInitiateUploadResponses];

export type FilesConfirmUploadData = {
    /**
     * Confirmation data
     */
    body: ConfirmUploadRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Upload ID from initiate response
         */
        uploadId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/uploads/{uploadId}/confirm';
};

export type FilesConfirmUploadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: FileResponse;
};

export type FilesConfirmUploadResponse = FilesConfirmUploadResponses[keyof FilesConfirmUploadResponses];

export type FilesDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: FileDeleteResponse | ErrorResponse;
};

export type FilesDeleteResponse = FilesDeleteResponses[keyof FilesDeleteResponses];

export type FilesGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: {
        /**
         * Comma-separated list of fields to return
         */
        fields?: string;
    };
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: FileResponse | ErrorResponse;
};

export type FilesGetResponse = FilesGetResponses[keyof FilesGetResponses];

export type FilesUpdateData = {
    /**
     * Update request
     */
    body: UpdateFileRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}';
};

export type FilesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: FileResponse | ErrorResponse;
};

export type FilesUpdateResponse = FilesUpdateResponses[keyof FilesUpdateResponses];

export type FilesDownloadData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}/download';
};

export type FilesDownloadResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
};

export type FilesDownloadResponse = FilesDownloadResponses[keyof FilesDownloadResponses];

export type FilesDeletePermanentData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * File ID
         */
        fileId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/files/{fileId}/permanent';
};

export type FilesDeletePermanentResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type FilesDeletePermanentResponse = FilesDeletePermanentResponses[keyof FilesDeletePermanentResponses];

export type InfectionSurveillancesListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by category
         */
        category?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/infection-surveillance';
};

export type InfectionSurveillancesListResponses = {
    /**
     * The request has succeeded.
     */
    200: InfectionSurveillanceListResponse | ErrorResponse;
};

export type InfectionSurveillancesListResponse = InfectionSurveillancesListResponses[keyof InfectionSurveillancesListResponses];

export type InfectionSurveillancesReportData = {
    body: ReportInfectionSurveillanceRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/infection-surveillance';
};

export type InfectionSurveillancesReportResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: InfectionSurveillanceResponse;
};

export type InfectionSurveillancesReportResponse = InfectionSurveillancesReportResponses[keyof InfectionSurveillancesReportResponses];

export type InfectionSurveillancesGetData = {
    body?: never;
    path: {
        orgId: string;
        caseId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/infection-surveillance/{caseId}';
};

export type InfectionSurveillancesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: InfectionSurveillanceResponse | ErrorResponse;
};

export type InfectionSurveillancesGetResponse = InfectionSurveillancesGetResponses[keyof InfectionSurveillancesGetResponses];

export type InfectionSurveillancesConfirmData = {
    body?: never;
    path: {
        orgId: string;
        caseId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/infection-surveillance/{caseId}/confirm';
};

export type InfectionSurveillancesConfirmResponses = {
    /**
     * The request has succeeded.
     */
    200: InfectionSurveillanceResponse | ErrorResponse;
};

export type InfectionSurveillancesConfirmResponse = InfectionSurveillancesConfirmResponses[keyof InfectionSurveillancesConfirmResponses];

export type InfectionSurveillancesResolveData = {
    body?: never;
    path: {
        orgId: string;
        caseId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/infection-surveillance/{caseId}/resolve';
};

export type InfectionSurveillancesResolveResponses = {
    /**
     * The request has succeeded.
     */
    200: InfectionSurveillanceResponse | ErrorResponse;
};

export type InfectionSurveillancesResolveResponse = InfectionSurveillancesResolveResponses[keyof InfectionSurveillancesResolveResponses];

export type IntegrationDashboardGetData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Filter by branch
         */
        branchId?: string;
    };
    url: '/v1/orgs/{orgId}/integrations/dashboard';
};

export type IntegrationDashboardGetResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationDashboardResponse | ErrorResponse;
};

export type IntegrationDashboardGetResponse = IntegrationDashboardGetResponses[keyof IntegrationDashboardGetResponses];

export type IntegrationErrorLogsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by integration type
         */
        integrationType?: string;
        /**
         * Filter by error category
         */
        errorCategory?: string;
        /**
         * Filter by resolution status
         */
        resolution?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/integrations/error-logs';
};

export type IntegrationErrorLogsListResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationErrorLogListResponse | ErrorResponse;
};

export type IntegrationErrorLogsListResponse = IntegrationErrorLogsListResponses[keyof IntegrationErrorLogsListResponses];

export type IntegrationErrorLogsGetData = {
    body?: never;
    path: {
        orgId: string;
        logId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/error-logs/{logId}';
};

export type IntegrationErrorLogsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationErrorLogResponse | ErrorResponse;
};

export type IntegrationErrorLogsGetResponse = IntegrationErrorLogsGetResponses[keyof IntegrationErrorLogsGetResponses];

export type IntegrationErrorLogsIgnoreData = {
    body?: never;
    path: {
        orgId: string;
        logId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/error-logs/{logId}/ignore';
};

export type IntegrationErrorLogsIgnoreResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationErrorLogResponse | ErrorResponse;
};

export type IntegrationErrorLogsIgnoreResponse = IntegrationErrorLogsIgnoreResponses[keyof IntegrationErrorLogsIgnoreResponses];

export type IntegrationErrorLogsResolveData = {
    body?: never;
    path: {
        orgId: string;
        logId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/error-logs/{logId}/resolve';
};

export type IntegrationErrorLogsResolveResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationErrorLogResponse | ErrorResponse;
};

export type IntegrationErrorLogsResolveResponse = IntegrationErrorLogsResolveResponses[keyof IntegrationErrorLogsResolveResponses];

export type JknConfigsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by API type
         */
        apiType?: string;
        /**
         * Filter by environment
         */
        environment?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
    };
    url: '/v1/orgs/{orgId}/integrations/jkn';
};

export type JknConfigsListResponses = {
    /**
     * The request has succeeded.
     */
    200: JknConfigListResponse | ErrorResponse;
};

export type JknConfigsListResponse = JknConfigsListResponses[keyof JknConfigsListResponses];

export type JknConfigsCreateData = {
    body: CreateJknConfigRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/jkn';
};

export type JknConfigsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: JknConfigResponse;
};

export type JknConfigsCreateResponse = JknConfigsCreateResponses[keyof JknConfigsCreateResponses];

export type JknConfigsDeleteData = {
    body?: never;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/jkn/{configId}';
};

export type JknConfigsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type JknConfigsDeleteResponse = JknConfigsDeleteResponses[keyof JknConfigsDeleteResponses];

export type JknConfigsGetData = {
    body?: never;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/jkn/{configId}';
};

export type JknConfigsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: JknConfigResponse | ErrorResponse;
};

export type JknConfigsGetResponse = JknConfigsGetResponses[keyof JknConfigsGetResponses];

export type JknConfigsUpdateData = {
    body: UpdateJknConfigRequest;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/jkn/{configId}';
};

export type JknConfigsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: JknConfigResponse | ErrorResponse;
};

export type JknConfigsUpdateResponse = JknConfigsUpdateResponses[keyof JknConfigsUpdateResponses];

export type JknConfigsTestData = {
    body: TestIntegrationRequest;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/jkn/{configId}/test';
};

export type JknConfigsTestResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationTestResponse | ErrorResponse;
};

export type JknConfigsTestResponse = JknConfigsTestResponses[keyof JknConfigsTestResponses];

export type SatusehatConfigsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by environment
         */
        environment?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
    };
    url: '/v1/orgs/{orgId}/integrations/satusehat';
};

export type SatusehatConfigsListResponses = {
    /**
     * The request has succeeded.
     */
    200: SatusehatConfigListResponse | ErrorResponse;
};

export type SatusehatConfigsListResponse = SatusehatConfigsListResponses[keyof SatusehatConfigsListResponses];

export type SatusehatConfigsCreateData = {
    body: CreateSatusehatConfigRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/satusehat';
};

export type SatusehatConfigsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: SatusehatConfigResponse;
};

export type SatusehatConfigsCreateResponse = SatusehatConfigsCreateResponses[keyof SatusehatConfigsCreateResponses];

export type SatusehatConfigsDeleteData = {
    body?: never;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/satusehat/{configId}';
};

export type SatusehatConfigsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type SatusehatConfigsDeleteResponse = SatusehatConfigsDeleteResponses[keyof SatusehatConfigsDeleteResponses];

export type SatusehatConfigsGetData = {
    body?: never;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/satusehat/{configId}';
};

export type SatusehatConfigsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: SatusehatConfigResponse | ErrorResponse;
};

export type SatusehatConfigsGetResponse = SatusehatConfigsGetResponses[keyof SatusehatConfigsGetResponses];

export type SatusehatConfigsUpdateData = {
    body: UpdateSatusehatConfigRequest;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/satusehat/{configId}';
};

export type SatusehatConfigsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: SatusehatConfigResponse | ErrorResponse;
};

export type SatusehatConfigsUpdateResponse = SatusehatConfigsUpdateResponses[keyof SatusehatConfigsUpdateResponses];

export type SatusehatConfigsRefreshTokenData = {
    body?: never;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/satusehat/{configId}/refresh-token';
};

export type SatusehatConfigsRefreshTokenResponses = {
    /**
     * The request has succeeded.
     */
    200: SatusehatConfigResponse | ErrorResponse;
};

export type SatusehatConfigsRefreshTokenResponse = SatusehatConfigsRefreshTokenResponses[keyof SatusehatConfigsRefreshTokenResponses];

export type SatusehatConfigsTestData = {
    body: TestIntegrationRequest;
    path: {
        orgId: string;
        configId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/satusehat/{configId}/test';
};

export type SatusehatConfigsTestResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationTestResponse | ErrorResponse;
};

export type SatusehatConfigsTestResponse = SatusehatConfigsTestResponses[keyof SatusehatConfigsTestResponses];

export type IntegrationSyncQueuesListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by integration type
         */
        integrationType?: string;
        /**
         * Filter by resource type
         */
        resourceType?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter by operation
         */
        operation?: string;
    };
    url: '/v1/orgs/{orgId}/integrations/sync-queue';
};

export type IntegrationSyncQueuesListResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationSyncQueueListResponse | ErrorResponse;
};

export type IntegrationSyncQueuesListResponse = IntegrationSyncQueuesListResponses[keyof IntegrationSyncQueuesListResponses];

export type IntegrationSyncQueuesRetryData = {
    body: RetrySyncRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/sync-queue/retry';
};

export type IntegrationSyncQueuesRetryResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationSyncQueueListResponse | ErrorResponse;
};

export type IntegrationSyncQueuesRetryResponse = IntegrationSyncQueuesRetryResponses[keyof IntegrationSyncQueuesRetryResponses];

export type IntegrationSyncQueuesGetData = {
    body?: never;
    path: {
        orgId: string;
        queueId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/sync-queue/{queueId}';
};

export type IntegrationSyncQueuesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationSyncQueueResponse | ErrorResponse;
};

export type IntegrationSyncQueuesGetResponse = IntegrationSyncQueuesGetResponses[keyof IntegrationSyncQueuesGetResponses];

export type IntegrationSyncQueuesCancelData = {
    body?: never;
    path: {
        orgId: string;
        queueId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/integrations/sync-queue/{queueId}/cancel';
};

export type IntegrationSyncQueuesCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: IntegrationSyncQueueResponse | ErrorResponse;
};

export type IntegrationSyncQueuesCancelResponse = IntegrationSyncQueuesCancelResponses[keyof IntegrationSyncQueuesCancelResponses];

export type InvoicesListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by patient
         */
        patientId?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter by payment type
         */
        paymentType?: string;
        /**
         * Filter by payer type
         */
        payerType?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
        /**
         * Filter overdue only
         */
        overdueOnly?: boolean;
    };
    url: '/v1/orgs/{orgId}/invoices';
};

export type InvoicesListResponses = {
    /**
     * The request has succeeded.
     */
    200: InvoiceListResponse | ErrorResponse;
};

export type InvoicesListResponse = InvoicesListResponses[keyof InvoicesListResponses];

export type InvoicesCreateData = {
    body: CreateInvoiceRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/invoices';
};

export type InvoicesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: InvoiceResponse;
};

export type InvoicesCreateResponse = InvoicesCreateResponses[keyof InvoicesCreateResponses];

export type InvoicesGetSummaryData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by patient
         */
        patientId?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/invoices/summary';
};

export type InvoicesGetSummaryResponses = {
    /**
     * The request has succeeded.
     */
    200: BillingSummaryResponse | ErrorResponse;
};

export type InvoicesGetSummaryResponse = InvoicesGetSummaryResponses[keyof InvoicesGetSummaryResponses];

export type InvoicesGetData = {
    body?: never;
    path: {
        orgId: string;
        invoiceId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/invoices/{invoiceId}';
};

export type InvoicesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: InvoiceResponse | ErrorResponse;
};

export type InvoicesGetResponse = InvoicesGetResponses[keyof InvoicesGetResponses];

export type InvoicesUpdateData = {
    body: UpdateInvoiceRequest;
    path: {
        orgId: string;
        invoiceId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/invoices/{invoiceId}';
};

export type InvoicesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: InvoiceResponse | ErrorResponse;
};

export type InvoicesUpdateResponse = InvoicesUpdateResponses[keyof InvoicesUpdateResponses];

export type InvoicesApproveData = {
    body?: never;
    path: {
        orgId: string;
        invoiceId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/invoices/{invoiceId}/approve';
};

export type InvoicesApproveResponses = {
    /**
     * The request has succeeded.
     */
    200: InvoiceResponse | ErrorResponse;
};

export type InvoicesApproveResponse = InvoicesApproveResponses[keyof InvoicesApproveResponses];

export type InvoicesVoidInvoiceData = {
    body: VoidInvoiceRequest;
    path: {
        orgId: string;
        invoiceId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/invoices/{invoiceId}/void';
};

export type InvoicesVoidInvoiceResponses = {
    /**
     * The request has succeeded.
     */
    200: InvoiceResponse | ErrorResponse;
};

export type InvoicesVoidInvoiceResponse = InvoicesVoidInvoiceResponses[keyof InvoicesVoidInvoiceResponses];

export type JobsListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by job status
         */
        status?: JobStatus;
        /**
         * Filter by job type
         */
        type?: string;
        /**
         * Filter jobs created after this timestamp
         */
        createdAfter?: string;
    };
    url: '/v1/orgs/{orgId}/jobs';
};

export type JobsListResponses = {
    /**
     * The request has succeeded.
     */
    200: JobListResponse | ErrorResponse;
};

export type JobsListResponse = JobsListResponses[keyof JobsListResponses];

export type JobsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}';
};

export type JobsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsGetResponse = JobsGetResponses[keyof JobsGetResponses];

export type JobsCancelData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Job ID
         */
        jobId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/jobs/{jobId}/cancel';
};

export type JobsCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: JobResponse | ErrorResponse;
};

export type JobsCancelResponse = JobsCancelResponses[keyof JobsCancelResponses];

export type LabOrdersListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by patient
         */
        patientId?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter by priority
         */
        priority?: string;
    };
    url: '/v1/orgs/{orgId}/lab-orders';
};

export type LabOrdersListResponses = {
    /**
     * The request has succeeded.
     */
    200: LabOrderListResponse | ErrorResponse;
};

export type LabOrdersListResponse = LabOrdersListResponses[keyof LabOrdersListResponses];

export type LabOrdersCreateData = {
    body: CreateLabOrderRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-orders';
};

export type LabOrdersCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: LabOrderResponse;
};

export type LabOrdersCreateResponse = LabOrdersCreateResponses[keyof LabOrdersCreateResponses];

export type LabOrdersGetData = {
    body?: never;
    path: {
        orgId: string;
        orderId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-orders/{orderId}';
};

export type LabOrdersGetResponses = {
    /**
     * The request has succeeded.
     */
    200: LabOrderResponse | ErrorResponse;
};

export type LabOrdersGetResponse = LabOrdersGetResponses[keyof LabOrdersGetResponses];

export type LabOrdersCancelData = {
    body?: never;
    path: {
        orgId: string;
        orderId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-orders/{orderId}/cancel';
};

export type LabOrdersCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: LabOrderResponse | ErrorResponse;
};

export type LabOrdersCancelResponse = LabOrdersCancelResponses[keyof LabOrdersCancelResponses];

export type LabOrdersUpdateStatusData = {
    body: UpdateLabOrderStatusRequest;
    path: {
        orgId: string;
        orderId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-orders/{orderId}/status';
};

export type LabOrdersUpdateStatusResponses = {
    /**
     * The request has succeeded.
     */
    200: LabOrderResponse | ErrorResponse;
};

export type LabOrdersUpdateStatusResponse = LabOrdersUpdateStatusResponses[keyof LabOrdersUpdateStatusResponses];

export type LabResultsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by patient
         */
        patientId?: string;
        /**
         * Filter by order
         */
        orderId?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter by abnormal
         */
        isAbnormal?: boolean;
        /**
         * Filter by critical
         */
        isCritical?: boolean;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/lab-results';
};

export type LabResultsListResponses = {
    /**
     * The request has succeeded.
     */
    200: LabResultListResponse | ErrorResponse;
};

export type LabResultsListResponse = LabResultsListResponses[keyof LabResultsListResponses];

export type LabResultsEnterData = {
    body: EnterLabResultRequest;
    path: {
        orgId: string;
        orderItemId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-results/order-items/{orderItemId}';
};

export type LabResultsEnterResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: LabResultResponse;
};

export type LabResultsEnterResponse = LabResultsEnterResponses[keyof LabResultsEnterResponses];

export type LabResultsGetData = {
    body?: never;
    path: {
        orgId: string;
        resultId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-results/{resultId}';
};

export type LabResultsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: LabResultResponse | ErrorResponse;
};

export type LabResultsGetResponse = LabResultsGetResponses[keyof LabResultsGetResponses];

export type LabResultsUnverifyData = {
    body?: never;
    path: {
        orgId: string;
        resultId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-results/{resultId}/unverify';
};

export type LabResultsUnverifyResponses = {
    /**
     * The request has succeeded.
     */
    200: LabResultResponse | ErrorResponse;
};

export type LabResultsUnverifyResponse = LabResultsUnverifyResponses[keyof LabResultsUnverifyResponses];

export type LabResultsVerifyData = {
    body: VerifyLabResultRequest;
    path: {
        orgId: string;
        resultId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-results/{resultId}/verify';
};

export type LabResultsVerifyResponses = {
    /**
     * The request has succeeded.
     */
    200: LabResultResponse | ErrorResponse;
};

export type LabResultsVerifyResponse = LabResultsVerifyResponses[keyof LabResultsVerifyResponses];

export type LabTestsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by category
         */
        category?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by name or code
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/lab-tests';
};

export type LabTestsListResponses = {
    /**
     * The request has succeeded.
     */
    200: LabTestListResponse | ErrorResponse;
};

export type LabTestsListResponse = LabTestsListResponses[keyof LabTestsListResponses];

export type LabTestsCreateData = {
    body: CreateLabTestRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-tests';
};

export type LabTestsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: LabTestResponse;
};

export type LabTestsCreateResponse = LabTestsCreateResponses[keyof LabTestsCreateResponses];

export type LabTestsDeleteData = {
    body?: never;
    path: {
        orgId: string;
        testId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-tests/{testId}';
};

export type LabTestsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type LabTestsDeleteResponse = LabTestsDeleteResponses[keyof LabTestsDeleteResponses];

export type LabTestsGetData = {
    body?: never;
    path: {
        orgId: string;
        testId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-tests/{testId}';
};

export type LabTestsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: LabTestResponse | ErrorResponse;
};

export type LabTestsGetResponse = LabTestsGetResponses[keyof LabTestsGetResponses];

export type LabTestsUpdateData = {
    body: UpdateLabTestRequest;
    path: {
        orgId: string;
        testId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/lab-tests/{testId}';
};

export type LabTestsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: LabTestResponse | ErrorResponse;
};

export type LabTestsUpdateResponse = LabTestsUpdateResponses[keyof LabTestsUpdateResponses];

export type PatientSafetyIncidentsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by severity
         */
        severity?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/patient-safety-incidents';
};

export type PatientSafetyIncidentsListResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientSafetyIncidentListResponse | ErrorResponse;
};

export type PatientSafetyIncidentsListResponse = PatientSafetyIncidentsListResponses[keyof PatientSafetyIncidentsListResponses];

export type PatientSafetyIncidentsReportData = {
    body: ReportPatientSafetyIncidentRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patient-safety-incidents';
};

export type PatientSafetyIncidentsReportResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PatientSafetyIncidentResponse;
};

export type PatientSafetyIncidentsReportResponse = PatientSafetyIncidentsReportResponses[keyof PatientSafetyIncidentsReportResponses];

export type PatientSafetyIncidentsGetData = {
    body?: never;
    path: {
        orgId: string;
        incidentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patient-safety-incidents/{incidentId}';
};

export type PatientSafetyIncidentsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientSafetyIncidentResponse | ErrorResponse;
};

export type PatientSafetyIncidentsGetResponse = PatientSafetyIncidentsGetResponses[keyof PatientSafetyIncidentsGetResponses];

export type PatientSafetyIncidentsInvestigateData = {
    body?: never;
    path: {
        orgId: string;
        incidentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patient-safety-incidents/{incidentId}/investigate';
};

export type PatientSafetyIncidentsInvestigateResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientSafetyIncidentResponse | ErrorResponse;
};

export type PatientSafetyIncidentsInvestigateResponse = PatientSafetyIncidentsInvestigateResponses[keyof PatientSafetyIncidentsInvestigateResponses];

export type PatientSafetyIncidentsResolveData = {
    body?: never;
    path: {
        orgId: string;
        incidentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patient-safety-incidents/{incidentId}/resolve';
};

export type PatientSafetyIncidentsResolveResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientSafetyIncidentResponse | ErrorResponse;
};

export type PatientSafetyIncidentsResolveResponse = PatientSafetyIncidentsResolveResponses[keyof PatientSafetyIncidentsResolveResponses];

export type PatientsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by name, NIK, or MRN
         */
        search?: string;
        /**
         * Filter by BPJS member status
         */
        hasBpjs?: boolean;
    };
    url: '/v1/orgs/{orgId}/patients';
};

export type PatientsListResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientListResponse | ErrorResponse;
};

export type PatientsListResponse = PatientsListResponses[keyof PatientsListResponses];

export type PatientsCreateData = {
    body: CreatePatientRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients';
};

export type PatientsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PatientResponse;
};

export type PatientsCreateResponse = PatientsCreateResponses[keyof PatientsCreateResponses];

export type PatientsSearchByBpjsData = {
    body?: never;
    path: {
        orgId: string;
    };
    query: {
        bpjsNumber: string;
    };
    url: '/v1/orgs/{orgId}/patients/search-by-bpjs';
};

export type PatientsSearchByBpjsResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientResponse | ErrorResponse;
};

export type PatientsSearchByBpjsResponse = PatientsSearchByBpjsResponses[keyof PatientsSearchByBpjsResponses];

export type PatientsSearchByNikData = {
    body?: never;
    path: {
        orgId: string;
    };
    query: {
        nik: string;
    };
    url: '/v1/orgs/{orgId}/patients/search-by-nik';
};

export type PatientsSearchByNikResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientResponse | ErrorResponse;
};

export type PatientsSearchByNikResponse = PatientsSearchByNikResponses[keyof PatientsSearchByNikResponses];

export type PatientsDeleteData = {
    body?: never;
    path: {
        orgId: string;
        patientId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}';
};

export type PatientsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type PatientsDeleteResponse = PatientsDeleteResponses[keyof PatientsDeleteResponses];

export type PatientsGetData = {
    body?: never;
    path: {
        orgId: string;
        patientId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}';
};

export type PatientsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientResponse | ErrorResponse;
};

export type PatientsGetResponse = PatientsGetResponses[keyof PatientsGetResponses];

export type PatientsUpdateData = {
    body: UpdatePatientRequest;
    path: {
        orgId: string;
        patientId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}';
};

export type PatientsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientResponse | ErrorResponse;
};

export type PatientsUpdateResponse = PatientsUpdateResponses[keyof PatientsUpdateResponses];

export type PatientAllergiesListData = {
    body?: never;
    path: {
        orgId: string;
        patientId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/allergies';
};

export type PatientAllergiesListResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientAllergyListResponse | ErrorResponse;
};

export type PatientAllergiesListResponse = PatientAllergiesListResponses[keyof PatientAllergiesListResponses];

export type PatientAllergiesCreateData = {
    body: CreatePatientAllergyRequest;
    path: {
        orgId: string;
        patientId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/allergies';
};

export type PatientAllergiesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PatientAllergyResponse;
};

export type PatientAllergiesCreateResponse = PatientAllergiesCreateResponses[keyof PatientAllergiesCreateResponses];

export type PatientAllergiesDeleteData = {
    body?: never;
    path: {
        orgId: string;
        patientId: string;
        allergyId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/allergies/{allergyId}';
};

export type PatientAllergiesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type PatientAllergiesDeleteResponse = PatientAllergiesDeleteResponses[keyof PatientAllergiesDeleteResponses];

export type PatientAllergiesUpdateData = {
    body: UpdatePatientAllergyRequest;
    path: {
        orgId: string;
        patientId: string;
        allergyId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/allergies/{allergyId}';
};

export type PatientAllergiesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: PatientAllergyResponse | ErrorResponse;
};

export type PatientAllergiesUpdateResponse = PatientAllergiesUpdateResponses[keyof PatientAllergiesUpdateResponses];

export type ChronicConditionsListData = {
    body?: never;
    path: {
        orgId: string;
        patientId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/chronic-conditions';
};

export type ChronicConditionsListResponses = {
    /**
     * The request has succeeded.
     */
    200: ChronicConditionListResponse | ErrorResponse;
};

export type ChronicConditionsListResponse = ChronicConditionsListResponses[keyof ChronicConditionsListResponses];

export type ChronicConditionsCreateData = {
    body: CreateChronicConditionRequest;
    path: {
        orgId: string;
        patientId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/chronic-conditions';
};

export type ChronicConditionsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: ChronicConditionResponse;
};

export type ChronicConditionsCreateResponse = ChronicConditionsCreateResponses[keyof ChronicConditionsCreateResponses];

export type ChronicConditionsDeleteData = {
    body?: never;
    path: {
        orgId: string;
        patientId: string;
        conditionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/chronic-conditions/{conditionId}';
};

export type ChronicConditionsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type ChronicConditionsDeleteResponse = ChronicConditionsDeleteResponses[keyof ChronicConditionsDeleteResponses];

export type ChronicConditionsUpdateData = {
    body: UpdateChronicConditionRequest;
    path: {
        orgId: string;
        patientId: string;
        conditionId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/patients/{patientId}/chronic-conditions/{conditionId}';
};

export type ChronicConditionsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: ChronicConditionResponse | ErrorResponse;
};

export type ChronicConditionsUpdateResponse = ChronicConditionsUpdateResponses[keyof ChronicConditionsUpdateResponses];

export type PaymentsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by invoice
         */
        invoiceId?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter by payment method
         */
        paymentMethod?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/payments';
};

export type PaymentsListResponses = {
    /**
     * The request has succeeded.
     */
    200: PaymentListResponse | ErrorResponse;
};

export type PaymentsListResponse = PaymentsListResponses[keyof PaymentsListResponses];

export type PaymentsCreateData = {
    body: CreatePaymentRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/payments';
};

export type PaymentsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PaymentResponse;
};

export type PaymentsCreateResponse = PaymentsCreateResponses[keyof PaymentsCreateResponses];

export type PaymentsGetData = {
    body?: never;
    path: {
        orgId: string;
        paymentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/payments/{paymentId}';
};

export type PaymentsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PaymentResponse | ErrorResponse;
};

export type PaymentsGetResponse = PaymentsGetResponses[keyof PaymentsGetResponses];

export type PaymentsCancelData = {
    body?: never;
    path: {
        orgId: string;
        paymentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/payments/{paymentId}/cancel';
};

export type PaymentsCancelResponses = {
    /**
     * The request has succeeded.
     */
    200: PaymentResponse | ErrorResponse;
};

export type PaymentsCancelResponse = PaymentsCancelResponses[keyof PaymentsCancelResponses];

export type PaymentsVerifyData = {
    body: VerifyPaymentRequest;
    path: {
        orgId: string;
        paymentId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/payments/{paymentId}/verify';
};

export type PaymentsVerifyResponses = {
    /**
     * The request has succeeded.
     */
    200: PaymentResponse | ErrorResponse;
};

export type PaymentsVerifyResponse = PaymentsVerifyResponses[keyof PaymentsVerifyResponses];

export type PolyclinicsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by name
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/polyclinics';
};

export type PolyclinicsListResponses = {
    /**
     * The request has succeeded.
     */
    200: PolyclinicListResponse | ErrorResponse;
};

export type PolyclinicsListResponse = PolyclinicsListResponses[keyof PolyclinicsListResponses];

export type PolyclinicsCreateData = {
    body: CreatePolyclinicRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/polyclinics';
};

export type PolyclinicsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PolyclinicResponse;
};

export type PolyclinicsCreateResponse = PolyclinicsCreateResponses[keyof PolyclinicsCreateResponses];

export type PolyclinicsDeleteData = {
    body?: never;
    path: {
        orgId: string;
        polyclinicId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/polyclinics/{polyclinicId}';
};

export type PolyclinicsDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type PolyclinicsDeleteResponse = PolyclinicsDeleteResponses[keyof PolyclinicsDeleteResponses];

export type PolyclinicsGetData = {
    body?: never;
    path: {
        orgId: string;
        polyclinicId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/polyclinics/{polyclinicId}';
};

export type PolyclinicsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PolyclinicResponse | ErrorResponse;
};

export type PolyclinicsGetResponse = PolyclinicsGetResponses[keyof PolyclinicsGetResponses];

export type PolyclinicsUpdateData = {
    body: UpdatePolyclinicRequest;
    path: {
        orgId: string;
        polyclinicId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/polyclinics/{polyclinicId}';
};

export type PolyclinicsUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: PolyclinicResponse | ErrorResponse;
};

export type PolyclinicsUpdateResponse = PolyclinicsUpdateResponses[keyof PolyclinicsUpdateResponses];

export type PractitionerCredentialsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by practitioner
         */
        practitionerId?: string;
        /**
         * Filter by credential type
         */
        credentialType?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Filter expiring soon
         */
        expiringSoon?: boolean;
    };
    url: '/v1/orgs/{orgId}/practitioner-credentials';
};

export type PractitionerCredentialsListResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerCredentialListResponse | ErrorResponse;
};

export type PractitionerCredentialsListResponse = PractitionerCredentialsListResponses[keyof PractitionerCredentialsListResponses];

export type PractitionerCredentialsCreateData = {
    body: CreatePractitionerCredentialRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioner-credentials';
};

export type PractitionerCredentialsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PractitionerCredentialResponse;
};

export type PractitionerCredentialsCreateResponse = PractitionerCredentialsCreateResponses[keyof PractitionerCredentialsCreateResponses];

export type PractitionerCredentialsGetData = {
    body?: never;
    path: {
        orgId: string;
        credentialId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioner-credentials/{credentialId}';
};

export type PractitionerCredentialsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerCredentialResponse | ErrorResponse;
};

export type PractitionerCredentialsGetResponse = PractitionerCredentialsGetResponses[keyof PractitionerCredentialsGetResponses];

export type PractitionerCredentialsVerifyData = {
    body?: never;
    path: {
        orgId: string;
        credentialId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioner-credentials/{credentialId}/verify';
};

export type PractitionerCredentialsVerifyResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerCredentialResponse | ErrorResponse;
};

export type PractitionerCredentialsVerifyResponse = PractitionerCredentialsVerifyResponses[keyof PractitionerCredentialsVerifyResponses];

export type PractitionersListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by specialty
         */
        specialty?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
        /**
         * Search by name
         */
        search?: string;
    };
    url: '/v1/orgs/{orgId}/practitioners';
};

export type PractitionersListResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerListResponse | ErrorResponse;
};

export type PractitionersListResponse = PractitionersListResponses[keyof PractitionersListResponses];

export type PractitionersCreateData = {
    body: CreatePractitionerRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioners';
};

export type PractitionersCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PractitionerResponse;
};

export type PractitionersCreateResponse = PractitionersCreateResponses[keyof PractitionersCreateResponses];

export type PractitionersDeleteData = {
    body?: never;
    path: {
        orgId: string;
        practitionerId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioners/{practitionerId}';
};

export type PractitionersDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type PractitionersDeleteResponse = PractitionersDeleteResponses[keyof PractitionersDeleteResponses];

export type PractitionersGetData = {
    body?: never;
    path: {
        orgId: string;
        practitionerId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioners/{practitionerId}';
};

export type PractitionersGetResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerResponse | ErrorResponse;
};

export type PractitionersGetResponse = PractitionersGetResponses[keyof PractitionersGetResponses];

export type PractitionersUpdateData = {
    body: UpdatePractitionerRequest;
    path: {
        orgId: string;
        practitionerId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioners/{practitionerId}';
};

export type PractitionersUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerResponse | ErrorResponse;
};

export type PractitionersUpdateResponse = PractitionersUpdateResponses[keyof PractitionersUpdateResponses];

export type PractitionerSchedulesListData = {
    body?: never;
    path: {
        orgId: string;
        practitionerId: string;
    };
    query?: {
        /**
         * Filter by polyclinic
         */
        polyclinicId?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
    };
    url: '/v1/orgs/{orgId}/practitioners/{practitionerId}/schedules';
};

export type PractitionerSchedulesListResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerScheduleListResponse | ErrorResponse;
};

export type PractitionerSchedulesListResponse = PractitionerSchedulesListResponses[keyof PractitionerSchedulesListResponses];

export type PractitionerSchedulesCreateData = {
    body: CreatePractitionerScheduleRequest;
    path: {
        orgId: string;
        practitionerId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioners/{practitionerId}/schedules';
};

export type PractitionerSchedulesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: PractitionerScheduleResponse;
};

export type PractitionerSchedulesCreateResponse = PractitionerSchedulesCreateResponses[keyof PractitionerSchedulesCreateResponses];

export type PractitionerSchedulesDeleteData = {
    body?: never;
    path: {
        orgId: string;
        practitionerId: string;
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioners/{practitionerId}/schedules/{scheduleId}';
};

export type PractitionerSchedulesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type PractitionerSchedulesDeleteResponse = PractitionerSchedulesDeleteResponses[keyof PractitionerSchedulesDeleteResponses];

export type PractitionerSchedulesUpdateData = {
    body: UpdatePractitionerScheduleRequest;
    path: {
        orgId: string;
        practitionerId: string;
        scheduleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/practitioners/{practitionerId}/schedules/{scheduleId}';
};

export type PractitionerSchedulesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: PractitionerScheduleResponse | ErrorResponse;
};

export type PractitionerSchedulesUpdateResponse = PractitionerSchedulesUpdateResponses[keyof PractitionerSchedulesUpdateResponses];

export type QualityIndicatorsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by category
         */
        category?: string;
        /**
         * Filter by active status
         */
        isActive?: boolean;
    };
    url: '/v1/orgs/{orgId}/quality-indicators';
};

export type QualityIndicatorsListResponses = {
    /**
     * The request has succeeded.
     */
    200: QualityIndicatorListResponse | ErrorResponse;
};

export type QualityIndicatorsListResponse = QualityIndicatorsListResponses[keyof QualityIndicatorsListResponses];

export type QualityIndicatorsCreateData = {
    body: CreateQualityIndicatorRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/quality-indicators';
};

export type QualityIndicatorsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: QualityIndicatorResponse;
};

export type QualityIndicatorsCreateResponse = QualityIndicatorsCreateResponses[keyof QualityIndicatorsCreateResponses];

export type QualityIndicatorsGetData = {
    body?: never;
    path: {
        orgId: string;
        indicatorId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/quality-indicators/{indicatorId}';
};

export type QualityIndicatorsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: QualityIndicatorResponse | ErrorResponse;
};

export type QualityIndicatorsGetResponse = QualityIndicatorsGetResponses[keyof QualityIndicatorsGetResponses];

export type QualityIndicatorsListResultsData = {
    body?: never;
    path: {
        orgId: string;
        indicatorId: string;
    };
    query?: {
        /**
         * Period start
         */
        periodFrom?: string;
        /**
         * Period end
         */
        periodTo?: string;
    };
    url: '/v1/orgs/{orgId}/quality-indicators/{indicatorId}/results';
};

export type QualityIndicatorsListResultsResponses = {
    /**
     * The request has succeeded.
     */
    200: QualityIndicatorResultListResponse | ErrorResponse;
};

export type QualityIndicatorsListResultsResponse = QualityIndicatorsListResultsResponses[keyof QualityIndicatorsListResultsResponses];

export type QualityIndicatorsRecordResultData = {
    body: RecordQualityIndicatorResultRequest;
    path: {
        orgId: string;
        indicatorId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/quality-indicators/{indicatorId}/results';
};

export type QualityIndicatorsRecordResultResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: QualityIndicatorResultResponse;
};

export type QualityIndicatorsRecordResultResponse = QualityIndicatorsRecordResultResponses[keyof QualityIndicatorsRecordResultResponses];

export type QueuesListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by polyclinic
         */
        polyclinicId?: string;
        /**
         * Filter by date
         */
        date?: string;
        /**
         * Filter by status
         */
        status?: string;
    };
    url: '/v1/orgs/{orgId}/queues';
};

export type QueuesListResponses = {
    /**
     * The request has succeeded.
     */
    200: QueueListResponse | ErrorResponse;
};

export type QueuesListResponse = QueuesListResponses[keyof QueuesListResponses];

export type QueuesCreateData = {
    body: CreateQueueRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/queues';
};

export type QueuesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: QueueResponse;
};

export type QueuesCreateResponse = QueuesCreateResponses[keyof QueuesCreateResponses];

export type QueuesCallNextData = {
    body: CallNextQueueRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/queues/call-next';
};

export type QueuesCallNextResponses = {
    /**
     * The request has succeeded.
     */
    200: QueueResponse | ErrorResponse;
};

export type QueuesCallNextResponse = QueuesCallNextResponses[keyof QueuesCallNextResponses];

export type QueuesGetDisplayData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by polyclinic
         */
        polyclinicId?: string;
    };
    url: '/v1/orgs/{orgId}/queues/display';
};

export type QueuesGetDisplayResponses = {
    /**
     * The request has succeeded.
     */
    200: QueueDisplayResponse | ErrorResponse;
};

export type QueuesGetDisplayResponse = QueuesGetDisplayResponses[keyof QueuesGetDisplayResponses];

export type QueuesGetData = {
    body?: never;
    path: {
        orgId: string;
        queueId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/queues/{queueId}';
};

export type QueuesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: QueueResponse | ErrorResponse;
};

export type QueuesGetResponse = QueuesGetResponses[keyof QueuesGetResponses];

export type QueuesCallData = {
    body: CallQueueRequest;
    path: {
        orgId: string;
        queueId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/queues/{queueId}/call';
};

export type QueuesCallResponses = {
    /**
     * The request has succeeded.
     */
    200: QueueResponse | ErrorResponse;
};

export type QueuesCallResponse = QueuesCallResponses[keyof QueuesCallResponses];

export type QueuesCompleteData = {
    body?: never;
    path: {
        orgId: string;
        queueId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/queues/{queueId}/complete';
};

export type QueuesCompleteResponses = {
    /**
     * The request has succeeded.
     */
    200: QueueResponse | ErrorResponse;
};

export type QueuesCompleteResponse = QueuesCompleteResponses[keyof QueuesCompleteResponses];

export type QueuesSkipData = {
    body?: never;
    path: {
        orgId: string;
        queueId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/queues/{queueId}/skip';
};

export type QueuesSkipResponses = {
    /**
     * The request has succeeded.
     */
    200: QueueResponse | ErrorResponse;
};

export type QueuesSkipResponse = QueuesSkipResponses[keyof QueuesSkipResponses];

export type RefundsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/refunds';
};

export type RefundsListResponses = {
    /**
     * The request has succeeded.
     */
    200: RefundListResponse | ErrorResponse;
};

export type RefundsListResponse = RefundsListResponses[keyof RefundsListResponses];

export type RefundsCreateData = {
    body: CreateRefundRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/refunds';
};

export type RefundsCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: RefundResponse;
};

export type RefundsCreateResponse = RefundsCreateResponses[keyof RefundsCreateResponses];

export type RefundsGetData = {
    body?: never;
    path: {
        orgId: string;
        refundId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/refunds/{refundId}';
};

export type RefundsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: RefundResponse | ErrorResponse;
};

export type RefundsGetResponse = RefundsGetResponses[keyof RefundsGetResponses];

export type RefundsApproveData = {
    body: ApproveRefundRequest;
    path: {
        orgId: string;
        refundId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/refunds/{refundId}/approve';
};

export type RefundsApproveResponses = {
    /**
     * The request has succeeded.
     */
    200: RefundResponse | ErrorResponse;
};

export type RefundsApproveResponse = RefundsApproveResponses[keyof RefundsApproveResponses];

export type RefundsProcessData = {
    body: ProcessRefundRequest;
    path: {
        orgId: string;
        refundId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/refunds/{refundId}/process';
};

export type RefundsProcessResponses = {
    /**
     * The request has succeeded.
     */
    200: RefundResponse | ErrorResponse;
};

export type RefundsProcessResponse = RefundsProcessResponses[keyof RefundsProcessResponses];

export type RefundsRejectData = {
    body: RejectRefundRequest;
    path: {
        orgId: string;
        refundId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/refunds/{refundId}/reject';
};

export type RefundsRejectResponses = {
    /**
     * The request has succeeded.
     */
    200: RefundResponse | ErrorResponse;
};

export type RefundsRejectResponse = RefundsRejectResponses[keyof RefundsRejectResponses];

export type TenantRolesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by system role status
         */
        isSystemRole?: boolean;
    };
    url: '/v1/orgs/{orgId}/roles';
};

export type TenantRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleListResponse | ErrorResponse;
};

export type TenantRolesListResponse = TenantRolesListResponses[keyof TenantRolesListResponses];

export type TenantRolesCreateData = {
    /**
     * Role data
     */
    body: CreateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles';
};

export type TenantRolesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: RoleResponse;
};

export type TenantRolesCreateResponse = TenantRolesCreateResponses[keyof TenantRolesCreateResponses];

export type TenantRolesDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type TenantRolesDeleteResponse = TenantRolesDeleteResponses[keyof TenantRolesDeleteResponses];

export type TenantRolesGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type TenantRolesGetResponse = TenantRolesGetResponses[keyof TenantRolesGetResponses];

export type TenantRolesUpdateData = {
    /**
     * Role update data
     */
    body: UpdateRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/roles/{roleId}';
};

export type TenantRolesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type TenantRolesUpdateResponse = TenantRolesUpdateResponses[keyof TenantRolesUpdateResponses];

export type AppointmentSlotsListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Filter by branch
         */
        branchId?: string;
        /**
         * Filter by practitioner
         */
        practitionerId?: string;
        /**
         * Filter by polyclinic
         */
        polyclinicId?: string;
        /**
         * Filter by date
         */
        date?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
        /**
         * Filter by availability
         */
        isAvailable?: boolean;
    };
    url: '/v1/orgs/{orgId}/slots';
};

export type AppointmentSlotsListResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentSlotListResponse | ErrorResponse;
};

export type AppointmentSlotsListResponse = AppointmentSlotsListResponses[keyof AppointmentSlotsListResponses];

export type AppointmentSlotsGenerateData = {
    body: GenerateSlotsRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/slots/generate';
};

export type AppointmentSlotsGenerateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: AppointmentSlotListResponse;
};

export type AppointmentSlotsGenerateResponse = AppointmentSlotsGenerateResponses[keyof AppointmentSlotsGenerateResponses];

export type AppointmentSlotsBlockData = {
    body: BlockSlotRequest;
    path: {
        orgId: string;
        slotId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/slots/{slotId}/block';
};

export type AppointmentSlotsBlockResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentSlotResponse | ErrorResponse;
};

export type AppointmentSlotsBlockResponse = AppointmentSlotsBlockResponses[keyof AppointmentSlotsBlockResponses];

export type AppointmentSlotsUnblockData = {
    body?: never;
    path: {
        orgId: string;
        slotId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/slots/{slotId}/unblock';
};

export type AppointmentSlotsUnblockResponses = {
    /**
     * The request has succeeded.
     */
    200: AppointmentSlotResponse | ErrorResponse;
};

export type AppointmentSlotsUnblockResponse = AppointmentSlotsUnblockResponses[keyof AppointmentSlotsUnblockResponses];

export type SpecimensListData = {
    body?: never;
    path: {
        orgId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Page size
         */
        pageSize?: number;
        /**
         * Filter by status
         */
        status?: string;
        /**
         * Date range start
         */
        dateFrom?: string;
        /**
         * Date range end
         */
        dateTo?: string;
    };
    url: '/v1/orgs/{orgId}/specimens';
};

export type SpecimensListResponses = {
    /**
     * The request has succeeded.
     */
    200: SpecimenListResponse | ErrorResponse;
};

export type SpecimensListResponse = SpecimensListResponses[keyof SpecimensListResponses];

export type SpecimensCollectData = {
    body: CollectSpecimenRequest;
    path: {
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/specimens';
};

export type SpecimensCollectResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: SpecimenResponse;
};

export type SpecimensCollectResponse = SpecimensCollectResponses[keyof SpecimensCollectResponses];

export type SpecimensGetData = {
    body?: never;
    path: {
        orgId: string;
        specimenId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/specimens/{specimenId}';
};

export type SpecimensGetResponses = {
    /**
     * The request has succeeded.
     */
    200: SpecimenResponse | ErrorResponse;
};

export type SpecimensGetResponse = SpecimensGetResponses[keyof SpecimensGetResponses];

export type SpecimensReceiveData = {
    body: ReceiveSpecimenRequest;
    path: {
        orgId: string;
        specimenId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/specimens/{specimenId}/receive';
};

export type SpecimensReceiveResponses = {
    /**
     * The request has succeeded.
     */
    200: SpecimenResponse | ErrorResponse;
};

export type SpecimensReceiveResponse = SpecimensReceiveResponses[keyof SpecimensReceiveResponses];

export type SpecimensRejectData = {
    body: ReceiveSpecimenRequest;
    path: {
        orgId: string;
        specimenId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/specimens/{specimenId}/reject';
};

export type SpecimensRejectResponses = {
    /**
     * The request has succeeded.
     */
    200: SpecimenResponse | ErrorResponse;
};

export type SpecimensRejectResponse = SpecimensRejectResponses[keyof SpecimensRejectResponses];

export type UserPermissionsGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/permissions';
};

export type UserPermissionsGetResponses = {
    /**
     * The request has succeeded.
     */
    200: UserEffectivePermissionsResponse | ErrorResponse;
};

export type UserPermissionsGetResponse = UserPermissionsGetResponses[keyof UserPermissionsGetResponses];

export type UserTenantRolesListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles';
};

export type UserTenantRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserRoleAssignmentListResponse | ErrorResponse;
};

export type UserTenantRolesListResponse = UserTenantRolesListResponses[keyof UserTenantRolesListResponses];

export type UserTenantRolesAssignData = {
    /**
     * Role assignment
     */
    body: AssignRoleRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles';
};

export type UserTenantRolesAssignResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: UserRoleAssignmentResponse;
};

export type UserTenantRolesAssignResponse = UserTenantRolesAssignResponses[keyof UserTenantRolesAssignResponses];

export type UserTenantRolesRemoveData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * User ID
         */
        userId: string;
        /**
         * Role ID to remove
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/users/{userId}/roles/{roleId}';
};

export type UserTenantRolesRemoveResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type UserTenantRolesRemoveResponse = UserTenantRolesRemoveResponses[keyof UserTenantRolesRemoveResponses];

export type WebhooksListData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by active status
         */
        isActive?: boolean;
    };
    url: '/v1/orgs/{orgId}/webhooks';
};

export type WebhooksListResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookListResponse | ErrorResponse;
};

export type WebhooksListResponse = WebhooksListResponses[keyof WebhooksListResponses];

export type WebhooksCreateData = {
    /**
     * Webhook configuration
     */
    body: CreateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks';
};

export type WebhooksCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: WebhookCreatedResponse;
};

export type WebhooksCreateResponse = WebhooksCreateResponses[keyof WebhooksCreateResponses];

export type WebhooksListEventTypesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/event-types';
};

export type WebhooksListEventTypesResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookEventTypesResponse | ErrorResponse;
};

export type WebhooksListEventTypesResponse = WebhooksListEventTypesResponses[keyof WebhooksListEventTypesResponses];

export type WebhooksDeleteData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type WebhooksDeleteResponse = WebhooksDeleteResponses[keyof WebhooksDeleteResponses];

export type WebhooksGetData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksGetResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookResponse | ErrorResponse;
};

export type WebhooksGetResponse = WebhooksGetResponses[keyof WebhooksGetResponses];

export type WebhooksUpdateData = {
    /**
     * Update data
     */
    body: UpdateWebhookRequest;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}';
};

export type WebhooksUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookResponse | ErrorResponse;
};

export type WebhooksUpdateResponse = WebhooksUpdateResponses[keyof WebhooksUpdateResponses];

export type WebhooksListDeliveriesData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: {
        /**
         * Page number
         */
        page?: number;
        /**
         * Items per page
         */
        pageSize?: number;
        /**
         * Filter by status
         */
        status?: WebhookDeliveryStatus;
        /**
         * Filter by event type
         */
        eventType?: string;
        /**
         * Filter deliveries after this timestamp
         */
        createdAfter?: string;
    };
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries';
};

export type WebhooksListDeliveriesResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryListResponse | ErrorResponse;
};

export type WebhooksListDeliveriesResponse = WebhooksListDeliveriesResponses[keyof WebhooksListDeliveriesResponses];

export type WebhooksGetDeliveryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
        /**
         * Delivery ID
         */
        deliveryId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}';
};

export type WebhooksGetDeliveryResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryResponse | ErrorResponse;
};

export type WebhooksGetDeliveryResponse = WebhooksGetDeliveryResponses[keyof WebhooksGetDeliveryResponses];

export type WebhooksRetryDeliveryData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
        /**
         * Delivery ID
         */
        deliveryId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/deliveries/{deliveryId}/retry';
};

export type WebhooksRetryDeliveryResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookDeliveryResponse | ErrorResponse;
};

export type WebhooksRetryDeliveryResponse = WebhooksRetryDeliveryResponses[keyof WebhooksRetryDeliveryResponses];

export type WebhooksRotateSecretData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/rotate-secret';
};

export type WebhooksRotateSecretResponses = {
    /**
     * The request has succeeded.
     */
    200: WebhookCreatedResponse | ErrorResponse;
};

export type WebhooksRotateSecretResponse = WebhooksRotateSecretResponses[keyof WebhooksRotateSecretResponses];

export type WebhooksTestData = {
    body?: never;
    path: {
        /**
         * Organization ID
         */
        orgId: string;
        /**
         * Webhook ID
         */
        webhookId: string;
    };
    query?: never;
    url: '/v1/orgs/{orgId}/webhooks/{webhookId}/test';
};

export type WebhooksTestResponses = {
    /**
     * The request has succeeded.
     */
    200: {
        data: {
            /**
             * Whether the test was successful
             */
            success: boolean;
            /**
             * HTTP status code from the webhook endpoint
             */
            httpStatus?: number;
            /**
             * Response time in milliseconds
             */
            durationMs?: number;
            /**
             * Error message if failed
             */
            error?: string;
        };
        meta: ResponseMeta;
    } | ErrorResponse;
};

export type WebhooksTestResponse = WebhooksTestResponses[keyof WebhooksTestResponses];

export type NotificationPreferencesRoutesGetPreferencesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/preferences';
};

export type NotificationPreferencesRoutesGetPreferencesResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationPreferencesResponse | ErrorResponse;
};

export type NotificationPreferencesRoutesGetPreferencesResponse = NotificationPreferencesRoutesGetPreferencesResponses[keyof NotificationPreferencesRoutesGetPreferencesResponses];

export type NotificationPreferencesRoutesUpdatePreferencesData = {
    body: UpdatePreferencesRequest;
    path?: never;
    query?: never;
    url: '/v1/preferences';
};

export type NotificationPreferencesRoutesUpdatePreferencesResponses = {
    /**
     * The request has succeeded.
     */
    200: NotificationPreferencesResponse | ErrorResponse;
};

export type NotificationPreferencesRoutesUpdatePreferencesResponse = NotificationPreferencesRoutesUpdatePreferencesResponses[keyof NotificationPreferencesRoutesUpdatePreferencesResponses];

export type GlobalRolesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Page number (1-indexed)
         */
        page?: number;
        /**
         * Number of items per page
         */
        pageSize?: number;
        /**
         * Filter by system role status
         */
        isSystemRole?: boolean;
    };
    url: '/v1/roles';
};

export type GlobalRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleListResponse | ErrorResponse;
};

export type GlobalRolesListResponse = GlobalRolesListResponses[keyof GlobalRolesListResponses];

export type GlobalRolesCreateData = {
    /**
     * Role data
     */
    body: CreateRoleRequest;
    path?: never;
    query?: never;
    url: '/v1/roles';
};

export type GlobalRolesCreateResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * The request has succeeded and a new resource has been created as a result.
     */
    201: RoleResponse;
};

export type GlobalRolesCreateResponse = GlobalRolesCreateResponses[keyof GlobalRolesCreateResponses];

export type GlobalRolesDeleteData = {
    body?: never;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesDeleteResponses = {
    /**
     * The request has succeeded.
     */
    200: ErrorResponse;
    /**
     * There is no content to send for this request, but the headers may be useful.
     */
    204: void;
};

export type GlobalRolesDeleteResponse = GlobalRolesDeleteResponses[keyof GlobalRolesDeleteResponses];

export type GlobalRolesGetData = {
    body?: never;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesGetResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type GlobalRolesGetResponse = GlobalRolesGetResponses[keyof GlobalRolesGetResponses];

export type GlobalRolesUpdateData = {
    /**
     * Role update data
     */
    body: UpdateRoleRequest;
    path: {
        /**
         * Role ID
         */
        roleId: string;
    };
    query?: never;
    url: '/v1/roles/{roleId}';
};

export type GlobalRolesUpdateResponses = {
    /**
     * The request has succeeded.
     */
    200: RoleResponse | ErrorResponse;
};

export type GlobalRolesUpdateResponse = GlobalRolesUpdateResponses[keyof GlobalRolesUpdateResponses];

export type AvailableContextsListData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/me/available-contexts';
};

export type AvailableContextsListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserContextListResponse | ErrorResponse;
};

export type AvailableContextsListResponse = AvailableContextsListResponses[keyof AvailableContextsListResponses];

export type CurrentUserContextGetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/users/me/context';
};

export type CurrentUserContextGetResponses = {
    /**
     * The request has succeeded.
     */
    200: ActiveContextResponse | ErrorResponse;
};

export type CurrentUserContextGetResponse = CurrentUserContextGetResponses[keyof CurrentUserContextGetResponses];

export type ContextSwitchSwitchData = {
    /**
     * Target context
     */
    body: SwitchContextRequest;
    path?: never;
    query?: never;
    url: '/v1/users/me/switch-context';
};

export type ContextSwitchSwitchResponses = {
    /**
     * The request has succeeded.
     */
    200: SwitchContextResponse | ErrorResponse;
};

export type ContextSwitchSwitchResponse = ContextSwitchSwitchResponses[keyof ContextSwitchSwitchResponses];

export type AllUserRolesListData = {
    body?: never;
    path: {
        /**
         * User ID
         */
        userId: string;
    };
    query?: never;
    url: '/v1/users/{userId}/roles';
};

export type AllUserRolesListResponses = {
    /**
     * The request has succeeded.
     */
    200: UserRoleAssignmentListResponse | ErrorResponse;
};

export type AllUserRolesListResponse = AllUserRolesListResponses[keyof AllUserRolesListResponses];
